/* subgraph.c */     /* Checks whether a hypergraph is a subgraph of another */
#define VERSION "1.1 26-Apr-2017"
/* 1.1 26-Apr-2017 nm - add fflush(stdout) after all printf statements */
/* 1.0 15-Jan-2017 nm - transfer vector assignment suffix from ref MMP.
   See also 2 TODOs. */
/* 0.9 1-May-2016 nm remove gcc warnings; increase MAX_BLOCKS to 3000,
       MAX_ATOMS to 1000, MAX_BLOCK_SIZE to 16 */
/* 0.8 1-May-2016 nm linput() now allows unlimited input line length */
/* 0.7 27-Apr-2010 nm Added -ss (subset) option */

/* To run this program, type:
      subgraph < file1 > file2
   where
      file1 = input file with MMP diagrams in Brendan McKay's format
      file2 = output file saying whether input is a subgraph of Peres' MMP
   See  subgraph --help  for more options and explanation.
*/

/*****************************************************************************/
/*       Copyright (C) 2008  NORMAN D. MEGILL  <nm at alum.mit.edu>          */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/


#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>

/***********************************************************************/
/************ Start of "vstring" header stuff **************************/
/************ Do not touch anything in this section ********************/
/***********************************************************************/
typedef char* vstring;

/* String assignment - MUST be used to assign vstrings */
void let(vstring *target,vstring source);
/* String concatenation - last argument MUST be NULL */
vstring cat(vstring string1,...);

/* Emulate BASIC linput statement; returns NULL if EOF */
/* Note that linput assigns target string with let(&target,...) */
  /*
    BASIC:  linput "what";a$
    c:      linput(NULL,"what?",&a);

    BASIC:  linput #1,a$                        (error trap on EOF)
    c:      if (!linput(file1,NULL,&a)) break;  (break on EOF)

  */
/*vstring linput(FILE *stream,vstring ask,vstring *target);*/
int linput(FILE *stream, const char* ask, vstring *target);

/* Emulation of BASIC string functions */
vstring seg(vstring sin, long p1, long p2);
vstring mid(vstring sin, long p, long l);
vstring left(vstring sin, long n);
vstring right(vstring sin, long n);
vstring edit(vstring sin, long control);
vstring space(long n);
vstring string(long n, char c);
vstring chr(long n);
vstring xlate(vstring sin, vstring control);
vstring date(void);
vstring time_(void);
vstring num(double x);
vstring num1(double x);
vstring str(double x);
long len(vstring s);
long instr(long start, vstring sin, vstring s);
long rinstr(vstring string1, vstring string2);
long ascii_(vstring c);
double val(vstring s);
/* Emulation of PROGRESS string functions added 11/25/98 */
vstring entry(long element, vstring list);
long lookup(vstring expression, vstring list);
long numEntries(vstring list);
long entryPosition(long element, vstring list);
/* Print to log file as well as terminal if fplog opened */
void print2(char* fmt,...);
FILE *fplog = NULL;
/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode);
/* Bug check error */
void bug(int bugNum);
/* End of functions you should call directly */


/* Do not call the ones below directly */
/******* Special pupose routines for better
      memory allocation (use with caution) *******/
/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the vstring may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s);   /* Make string have temporary allocation to be
                                    released by next let() */
#define MAX_ALLOC_STACK 100
int tempAllocStackTop=0;        /* Top of stack for tempAlloc functon */
int startTempAllocStack=0;      /* Where to start freeing temporary allocation
                                    when let() is called (normally 0, except in
                                    special nested vstring functions) */
char *tempAllocStack[MAX_ALLOC_STACK];


/*****************************************************************************/
/*********************** End of "vstring" header stuff ***********************/
/*****************************************************************************/

/* Constants */

/* The reference MMP (hard-coded for now; later this could be an input
   parameter for a more general subhypergraph program) */
#define REF_MMP "1234,4567,789A,ABCD,DEFG,GHI1,12IJ,345K,678L,7LOG,68FH," \
   "1J9B,AMI2,4KCE,DN35,CDEN,IJK5,38KL,6BML,9EMN,CHNO,2JOF,9ABM,OFGH."


/* Mapping for MMP diagram atoms */
#define ATOM_MAP "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs" \
    "tuvwxyz!\"#$%&'()*-/:;<=>?@[\\]^_`{|}~"
/* Length of above string */
#define MAX_ATOMS 1000 /* was 90 */
/* Maximum number of blocks */
#define MAX_BLOCKS 3000 /* was 128 */
/* Minimum block size */
#define MIN_BLOCK_SIZE 2
/* Maximum block size */
#define MAX_BLOCK_SIZE 16 /* was 10 */

/* Global variables */
char oneLineDisplay = 0;
char verboseMode = 0;
char doubleInputMode = 0; /* 1 = input lines are of form input + " " + ref */
char subsetMode = 0;  /* Renormalize test diagram to be subset of ref */
char exchangeInpAndRef = 0; /* 1 = exchange input and ref before test */
char refFromFile = 0; /* 1 = -rf qualifier, with possibly multiple refs */
char noErrorCheck = 0;
long diagrams = 0;
long atomMapLen;
/* The following were taken out of testForSubgraph() since they need to
   be referenced externally */
/* To store input MMP */
long blocks;
long atoms;
long maxAtom;
char unconnectedFlag = 0;  /* Graph isn't connected (two or more sections) */
long blockSize[MAX_BLOCKS + 1];
long block[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
/* To store ref MMP */
/* (The 'static' is redundant, but needed if this array is ever put back into
   testForSubgraph()) */
/*static*/ long refBlock[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
long inpToRefBlockMap[MAX_BLOCKS + 1];

long backtrackCount = 0; /* For user information */
long totalBacktrackCount = 0; /* For user information */



/* Prototypes */
char testForSubgraph(vstring inputMMP, vstring refMMP);
vstring parseMMP(vstring MMPDiagram, char normalize);

vstring buildMMP(long blocks_, long *blockSize_,
    long (*block_)[MAX_BLOCK_SIZE + 1], char *aTOM_MAP,
    long atomMapLen_);
vstring extendedAtomName(long atom);



/******************** Main program *******************************************/

int main(int argc, char *argv[])
{

  /* Integer variable declarations */

  /* This is how you declare some strings you want to work with */
  /* They MUST be initialized to the empty string, never to anything else */
  vstring str1 = "";
  vstring str2 = "";
  vstring tmp = "";  /* Added 1-May-2016 */
  long arg;
  char success;
  FILE *fref = NULL;
  vstring inpMMP = "";
  vstring refMMP = "";
  vstring printInpMMP = "";
  vstring printRefMMP = "";
  long p, i, j, q;
  long refDiagrams = 0;
  long refDiagram = 0;

  vstring inpMMPPrefix = ""; /* 15-Jan-2017 nm */
  vstring inpMMPSuffix = ""; /* 15-Jan-2017 nm */
  vstring refMMPPrefix = ""; /* 15-Jan-2017 nm */
  vstring refMMPSuffix = ""; /* 15-Jan-2017 nm */

  /* if (strlen(ATOM_MAP) != MAX_ATOMS) bug(1); */
  atomMapLen = (long)strlen(ATOM_MAP); /* Do here to speed up its reuse */

  for (arg = 1; arg < argc; arg++) {
    if (!strcmp(argv[arg], "-1")) {
      oneLineDisplay = 1;
    } else if (!strcmp(argv[arg], "-ne")) {
      noErrorCheck = 1;
    /*
    } else if (!strcmp(argv[arg], "-v")) {
      verboseMode = 1;
    */


    /* Process options to read the reference diagram */
    } else if (!strcmp(argv[arg], "-r")) {
      arg++;
      /* Take reference diagram from field after "-r" */
      let(&refMMP, argv[arg]);
    } else if (!strcmp(argv[arg], "-rf")) {
      if (refMMP[0]) {
        fprintf(stderr,
   "?Only one of \"-r\" or \"-rf\" or \"-r1\" or \"-ir\" may be specified.\n");
        exit(1);
      }
      refFromFile = 1; /* Set flag there are possibly multiple refs */
      arg++;
      /* Take file with reference diagram from field after "-r" */
      fref = fopen(argv[arg], "r");
      if (fref == NULL) {
        fprintf(stderr,
            "?File \"%s\" could not be found or opened.\n", argv[arg]);
        exit(1);
      }
      /* Count the reference diagrams in the -rf file */
      refDiagrams = 0;
      while (linput(fref, NULL, &refMMP) != 0) {
        refDiagrams++;
      }
      if (refDiagrams == 0) {
        fprintf(stderr,
            "?File \"%s\" is empty.\n", argv[arg]);
        exit(1); /* NULL means EOF */
      }
      /*rewind(fref);*/ /* Reset to beginning of file */ /* Done before scan*/
      let(&refMMP, ""); /* The -rf fref scan will assign it */
    } else if (!strcmp(argv[arg], "-r1")) {
      if (refMMP[0]) {
        fprintf(stderr,
   "?Only one of \"-r\" or \"-rf\" or \"-r1\" or \"-ir\" may be specified.\n");
        exit(1);
      }
      /* Take reference diagram from first line in stdin (standard input) */
      if (linput(NULL, NULL, &refMMP) == 0) {
        fprintf(stderr,
            "?There are no input lines.\n");
        exit(1);
      }
      /* Clean off carriage return (for Windows/Cygwin) and spaces */
      let(&refMMP, edit(refMMP, 2 + 4));
    } else if (!strcmp(argv[arg], "-ir")) {
      if (refMMP[0]) {
        fprintf(stderr,
   "?Only one of \"-r\" or \"-rf\" or \"-r1\" or \"-ir\" may be specified.\n");
        exit(1);
      }
      /* Take reference diagram from 2nd field of each stdin input line */
      doubleInputMode = 1;
    /* (End of processing options to read the reference diagram */


    } else if (!strcmp(argv[arg], "-x")) {
      /* Swap input and reference before subgraph test */
      exchangeInpAndRef = 1;
    } else if (!strcmp(argv[arg], "-ss")) {
      /* Subset mode */
      subsetMode = 1;
    /* (End of processing options to read the reference diagram */


    } else if (!strcmp(argv[arg], "--help")) {
printf("subgraph.c  Version %s\n", VERSION);
printf("To run this program, type:\n");
/*
printf("   subgraph [-1] [-ne] [-v] < file1 > file2\n");
*/
printf(
"   subgraph [-1] [-ne] [-r ref | -rf reffile | -r1 | -ir] [-x]\n");
printf(
"       [-1] [-v] [-ss] < file1 > file2\n");
printf(
"where the optional qualifiers may be given in any order:\n");
printf(
"   -1 = display 1-line output for use with Unix pipe filters:  the output\n");
printf(
"     consists of pass/fail info followed by \":: \", then the input\n");
printf(
"     (potential) subgraph MMP, then \" \", then the reference hypergraph MMP.\n");
printf(
"     \"fails\" means \"the input MMP is not a subgraph of the reference MMP.\"\n");
printf(
"     When there are multiple references (-rf), each input line will\n");
printf(
"     turn into several output lines, one for each reference.\n");
printf(
"   -ne = skip some error checking for speedup\n");
/*
printf(
"   -v = verbose mode for debugging\n");
*/
printf(
"   -r = use the next argument as the reference diagram\n");
printf(
"   -rf = use the next argument as the file with the reference diagram(s)\n");
printf(
"   -r1 = use the first line from \"file1\" as the reference diagram\n");
printf(
"   -ir = \"file1\" format is input diagram + space + reference diagram\n");
printf(
"     (If none of -r, -rf, -r1, -ir then internal REF_MMP is used.)\n");
printf(
"   -x = exchange input and reference before the subgraph test.  E.g.\n");
printf(
"     \"subgraph -r 1234,4567. -x < file1\" will treat \"file1\" as a list\n");
printf(
"     of reference diagrams and test whether \"1234,4567.\" is a subgraph.\n");
printf(
"     Since -x may be confusing, the default output shows the detailed\n");
printf(
"     assumptions being made.\n");
printf(
"   -ss = reformat each input diagram to match a subset of the blocks\n");
printf(
"     in the reference diagram.  Note: -ss affects only the -1 mode.\n");
printf(
"     Only passing (subgraph) lines are reformatted.\n");
printf(
"   file1 = input file with hypergraphs in MMP diagram format\n");
printf(
"   file2 = output file with subgraph test results\n");
printf("For this help message, type:  subgraph --help\n");
printf("\n");
printf(
"Purpose:  This program determines whether an input hypergraph in MMP\n");
printf(
"diagram format is a subgraph of the specified reference hypergraph.\n");
printf(
"The MMP diagram notation is due to Brendan McKay and is the same as for\n");
printf(
"Greechie diagrams as described in the --help for the program latticeg.c\n");
printf("\n");
printf("Example of use:\n");
printf("  subgraph < test.mmp\n");
printf("where test.mmp contains the two lines:\n");
printf("  1234,4567.\n");
printf("  1234,1235.\n");
printf("corresponding to two diagrams, the first a subgraph of REF_MMP and\n");
printf("the second one not a subgraph.\n");
printf("\n");
printf("Special feature:  if the reference diagram has a vector assignment\n");
printf("suffix, and -ss is used, and the subgraph check passes, then the\n");
printf("suffix is transferred to the input diagram.  Vector assignments are\n");
printf("made with vecfind.c.  The unused vector assignments on the input\n");
printf("diagram can be trimmed by passing it through mmpshuffle.c.\n");
printf("Example:  subgraph -ss -r1 ref.mmp < input.mmp | mmpshuffle -na\n");
printf("\n");

printf(
"Acknowledgment:  Thanks to Brendan McKay for suggesting the main\n");
printf(
"isomorphic subgraph algorithm for hypergraphs.\n");
      goto return_point;
    } else {
      fprintf(stderr,
          "?Unrecognized option \"%s\"- type \"subgraph --help\" for usage\n",
          argv[arg]);
      exit(1);
    }
  }


  if (!doubleInputMode && !refFromFile) {
    if (!refMMP[0]) {
      /* None of -r, -rf, or -r1 was specified; use internal hard-coded ref */
      let(&refMMP, REF_MMP);
      if (!oneLineDisplay && !exchangeInpAndRef) {
        printf(
         "The reference diagram (hard-coded in the program as REF_MMP) is:\n");
        printf("  %s\n", refMMP);
#if __STDC__
        fflush(stdout);
#endif
      }
    } else {
      if (!oneLineDisplay && !exchangeInpAndRef) {
        printf("The reference diagram is:\n");
        printf("  %s\n", refMMP);
#if __STDC__
        fflush(stdout);
#endif
      }
    }
  }


  while (1) { /* Scan the < file1 (standard input) lines */
    /* Get line from standard input */
    if (linput(NULL, NULL, &str1) == 0) break; /* NULL means EOF */
    /* Clean off carriage return (for Windows files under Cygwin) and spaces */
    /* 4=remove cr/lf, 8=trim leading spaces, 16=reduce spaces, 128=trailing */
    /*let(&str1, edit(str1, 4 + 8 + 16 + 128));*/
    let(&str1, edit(str1, 4)); /* Just CR/LF */ /* 15-Jan-2016 nm */

    /* Special feature for debugging; maybe I'll make it permanent:
       if the first character of the line is '#', treat it as comment.
       However, right now the first line for -r1 is not handled, nor
       is any line of the -rf file. */
    if (str1[0] == '#') continue;

    diagrams++;


    /* 15-Jan-2017 nm */
    /* Get any prefix i.e. part of line before last space and any
       suffix i.e. part of line after "." */
    let(&inpMMPPrefix, "");
    let(&inpMMPSuffix, "");
    if (!doubleInputMode) {
      p = 0;
      while (1) {  /* Find last space */
        q = instr(p + 1, str1, " ");
        if (q == 0) break;
        p = q;
      }
      q = instr(p + 1, str1, "."); /* End of MMP, just before suffix */
      if (q == 0) {
        fprintf(stderr, "?Error: MMP #%ld doesn't end with period.\n", diagrams);
        exit(1);
      }
      if (p != 0) {
        let(&inpMMPPrefix, left(str1, p));
      }
      let(&inpMMPSuffix, right(str1, q + 1));
      let(&str1, seg(str1, p + 1, q));
    }


    if (refFromFile) {
      refDiagram = 0;
      rewind(fref); /* Reset to beginning of -rf file */
    }
    while (1) { /* Scan the -rf file (or just one pass if no -rf) */

      if (refFromFile) {
        /* Get the next reference MMP from the -rf file */
        if (linput(fref, NULL, &refMMP) == 0) break; /* NULL means EOF */
        /* Clean off carriage return (for Windows/Cygwin) and spaces */
        /*let(&refMMP, edit(refMMP, 2 + 4));*/
        let(&refMMP, edit(refMMP, 4)); /* Just CR/LF */ /* 15-Jan-2016 nm */
        refDiagram++;


        /* 15-Jan-2017 nm */
        /* Get any prefix i.e. part of line before last space and any
           suffix i.e. part of line after "." */
        let(&refMMPPrefix, "");
        let(&refMMPSuffix, "");
        p = 0;
        while (1) {  /* Find last space */
          q = instr(p + 1, refMMP, " ");
          if (q == 0) break;
          p = q;
        }
        q = instr(p + 1, refMMP, "."); /* End of MMP, just before suffix */
        if (q == 0) {
          fprintf(stderr, "?Error: Ref MMP #%ld doesn't end with period.\n",
              refDiagram);
          exit(1);
        }
        if (p != 0) {
          let(&refMMPPrefix, left(refMMP, p));
        }
        let(&refMMPSuffix, right(refMMP, q + 1));
        let(&refMMP, seg(refMMP, p + 1, q));


      }

      /* Assume input line is in the form inpMMP+" "+refMMP */
      if (doubleInputMode) {
        p = instr(1, str1, " ");
        q = instr(p + 1, str1, " "); /* 15-Jan-2017 nm */
        if (p == 0 || q != 0) {
          fprintf(stderr, "%s\n", str1);
          fprintf(stderr, !exchangeInpAndRef ?
  "?Format should be input diagram + space + reference diagram in -ir mode\n"
            :
  "?Format should be reference diagram + space + input diagram in -ir mode\n");
          exit(1);
        }

        /* 15-Jan-2017 nm */
        /* TODO Is this error-check needed?  Or do it earlier? */
        if (refMMPPrefix[0] != 0 || refMMPSuffix[0] != 0) {
          fprintf(stderr,
"The reference diagram may not have a vector assignment in \"-ir\" mode.\n");
          exit(1);
        }

        let(&inpMMP, left(str1, p - 1));
        let(&refMMP, right(str1, p + 1));
        if (!oneLineDisplay) {
          printf("The reference diagram for #%ld is:\n", diagrams);
          printf("  %s\n", !exchangeInpAndRef ? refMMP : inpMMP);
#if __STDC__
          fflush(stdout);
#endif
        }
      } else {
        let(&inpMMP, str1);
        if (exchangeInpAndRef || refFromFile) {
          if (!oneLineDisplay) {
            if (!refFromFile || refDiagrams == 1) {
              printf("The reference diagram for #%ld is:\n", diagrams);
            } else {
              printf(
                "Case %ld of %ld:  The reference diagram for #%ld below is:\n",
                  refDiagram, refDiagrams, diagrams);
            }
            printf("  %s\n", !exchangeInpAndRef ? refMMP : inpMMP);
#if __STDC__
            fflush(stdout);
#endif
          }
        }
      }

      if (!oneLineDisplay) {
        printf("#%ld %s\n", diagrams, !exchangeInpAndRef ? inpMMP : refMMP);
#if __STDC__
        fflush(stdout);
#endif
      }
      backtrackCount = 0;

      /********* Do the test ********/
      success = testForSubgraph(!exchangeInpAndRef ? inpMMP : refMMP,
           !exchangeInpAndRef ? refMMP : inpMMP);
                                        /* 1 = is subgraph, 0 = not subgraph */

      if (!oneLineDisplay) {
        if (!success) {
          printf(
           "  The above input diagram is not a subgraph of the reference.\n");
#if __STDC__
          fflush(stdout);
#endif
        }
      }
      if (oneLineDisplay) {

        if(!exchangeInpAndRef) {
          let(&printInpMMP, inpMMP);
          let(&printRefMMP, refMMP);
        } else {
          let(&printInpMMP, refMMP);
          let(&printRefMMP, inpMMP);
          /* 15-Jan-2017 nm */  /* Swap prefixes and suffixes */
          let(&str2, refMMPPrefix);
          let(&refMMPPrefix, inpMMPPrefix);
          let(&inpMMPPrefix, str2);
          let(&str2, refMMPSuffix);
          let(&refMMPSuffix, inpMMPSuffix);
          let(&inpMMPSuffix, str2);
        }

        if (subsetMode && success) {
          /* Reformat the input diagram to be a subset of the reference */
          /* Don't do this unless it is a subgraph, otherwise the mapping
             is meaningless */
          p = 0;
          for (i = 1; i <= blocks; i++) {
            for (j = 1; j <= blockSize[i]; j++) {
              /*
              printInpMMP[p] = ATOM_MAP[refBlock[inpToRefBlockMap[i]][j]-1];
              p++;
              */
              let(&tmp, "");
              tmp = extendedAtomName(refBlock[inpToRefBlockMap[i]][j]);
              for (q = 0; q < (long)strlen(tmp); q++) {
                printInpMMP[p] = tmp[q];
                p++;
              }
            }
            printInpMMP[p] = (i == blocks) ? '.' : ',';
            p++;
          }
          if (p != (long)strlen(!exchangeInpAndRef ? inpMMP : refMMP)) bug(801);
          if (printInpMMP[p] != 0) bug(802);
        }

        /* nm 8-Nov-2008 Make the 1-line output after "::" _always_ be the
           input MMP then space then the ref MMP */
        /* (was: "let(&str2, str1);") */
        if (refMMPSuffix[0] == 0) {
          let(&str2, cat(printInpMMP, " ", printRefMMP, NULL));
        } else {
          /* 15-Jan-2017 nm */
          if (subsetMode && success) {
            /* If there is a vector assignment suffix on the ref MMP, just
               print the subgraph with the assignment appended */
            let(&str2, cat(printInpMMP, refMMPSuffix, NULL));
          } else {
            /* If it fails or if the diagram wasn't renumbered, don't
               append vector assignment suffix */
            let(&str2, printInpMMP);
          }
        }

        if (!refFromFile) {
          /* #16 ((37)) passes:: 8HP,9KP,25A,23L,BCQ,5DN,7CL,9EN,67F,... */
          printf("#%ld ((%ld)) %s:: %s\n", diagrams, backtrackCount,
              success ? "passes" : "fails", str2);
        } else {
          /* #16 r#2 ((37)) passes:: 8HP,9KP,25A,23L,BCQ,5DN,7CL,9EN,67F,... */
          printf("#%ld %c#%ld ((%ld)) %s:: %s\n", diagrams,
              !exchangeInpAndRef ? 'r' : 'i',
              refDiagram,
              backtrackCount, success ? "passes" : "fails", str2);
        }
#if __STDC__
        fflush(stdout);
#endif
      } else {
        printf("  Backtrack count = %ld\n", backtrackCount);
#if __STDC__
        fflush(stdout);
#endif
      }
      totalBacktrackCount += backtrackCount;
      if (!refFromFile) break; /* not the -rf option, there is only 1 pass */
    } /* end while (1) for -rf file scan */
  } /* end while (1) for the stdin scan */

  if (!oneLineDisplay) {
    printf("Total diagrams = %ld  Total backtrack count = %ld",
        diagrams, totalBacktrackCount);
#ifdef CLOCKS_PER_SEC
    printf("  CPU time =%6.2f s", (double)clock()/CLOCKS_PER_SEC);
#endif
    printf("\n");
#if __STDC__
    fflush(stdout);
#endif
  }

 return_point:
  /* Deallocate vstring memory */
  let(&str1, "");
  let(&str2, "");
  let(&tmp, "");

  return 0;
} /* End of main() */


/* Caller must deallocate returned string. */
char testForSubgraph(vstring inputMMP, vstring refMMP)
{
  static char refParsed = 0; /* To save time if already parsed */
  static char refBlockUsesAtom[MAX_BLOCKS + 1][MAX_ATOMS + 1];

  /* To store reference REF_MMP */
  static long refBlocks;
  static long refAtoms;
  static long refBlockSize[MAX_BLOCKS + 1];

  static char blockUsesAtom[MAX_BLOCKS + 1][MAX_ATOMS + 1];
                                /* (static to avoid breaking stack) */
  long i, j, k, wblock, refAtom, inpAtom;
  char found = 0;
  char result; /* Returned value of testForSubgraph: 1 = has subgraph */
  vstring str1 = "";
  char refBlockUsed[MAX_BLOCKS + 1];
  char blockAtomTested[MAX_BLOCK_SIZE + 1];

  /* For user information */  /* (static to avoid breaking stack) */
  static long inpAtomToRefAtom[MAX_BLOCKS + 1][MAX_ATOMS + 1];
  static long refAtomToInpAtom[MAX_BLOCKS + 1][MAX_ATOMS + 1];

  vstring tmp = "";  /* added 1-May-2016 */

#define ONLY_ONE_REF_MMP 1
  /* Parse the reference hypergraph in MMP format */
  if (!ONLY_ONE_REF_MMP || !refParsed || doubleInputMode
      || exchangeInpAndRef || refFromFile) { /* Save time if already parsed */
    refParsed = 1;
    str1 = parseMMP(refMMP, 0 /* Don't normalize */);
    let(&str1, "");
    /* Transfer information to the reference storage */
    refAtoms = atoms;
    refBlocks = blocks;
    for (i = 1; i <= refBlocks; i++) {
      refBlockSize[i] = blockSize[i];
      for (j = 1; j <= refBlockSize[i]; j++) {
        refBlock[i][j] = block[i][j];
      }
    }
    /* Build the "block uses atom" table */
    for (i = 1; i <= refBlocks; i++) {
      for (j = 1; j <= refAtoms; j++) {
        refBlockUsesAtom[i][j] = 0;  /* Initialize */
      }
      for (j = 1; j <= refBlockSize[i]; j++) {
        refBlockUsesAtom[i][refBlock[i][j]] = 1; /* Set the flag */
      }
    }
  }

  /* Parse the input hypergraph in MMP format */
  str1 = parseMMP(inputMMP, 0 /* Don't normalize */);
  let(&str1, "");
  /* Build the "block uses atom" table */
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= atoms; j++) {
      blockUsesAtom[i][j] = 0;  /* Initialize */
    }
    for (j = 1; j <= blockSize[i]; j++) {
      blockUsesAtom[i][block[i][j]] = 1; /* Set the flag */
    }
  }

  if (blocks > refBlocks) {
    result = 0; /* input > ref not a subgraph */
    return result;
  }

  for (i = 1; i <= refBlocks; i++) {
    refBlockUsed[i] = 0; /* Initialize */
  }

  wblock = 1; /* Working block of input hypergraph */
  inpToRefBlockMap[wblock] = 0; /* Initialize input to ref block map */

  /* Initialize the user information mapping */
  /*
  for (i = 1; i <= atoms; i++) {
    inpAtomToRefAtom[wblock][i] = 0;
  }
  for (i = 1; i <= refAtoms; i++) {
    refAtomToInpAtom[wblock][i] = 0;
  }
  */

  /* Get next candidate from reference hypergraph */
  while (1) {
    inpToRefBlockMap[wblock]++;
    if (inpToRefBlockMap[wblock] > refBlocks) {
      /* Backtrack */
      backtrackCount++;
      wblock--;
      if (wblock == 0) {
        /* We've exhausted the backtracking; give up */
        result = 0;
        return result;
      }
      refBlockUsed[inpToRefBlockMap[wblock]] = 0;
      continue;
    }

    /* Find the next usable unassigned block from the reference */
    if (refBlockUsed[inpToRefBlockMap[wblock]]) { /* It's used by an earlier
                                                     input block */
      continue;
    }
    if (refBlockSize[inpToRefBlockMap[wblock]] != blockSize[wblock]) {
                 /* Size mismatch */
      continue;
    }

    /* See if we still have an isomorphism when the new block is added */
    for (i = 1; i <= blockSize[wblock]; i++) {
      /* We will set this flag for each successful atom connectivity test */
      blockAtomTested[i] = 0;
    }

    if (!oneLineDisplay) {
      /* Initialize the atom mapping information for this trial block */
      if (wblock == 1) {
        /* Initialize the user information mapping */
        for (i = 1; i <= atoms; i++) {
          inpAtomToRefAtom[wblock][i] = 0;
        }
        for (i = 1; i <= refAtoms; i++) {
          refAtomToInpAtom[wblock][i] = 0;
        }
      } else {
        /* Copy the user information atom mapping from the previous block */
        for (i = 1; i <= atoms; i++) {
          inpAtomToRefAtom[wblock][i] = inpAtomToRefAtom[wblock - 1][i];
        }
        for (i = 1; i <= refAtoms; i++) {
          refAtomToInpAtom[wblock][i] = refAtomToInpAtom[wblock - 1][i];
        }
      }
    }

    /* Scan each atom in the added ref block and see if there is an atom
       in the input block with the same connectivity */
    for (i = 1; i <= blockSize[wblock]; i++) {
      refAtom = refBlock[inpToRefBlockMap[wblock]][i];
      /* Scan the atoms in the corresponding input block */
      for (j = 1; j <= blockSize[wblock]; j++) {
        if (blockAtomTested[j]) continue;
        found = 1;
        /* Compare the connectivity with all previous blocks */
        inpAtom = block[wblock][j];
        for (k = 1; k < wblock; k++) {
          if (refBlockUsesAtom[inpToRefBlockMap[k]][refAtom]
              != blockUsesAtom[k][inpAtom]) {
            /* Connectivity match failed */
            found = 0;
            break;
          }
        }
        if (found) {
          /* This is a good connectivity match; use it */
          blockAtomTested[j] = 1;

          if (!oneLineDisplay) {
            /* Assign atom mapping for user info */
            if (inpAtomToRefAtom[wblock][inpAtom] == 0) {
              /* It hasn't been assigned yet */
              if (refAtomToInpAtom[wblock][refAtom] != 0) {

/*D*/ /* For debugging bug #2; can be removed */
/*D*/ /* WARNING: doesn't handle extended atom names!! */
/*D*/printf("rA %c iA %c r2i %c i2r %c wb %ld i2rbl %ld\n",
/*D*/ ATOM_MAP[refAtom-1],
/*D*/ ATOM_MAP[inpAtom-1],
/*D*/ ATOM_MAP[refAtomToInpAtom[wblock][refAtom]-1],
/*D*/ '?', /*ATOM_MAP[inpAtomToRefAtom[wblock][inpAtom]-1],*/
/*D*/ wblock,
/*D*/ inpToRefBlockMap[wblock]);

                bug(2);
              }
              inpAtomToRefAtom[wblock][inpAtom] = refAtom;
              refAtomToInpAtom[wblock][refAtom] = inpAtom;
            } else {
              /* If it changed, swap the mapping to keep it 1-to-1 */
              if (inpAtomToRefAtom[wblock][inpAtom] != refAtom) {
                if (refAtomToInpAtom[wblock][refAtom] == inpAtom) {
                  bug(3);
                }
                inpAtomToRefAtom[wblock][refAtomToInpAtom[wblock][refAtom]]
                    = inpAtomToRefAtom[wblock][inpAtom];
                refAtomToInpAtom[wblock][inpAtomToRefAtom[wblock][inpAtom]]
                    = refAtomToInpAtom[wblock][refAtom];
                inpAtomToRefAtom[wblock][inpAtom] = refAtom;
                refAtomToInpAtom[wblock][refAtom] = inpAtom;
              } else {
                if (refAtomToInpAtom[wblock][refAtom] != inpAtom) {
                  bug(4);
                }
              }
            } /* end if (inpAtomToRefAtom[wblock][inpAtom] == 0) else */
          } /* end if (!oneLineDisplay) */

          break;
        } /* end if (found) */
      } /* next j (atom in input hypergraph block) */
      if (!found) break;
    } /* next i (atom in ref hypergraph trial block) */
    if (!found) {
      /* There is an atom in the trial refBlock that has different
         connectivity from all atoms in the input block */
      continue;
    }

    /* We found a good ref hypergraph block to add.  Go on to next one. */
    /* Add the next block from the input hypergraph */
    refBlockUsed[inpToRefBlockMap[wblock]] = 1;
    wblock++;
    /* If we're past the last input hypergraph block we're done; success. */
    if (wblock > blocks) {
      result = 1;
      if (!oneLineDisplay) {
        printf(
"  Isomorphism:  ref block numbers, ref blocks, map to input block atoms:\n");

        /* Print the reference block numbers */
        let(&str1, "    ");
        for (i = 1; i <= blocks; i++) {
          let(&str1, cat(str1,
             space(i == 1 ? 0 : blockSize[inpToRefBlockMap[i - 1]] + 1 -
                 (long)strlen(str((double)inpToRefBlockMap[i - 1]))),
             str((double)inpToRefBlockMap[i]), NULL));
        }
        printf("%s\n", str1);
        let(&str1, ""); /* Deallocate */

        /* Print the reference blocks */
        printf("    ");
        for (i = 1; i <= blocks; i++) {
          for (j = 1; j <= blockSize[i]; j++) {
            /* printf("%c", ATOM_MAP[refBlock[inpToRefBlockMap[i]][j]-1]); */
            /* Added 1-May-2016 */
            let(&tmp, "");
            tmp = extendedAtomName(refBlock[inpToRefBlockMap[i]][j]);
            printf("%s", tmp);
            let(&tmp, ""); /* Memory leak protection */
          }
          printf("%c", i == blocks ? '.' : ',');
        }
        printf("\n");

        /* Print the corresponding atoms in the input blocks */
        printf("    ");
        for (i = 1; i <= blocks; i++) {
          for (j = 1; j <= blockSize[i]; j++) {
            k = refBlock[inpToRefBlockMap[i]][j];
            /* 15-Jan-2017 nm TODO: This doesn't seem right and doesn't
               print all atoms in 145,587. + OM1,1pa,5vt. */
            /* printf("%c", ATOM_MAP[refAtomToInpAtom[blocks][k]-1]); */
            /* Added 1-May-2016 */
            let(&tmp, "");
            tmp = extendedAtomName(refAtomToInpAtom[blocks][k]);
            printf("%s", tmp);
            let(&tmp, ""); /* vstring stack overflow protection */
          }
          printf("%c", i == blocks ? '.' : ',');
        }
        printf("\n");
#if __STDC__
        fflush(stdout);
#endif

      }
      return result;
    }

    /* Copy the user information atom mapping from the previous block */
    /*
    for (i = 1; i <= atoms; i++) {
      inpAtomToRefAtom[wblock][i] = inpAtomToRefAtom[wblock - 1][i];
    }
    for (i = 1; i <= refAtoms; i++) {
      refAtomToInpAtom[wblock][i] = refAtomToInpAtom[wblock - 1][i];
    }
    */

    inpToRefBlockMap[wblock] = 0; /* Initialize input to ref block map */
  } /* end while (1) */
} /* end of testForSubgraph() */

/* This function parses the input MMP diagram and assigns the following
   global variables and arrays:
     blocks = # blocks (edges)
     atoms = largest atom (vertex) #, starting at 1 (NOT necessarily the
             # of atoms though, if the input diagram skips atoms)
     blockSize[<block>]  <block> = 1,...,blocks
     block[<block>][<j>] = atom number, where <block> = 1,...,blocks,
                           <j> = 1,...,blockSize[]
*/
/* The version of parseMMP below was taken from mmptag.c on 1-May-2016 */
/* Caller must deallocate returned string. */
vstring parseMMP(vstring inputDiagram /* MMP diagram */,
    char normalize /* 0=don't, 1=do normalize output diagram */) {
  long i, j, k, m, n;
  vstring jptr;
  long extendedNotationIncr; /* For + notation */
  long extendedNotationOffset; /* For + notation */
  /*vstring atomRemap = "";*/ /* To fill in atom gaps */
  char blockConn[MAX_BLOCKS + 1]; /* Block connected flags */
  long atomRemap[MAX_ATOMS + 1]; /* To fill in atom gaps */
  char atomUsed[MAX_ATOMS + 1]; /* To count actual atoms */
  /*vstring inputDiagram = "";*/
  vstring str1 = "";
  vstring outputDiagram = "";

  /* extendedNotationIncr = strlen(ATOM_MAP); */ /* For + notation */
  extendedNotationIncr = atomMapLen; /*  For + notation (faster than strlen) */

  /*let(&inputDiagram, glattice);*/
  /*let(&inputDiagram, edit(glattice, 2));*/ /* Remove spaces */

  n = (long)strlen(inputDiagram);

  if (!noErrorCheck) {
    /* The calling routine should ensure this */
    if (strchr(inputDiagram, ' ') != NULL) {
      /* bug(14); */
      fprintf(stderr, "%s\n", inputDiagram);
      fprintf(stderr,
     "?Error: the input diagram has a space.  Did you forget \"mmptag -u\"?\n");
      exit(1);
    }
/*D*//*printf("%s\n",inputDiagram);*/
/*D*//*printf("n %ld\n",n);        */

    /* inputDiagram can't be a blank line */
    if (inputDiagram[0] == 0) {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr, "?Error: Blank lines are not allowed\n");
      exit(1);
    }

    /* inputDiagram must have ending period for new (Brendan) compact standard */
    if (inputDiagram[n - 1] != '.') {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr, "?Error: Last character should be a period\n");
      exit(1);
    }

    /* if (instr(1, left(inputDiagram, n - 1), ".") != 0) { */
    if (strchr(inputDiagram, '.') != inputDiagram + n - 1) {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr, "?Error: Period can only be last character\n");
      exit(1);
    }
    if (n == 1) {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr, "?Error: Diagram must have at least one block\n");
      exit(1);
    }
  }

  maxAtom = 0;
  blocks = 1;
  blockSize[blocks] = 0;
  extendedNotationOffset = 0; /* For + notation */
  for (i = 0; i < n; i++) {
    if (inputDiagram[i] == ',' || inputDiagram[i] == '.') {
      /* End of block */
      if (blockSize[blocks] < MIN_BLOCK_SIZE) {
        fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
        fprintf(stderr,
            "?Error: Block %ld has %ld atoms, but minimum block size is %ld\n",
             blocks, blockSize[blocks], (long)MIN_BLOCK_SIZE);
        exit(1);
      }
      if (inputDiagram[i] == ',') {
        /* Start of new block */
        blocks++;
        if (blocks > MAX_BLOCKS) {
          fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
          fprintf(stderr,
   "?Error: Maximum blocks allowed is %ld.  Increase MAX_BLOCKS in program.\n",
                (long)MAX_BLOCKS);
          exit(1);
        }
        blockSize[blocks] = 0;
      }
      continue;
    }

    if (inputDiagram[i] == '+') {
      /* Process the extended notation
         12...9A...Za...`{|}~+1+2...+|+}+~++1...++~+++1....
         From 23-Apr-2009 email to Mladen:
           "If in the far future we get to say 10000 atoms, that would be
           around 100 +'s per atom, obviously extremely inefficient.  But,
           we still have "0" unused, and can have an alternate (and
           compatible) notation where "0" is the start of a decimal number,
           with some non-digit, say ".", terminating it.  I'll leave a
           comment to that effect in the latticeg.c file, for when it
           becomes a problem for a future generation" */
      extendedNotationOffset += extendedNotationIncr;
      continue;
    }

    /* Get the atom number */
    /*j = instr(1, ATOM_MAP, chr(inputDiagram[i]));*/
    /*let(&str1, "");*/ /* Deallocate chr call */
    jptr = strchr(ATOM_MAP, inputDiagram[i]);
    if (jptr == NULL) {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr, "?Error: Illegal character '%c' in diagram\n",
          inputDiagram[i]);
      exit(1);
    }
    j = jptr - ATOM_MAP + 1; /* Atom number */
    j += extendedNotationOffset; /* For + notation */
    extendedNotationOffset = 0; /* For + notation - initialize for next atom */
    blockSize[blocks]++;
    if (blockSize[blocks] > MAX_BLOCK_SIZE) {
      fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
      fprintf(stderr,
           "?Error: Block %ld has %ld atoms, but maximum block size is %ld \n",
           blocks, blockSize[blocks], (long)MIN_BLOCK_SIZE);
      exit(1);
    }
    /* Assign the atom */
    block[blocks][blockSize[blocks]] = j;
    if (j > maxAtom) maxAtom = j; /* Maximum atom number */
  } /* next i */


  if (!noErrorCheck) {
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i] - 1; j++) {
        for (k = j + 1; k <= blockSize[i]; k++) {
          if (block[i][j] == block[i][k]) {
            fprintf(stderr, "#%ld: %s\n", diagrams, inputDiagram);
            fprintf(stderr,
                "?Error: Duplicate atom numbers in a block\n");
            exit(1);
          }
        }
      }
    }
  }

  /* Prevent compiler unused variable warnings due to stripped code below */
  /* let(&atomRemap, ""); */
  let(&str1, "");


  /********* Start of connectivity test *******/
  /* let(&blockConn, string(blocks + 1, 1)); */ /*old*/  /* Re-use the
                      blockConn string; start at ASCII 1, not 0, since 0
                      means end-of-string */
  for (i = 1; i <= blocks; i++) blockConn[i] = 1;
  blockConn[1] = 2; /* 1 = not connected to 1st block; 2 = connected;
                       3 = connected and we've processed it */
  /* Starting with block one, flag all blocks connected to it, then
     connected to all flagged blocks, etc. until nothing changes */
  n = 1;
  while (n) {
    n = 0;
    for (i = 1; i <= blocks; i++) {
      if (blockConn[i] == 2) { /* Look at blocks added to list so far */
        for (j = 1; j <= blockSize[i]; j++) {
          for (k = 1; k <= blocks; k++) {
            if (blockConn[k] == 1) { /* Look remaining unconnected blocks */
              for (m = 1; m <= blockSize[k]; m++) {
                if (block[i][j] == block[k][m]) {
                  blockConn[k] = 2; /* Block is connected */
                  n = 1; /* Flag that something changed */
                  break;
                }
              }
            }
          } /* next k */
        } /* next j */
        blockConn[i] = 3; /* Flag it as processed */
      }
    } /* next i */
  } /* end while */
  unconnectedFlag = 0;  /* Global flag */
  for (i = 1; i <= blocks; i++) {
    if (blockConn[i] < 2) {
      unconnectedFlag = 1; /* Graph isn't connected */
      break;
    }
  }
  /* let(&blockConn, ""); */ /* Deallocate memory */
  /********* End of connectivity test *******/


  /********* Start of canonical atom renaming section *******/

  /* Count gaps in atom numbering */
  for (i = 1; i <= maxAtom; i++) {
    atomUsed[i] = 0;
  }

  /*let(&atomUsed, string(maxAtom + 1, '0'));*/ /* obsolete */
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      atomUsed[block[i][j]] = 1;
    }
  }
  n = 0; /* Number of gaps in atom numbering */
  for (i = 1; i <= maxAtom; i++) {
    if (atomUsed[i] == 0) n++;
  }
  atoms = maxAtom - n; /* True number of atoms, even if gaps */

  /* Error if gaps in numbering */
  /* 24-Apr-09 - gaps in atom numbering are now allowed */
  /*
  if (n > 0) {
    print2("%s: %s\n", latticeName, inputDiagram);
    print2("?Error: There are gaps in atom numbering\n");
    exit(0);
  }
  */

  if (normalize) { /* Skip renumbering */
    /***/
    /* If there are gaps, remap the atoms to fill in the gaps */
    if (n > 0) {
      /* 25-Sep-2009 This is taken from states.c, where atomRemap is
         wideString */
      /* It must be changed to wideString for > 127 (?) atoms */
      /* if (atoms >= 127) bug(15); */ /* Need to switch to wideString */
      /* 19-Apr-2010 We now use an array from atomRemap so we don't
         need the wideString stuff */
      /* (Here is the intended use of atomRemap[]) */
      /*let(&atomRemap, string(maxAtom + 1, '?'));*/ /*old*/
      for (i = 1; i <= maxAtom; i++) atomRemap[i] = '?';
      j = 0;
      for (i = 1; i <= maxAtom; i++) {
        if (atomUsed[i] == 1) {
          j++; /* Atom is used */
          atomRemap[i] = j;
        }
      }
      if (maxAtom - j != n) bug(16); /* Sanity check */
      maxAtom = j; /* True number of atoms, with no gaps */
      if (maxAtom != atoms) bug(19);
      for (i = 1; i <= blocks; i++) {
        for (j = 1; j <= blockSize[i]; j++) {
          block[i][j] = atomRemap[block[i][j]];
        }
      }
      /*let(&atomRemap, "");*/ /* Deallocate memory */
    }
    /***/
    /* Renumber the atoms starting at 1 from left to right */
    /* This will make sort | uniq find more duplicates to ignore */
    /* See wideString warning above */
    /*let(&atomRemap, string(maxAtom + 1, 127));*/
    for (i = 1; i <= maxAtom; i++) atomRemap[i] = -1; /* -1 = "not an atom" */
    k = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        /* if (atomRemap[block[i][j]] == 127) { */
        if (atomRemap[block[i][j]] == -1) {
          k++;
          /* if (k == 127) bug(17); */
          atomRemap[block[i][j]] = k;
        }
        block[i][j] = atomRemap[block[i][j]];
      }
    }
    /* let(&atomRemap, ""); */
    n = 1;  /* Force the diagram to be rewritten below */
  } /* if normalize */
  /********* End of canonical atom renaming section *******/


/*
  /@ See if there are isolated blocks @/
  unconnectedBlockFlag = 0;  /@ Global flag @/
  let(&atomRemap, string(maxAtom + 1, 1)); /@ Start at ASCII 1, not 0; @/
               /@ otherwise, there is some weird stack dump behavior @/
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      atomRemap[block[i][j]]++;  /@ Number of blocks used by this atom @/
    }
  }
  for (i = 1; i <= blocks; i++) {
    k = 0; /@ Flag that atom used by more than one block @/
    for (j = 1; j <= blockSize[i]; j++) {
      if (atomRemap[block[i][j]] > 2) {
        k = 1; /@ Atom is used by more than one block @/
        break;
      }
    }
    if (k == 0) {
      unconnectedBlockFlag = 1;
      break;
    }
  }
  let(&atomRemap, ""); /@ Deallocate memory @/
*/


  if (!normalize) n = 0; /* Skip renumbering below */

  /* This is the global greechie diagram for use wherever
     we want to print it out. */
  /* if (instr(1, inputDiagram, ".") == 0 */
  if (strchr(inputDiagram, '.') == NULL
                          /* No period - assume old standard:  3-atom blocks */
         || n > 0) {
             /* Also, if there are atom numbering gaps, rewrite the diagram. */
    /* First, compute the size of the new diagram */
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > atomMapLen) {
          /* Handle extended notation */
          m++;
          k -= atomMapLen;
        }
        m++;
      }
      m++;
    }
    let(&outputDiagram, space(m)); /* Preallocate string to computed size */
    /* Next, fill in the characters */
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > atomMapLen) {
          /* Handle extended notation */
          outputDiagram[m] = '+';
          m++;
          k -= atomMapLen;
        }
        outputDiagram[m] = ATOM_MAP[k - 1];
        m++;
      }
      if (i < blocks) {
        outputDiagram[m] = ',';
        m++;
      } else {
        outputDiagram[m] = '.';
        m++;
      }
    }
    if (outputDiagram[m] != 0) bug(18); /* Must be end of string */
  } else {
    /* It is already in the new compact form */
    let(&outputDiagram, inputDiagram);
  }

  /* Deallocate strings */
  let(&str1, "");
  /*let(&inputDiagram, "");*/

  /* The caller must deallocate outputDiagram */
  return outputDiagram;
} /* parseMMP */


/* The following function is from mmpshuffle.c, added 1-May-2016 */

/* Build an MMP diagram from input:  blocks, blockSize[], block[][],
   ATOM_MAP, and atomMapLen */
/* User must deallocate returned string */
vstring buildMMP(long blocks_, long *blockSize_,
    long (*block_)[MAX_BLOCK_SIZE + 1], char *aTOM_MAP,
    long atomMapLen_) {
  long m, b, ba, a, extendedNotationIncr;
  vstring newMMP = "";
  /* extendedNotationIncr = strlen(aTOM_MAP); */ /* For + notation */
  extendedNotationIncr = atomMapLen_; /*  For + notation (faster than strlen) */
  /* First, we compute the size of the new MMP diagram */
  m = 0; /* Pointer to MMP diagram character */
  for (b = 1; b <= blocks_; b++) {
    for (ba = 1; ba <= blockSize_[b]; ba++) {
      a = block_[b][ba]; /* Atom in block */
      while (a > extendedNotationIncr) {
        /* Handle extended notation */
        m++;
        a -= extendedNotationIncr;
      }
      m++;
    }
    m++;
  }
  let(&newMMP, space(m)); /* Preallocate string to computed size */
  /* Next, fill in the characters */
  m = 0;  /* Pointer to MMP diagram character */
  for (b = 1; b <= blocks_; b++) {
    for (ba = 1; ba <= blockSize_[b]; ba++) {
      a = block_[b][ba]; /* Atom */
      while (a > extendedNotationIncr) {
        /* Handle extended notation */
        if (newMMP[m] != ' ') bug(206);
        newMMP[m] = '+';
        m++;
        a -= extendedNotationIncr;
      }
      if (newMMP[m] != ' ') bug(207);
      newMMP[m] = aTOM_MAP[a - 1];
      m++;
    }
    if (newMMP[m] != ' ') bug(208);
    newMMP[m] = ',';
    m++;
  }
  if (newMMP[m] != 0) bug(210); /* Should be end of string */
  if (m == 0) bug(212);
  if (newMMP[m - 1] != ',') bug(213);
  newMMP[m - 1] = '.';
     /* This global is updated for possible later use so we don't have to
        call parseMMP again, but the other block_[] structure entries
        are NOT valid! */
  return newMMP; /* Caller must deallocate */
} /* buildMMP */


/* Added 25-Dec-2013 nm */
/* Get the extended notation name of a single atom */
/* The user must deallocate the output string */
/* This function is inefficient but is not expected to be used often;
   if it is, it can be rewritten to implement the buildMMP algorithm
   directly. */
vstring extendedAtomName(long atom) {
  long block_[2][MAX_BLOCK_SIZE + 1];
  long blockSize_[2];
  long blocks_ = 1;
  vstring newMMP = "";
  blockSize_[1] = 1;
  block_[1][1] = atom;
  /* Build the new MMP diagram */
  /* New 25-Dec-2013 */
  let(&newMMP, "");
  newMMP = buildMMP(blocks_, blockSize_, block_, ATOM_MAP, atomMapLen);
  let(&newMMP, left(newMMP, (long)strlen(newMMP) - 1)); /* Remove period */
  return newMMP;
} /* extendedAtomName */




/******************* End of main program ********************************/


/***********************************************************************/
/************ Start of "vstring" body stuff ****************************/
/************ Do not touch anything from here to end of program ********/
/***********************************************************************/

/*****************************************************************************/
/*       Copyright (C) 1999  NORMAN D. MEGILL  <nm at alum.mit.edu>          */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/

/**************************************************************************

Variable-length string handler
------------------------------

     This collection of string-handling functions emulate most of the
string functions of VMS BASIC.  The objects manipulated by these functions
are strings of a special type called 'vstring' which
have no pre-defined upper length limit but are dynamically allocated
and deallocated as needed.  To use the vstring functions within a program,
all vstrings must be initially set to the null string when declared or
before first used, for example:

        vstring string1 = "";
        vstring stringArray[] = {"","",""};

        vstring bigArray[100][10]; /- Must be initialized before using -/
        int i,j;
        for (i=0; i<100; i++)
          for (j=0; j<10; j++)
            bigArray[i][j] = ""; /- Initialize -/


     After initialization, vstrings should be assigned with the 'let(&'
function only; for example the statements

        let(&string1,"abc");
        let(&string1,string2);
        let(&string1,left(string2,3));

all assign the second argument to 'string1'.  The 'let(&' function must
not be used to initialize a vstring for the first time.

     The 'cat' function emulates the '+' concatenation operator in BASIC.
It has a variable number of arguments, and the last argument should always
be NULL.  For example,

        let(&string1,cat("abc","def",NULL));

assigns "abcdef" to 'string1'.  Warning: 0 will work instead of NULL on the
VAX but not on the Macintosh, so always use NULL.

     All other functions are generally used exactly like their BASIC
equivalents.  For example, the BASIC statement

        let string1$=left$("def",len(right$("xxx",2)))+"ghi"+string2$

is emulated in c as

        let(&string1,cat(left("def",len(right("xxx",2))),"ghi",string2,NULL));

Note that ANSI c does not allow "$" as part of an identifier
name, so the names in c have had the "$" suffix removed.

     The string arguments of the vstring functions may be either standard c
strings or vstrings (except that the first argument of the 'let(&' function
must be a vstring).  The standard c string functions may use vstrings or
vstring functions as their string arguments, as long as the vstring variable
itself (which is a char * pointer) is not modified and no attempt is made to
increase the length of a vstring.  Caution must be excercised when
assigning standard c string pointers to vstrings or the results of
vstring functions, as the memory space may be deallocated when the
'le(&t' function is next executed.  For example,

        char *stdstr; /- A standard c string pointer -/
         ...
        stdstr=left("abc",2);  /- DO NOT DO THIS -/

will assign "ab" to 'stdstr', but this assignment will be lost when the
next 'let(&' function is executed.  To be safe, use 'strcpy':

        char stdstr1[80]; /- A fixed length standard c string -/
         ...
        strcpy(stdstr1,left("abc",2));

Here, of course, the user must ensure that the string copied to 'stdstr1'
does not exceed 79 characters in length.  IT IS SAFEST NOT TO USE ANY
STANDARD C STRING FUNCTIONS WITH VSTRINGS OR VSTRING FUNCTIONS UNLESS YOU
REALLY UNDERSTAND WHAT YOU ARE DOING.

     The vstring functions ('left', 'right', 'cat', etc.) allocate temporary
memory whenever they are called.  This temporary memory is deallocated
whenever a 'let(&' assignment is made.  The user should be aware of this
when using vstring functions outside of 'let(&' assignments; for example

        for (i=0; i<10000; i++)
          print2("%s\n",left(string1,70));

will allocate another 70 bytes or so of memory each 'left' call
and eventually overflow the temporary string stack.
If necessary, dummy 'let(&' assignments can be made periodically to clear
this temporary memory:

        for (i=0; i<10000; i++)
          {
          print2("%s\n",left(string1,70));
          let(&dummy,"");
          }

It should be noted that the 'linput' function assigns its target string
with 'let(&' and thus has the same deallocation effect as 'let(&'.

************************************************************************/


static void freeTempAlloc(void)
{
  /* All memory previously allocated with tempAlloc is deallocated. */
  /* EXCEPT:  When startTempAllocStack != 0, the freeing will start at
     startTempAllocStack. */
  int i;
  for (i = startTempAllocStack; i < tempAllocStackTop; i++) {
    free(tempAllocStack[i]);
  }
  tempAllocStackTop = startTempAllocStack;
} /* freeTempAlloc */


static void pushTempAlloc(void *mem)
{
  if (tempAllocStackTop >= (MAX_ALLOC_STACK-1)) {
    printf("*** FATAL ERROR ***  Temporary string stack overflow\n");
#if __STDC__
    fflush(stdout);
#endif
    bug(2201);
  }
  tempAllocStack[tempAllocStackTop++] = mem;
} /* pushTempAlloc */


static void* tempAlloc(long size)  /* String memory allocation/deallocation */
{
  void* memptr = malloc((size_t)size);
  if (!memptr || size == 0) {
    printf("*** FATAL ERROR ***  Temporary string allocation failed\n");
#if __STDC__
    fflush(stdout);
#endif
    bug(2202);
  }
  pushTempAlloc(memptr);
  return memptr;
} /* tempAlloc */


/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the vstring may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s)
{
  pushTempAlloc(s);
} /* makeTempAlloc */


/* 8-Jul-2013 Wolf Lammen - rewritten to simplify it */
void let(vstring *target, vstring source)        /* String assignment */
/* This function must ALWAYS be called to make assignment to */
/* a vstring in order for the memory cleanup routines, etc. */
/* to work properly.  If a vstring has never been assigned before, */
/* it is the user's responsibility to initialize it to "" (the */
/* null string). */
{

  size_t sourceLength = strlen(source);  /* Save its length */
  size_t targetLength = strlen(*target); /* Save its length */
  if (targetLength < sourceLength) { /* Old string has not enough room for new one */
    /* Free old string space and allocate new space */
    if (targetLength)
      free(*target);  /* Free old space */
    *target = malloc(sourceLength + 1); /* Allocate new space */
    if (!*target) {
      printf("*** FATAL ERROR ***  String memory couldn't be allocated\n");
#if __STDC__
      fflush(stdout);
#endif
      bug(2204);
    }
  }
  if (sourceLength) {
    strcpy(*target, source);
  } else {
    /* Empty strings could still be temporaries, so always assign a constant */
    if (targetLength) {
      free(*target);
    }
    *target= "";
  }

  freeTempAlloc(); /* Free up temporary strings used in expression computation */

} /* let */

vstring cat(vstring string1,...)        /* String concatenation */
#define MAX_CAT_ARGS 50
{
  va_list ap;   /* Declare list incrementer */
  vstring arg[MAX_CAT_ARGS];    /* Array to store arguments */
  size_t argPos[MAX_CAT_ARGS]; /* Array of argument positions in result */
  vstring result;
  int i;
  int numArgs = 0;        /* Define "last argument" */

  size_t pos = 0;
  char* curArg = string1;

  va_start(ap, string1); /* Begin the session */
  do {
        /* User-provided argument list must terminate with 0 */
    if (numArgs >= MAX_CAT_ARGS) {
      printf("*** FATAL ERROR ***  Too many cat() arguments\n");
#if __STDC__
      fflush(stdout);
#endif
      bug(2206);
    }
    arg[numArgs] = curArg;
    argPos[numArgs] = pos;
    pos += strlen(curArg);
  } while (++numArgs, (curArg = va_arg(ap,char *)) != 0);
  va_end(ap);           /* End var args session */

  /* Allocate the memory for it */
  result = tempAlloc((long)pos+1);
  /* Move the strings into the newly allocated area */
  for (i = 0; i < numArgs; ++i)
    strcpy(result + argPos[i], arg[i]);
  return result;
} /* cat */


/* 20-Oct-2013 Wolf Lammen - allow unlimited input line lengths */
/* Input a line from the user or from a file */
/* Returns 1 if a (possibly empty) line was successfully read, 0 if EOF */
int linput(FILE *stream, const char* ask, vstring *target)
{                           /* Note: "vstring *target" means "char **target" */
  /*
    BASIC:  linput "what"; a$
    c:      linput(NULL, "what?", &a);

    BASIC:  linput #1, a$                         (error trap on EOF)
    c:      if (!linput(file1, NULL, &a)) break;  (break on EOF)

  */
  /* This function prints a prompt (if 'ask' is not NULL), gets a line from
    the stream, and assigns it to target using the let(&...) function.
    0 is returned when end-of-file is encountered.  The vstring
    *target MUST be initialized to "" or previously assigned by let(&...)
    before using it in linput. */
  char f[10001]; /* Read in chunks up to 10000 characters */
  int result = 0;
  int eol_found = 0;
  if (ask) {
    printf("%s", ask);
#if __STDC__
    fflush(stdout);
#endif
  }
  if (stream == NULL) stream = stdin;
  while (!eol_found && fgets(f, sizeof(f), stream))
  {
    size_t endpos = strlen(f) - 1;
    eol_found = (f[endpos] == '\n');
    /* If the last line in the file has no newline, eol_found will be 0 here.
       The fgets() above will return 0 and prevent another loop iteration. */
    if (eol_found)
      f[endpos] = 0; /* The return string will have any newline stripped. */
    if (result)
      /* Append additional parts of the line to *target */
      /* The let() reallocates *target and copies the concatenation of the
         old *target and the additional input f[] to it */
      let(target /* = &(*target) */, cat(*target, f, NULL));
    else
      /* This is the first time through the loop, and normally
         the only one unless the input line overflows f[] */
      let(target, f);  /* Allocate *target and copy f to it */
    result = 1;
  }
  return result;
} /* linput */


/* Find out the length of a string */
long len(vstring s)
{
  return ((long)strlen(s));
} /* len */


/* Extract sin from character position start to stop into sout */
vstring seg(vstring sin, long start, long stop)
{
  if (start < 1) start = 1;
  return mid(sin, start, stop - start + 1);
} /* seg */


/* Extract sin from character position start for length len */
vstring mid(vstring sin, long start, long length)
{
  vstring sout;
  if (start < 1) start = 1;
  if (length < 0) length = 0;
  sout=tempAlloc(length + 1);
  strncpy(sout,sin + start - 1, (size_t)length);
  sout[length] = 0;
  return (sout);
} /* mid */


/* Extract leftmost n characters */
vstring left(vstring sin,long n)
{
  return mid(sin, 1, n);
} /* left */


/* Extract after character n */
vstring right(vstring sin, long n)
{
  return seg(sin, n, (long)(strlen(sin)));
} /* right */


/* Emulate VMS BASIC edit$ command */
vstring edit(vstring sin,long control)
#define isblank_(c) ((c==' ') || (c=='\t'))
    /* 11-Sep-2009 nm Added _ to fix '"isblank" redefined' compiler warning */
{
  /* EDIT$ (from VMS BASIC manual)
       Syntax:  str-vbl = EDIT$(str-exp, int-exp)
       Values   Effect
       1        Trim parity bits
       2        Discard all spaces and tabs
       4        Discard characters: CR, LF, FF, ESC, RUBOUT, and NULL
       8        Discard leading spaces and tabs
       16       Reduce spaces and tabs to one space
       32       Convert lowercase to uppercase
       64       Convert [ to ( and ] to )
       128      Discard trailing spaces and tabs
       256      Do not alter characters inside quotes

       (non-BASIC extensions)
       512      Convert uppercase to lowercase
       1024     Tab the line (convert spaces to equivalent tabs)
       2048     Untab the line (convert tabs to equivalent spaces)
       4096     Convert VT220 screen print frame graphics to -,|,+ characters

       (Added 10/24/03:)
       8192     Discard CR only (to assist DOS-to-Unix conversion)
  */
  vstring sout;
  long i, j, k, m;
  int last_char_is_blank;
  int trim_flag, discardctrl_flag, bracket_flag, quote_flag, case_flag;
  int alldiscard_flag, leaddiscard_flag, traildiscard_flag, reduce_flag;
  int processing_inside_quote=0;
  int lowercase_flag, tab_flag, untab_flag, screen_flag, discardcr_flag;
  unsigned char graphicsChar;

  /* Set up the flags */
  trim_flag = control & 1;
  alldiscard_flag = control & 2;
  discardctrl_flag = control & 4;
  leaddiscard_flag = control & 8;
  reduce_flag = control & 16;
  case_flag = control & 32;
  bracket_flag = control & 64;
  traildiscard_flag = control & 128;
  quote_flag = control & 256;

  /* Non-BASIC extensions */
  lowercase_flag = control & 512;
  tab_flag = control & 1024;
  untab_flag = control & 2048;
  screen_flag = control & 4096; /* Convert VT220 screen prints to |,-,+
                                   format */
  discardcr_flag = control & 8192; /* Discard CR's */

  /* Copy string */
  i = (long)strlen(sin) + 1;
  if (untab_flag) i = i * 7; /* Allow for max possible length */
  sout=tempAlloc(i);
  strcpy(sout,sin);

  /* Discard leading space/tab */
  i=0;
  if (leaddiscard_flag)
    while ((sout[i] != 0) && isblank_(sout[i]))
      sout[i++] = 0;

  /* Main processing loop */
  while (sout[i] != 0) {

    /* Alter characters inside quotes ? */
    if (quote_flag && ((sout[i] == '"') || (sout[i] == '\'')))
       processing_inside_quote = ~ processing_inside_quote;
    if (processing_inside_quote) {
       /* Skip the rest of the code and continue to process next character */
       i++; continue;
    }

    /* Discard all space/tab */
    if ((alldiscard_flag) && isblank_(sout[i]))
        sout[i] = 0;

    /* Trim parity (eighth?) bit */
    if (trim_flag)
       sout[i] = sout[i] & 0x7F;

    /* Discard CR,LF,FF,ESC,BS */
    if ((discardctrl_flag) && (
         (sout[i] == '\015') || /* CR  */
         (sout[i] == '\012') || /* LF  */
         (sout[i] == '\014') || /* FF  */
         (sout[i] == '\033') || /* ESC */
         /*(sout[i] == '\032') ||*/ /* ^Z */ /* DIFFERENCE won't work w/ this */
         (sout[i] == '\010')))  /* BS  */
      sout[i] = 0;

    /* Discard CR */
    if ((discardcr_flag) && (
         (sout[i] == '\015')))  /* CR  */
      sout[i] = 0;

    /* Convert lowercase to uppercase */
    /*
    if ((case_flag) && (islower(sout[i])))
       sout[i] = toupper(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((case_flag) && (sout[i] >= 'a' && sout[i] <= 'z'))
       sout[i] = (char)(sout[i] - ('a' - 'A'));

    /* Convert [] to () */
    if ((bracket_flag) && (sout[i] == '['))
       sout[i] = '(';
    if ((bracket_flag) && (sout[i] == ']'))
       sout[i] = ')';

    /* Convert uppercase to lowercase */
    /*
    if ((lowercase_flag) && (isupper(sout[i])))
       sout[i] = tolower(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((lowercase_flag) && (sout[i] >= 'A' && sout[i] <= 'Z'))
       sout[i] = (char)(sout[i] + ('a' - 'A'));

    /* Convert VT220 screen print frame graphics to +,|,- */
    if (screen_flag) {
      graphicsChar = (unsigned char)sout[i]; /* Need unsigned char for >127 */
      /* vt220 */
      if (graphicsChar >= 234 && graphicsChar <= 237) sout[i] = '+';
      if (graphicsChar == 241) sout[i] = '-';
      if (graphicsChar == 248) sout[i] = '|';
      if (graphicsChar == 166) sout[i] = '|';
      /* vt100 */
      if (graphicsChar == 218 /*up left*/ || graphicsChar == 217 /*lo r*/
          || graphicsChar == 191 /*up r*/ || graphicsChar == 192 /*lo l*/)
        sout[i] = '+';
      if (graphicsChar == 196) sout[i] = '-';
      if (graphicsChar == 179) sout[i] = '|';
    }

    /* Process next character */
    i++;
  }
  /* sout[i]=0 is the last character at this point */

  /* Clean up the deleted characters */
  for (j = 0, k = 0; j <= i; j++)
    if (sout[j]!=0) sout[k++]=sout[j];
  sout[k] = 0;
  /* sout[k] = 0 is the last character at this point */

  /* Discard trailing space/tab */
  if (traildiscard_flag) {
    --k;
    while ((k >= 0) && isblank_(sout[k])) --k;
    sout[++k] = 0;
  }

  /* Reduce multiple space/tab to a single space */
  if (reduce_flag) {
    i = j = last_char_is_blank = 0;
    while (i <= k - 1) {
      if (!isblank_(sout[i])) {
        sout[j++] = sout[i++];
        last_char_is_blank = 0;
      } else {
        if (!last_char_is_blank)
          sout[j++]=' '; /* Insert a space at the first occurrence of a blank */
        last_char_is_blank = 1; /* Register that a blank is found */
        i++; /* Process next character */
      }
    }
    sout[j] = 0;
  }

  /* Untab the line */
  if (untab_flag || tab_flag) {

    /*
    DEF FNUNTAB$(L$)      ! UNTAB LINE L$
    I9%=1%
    I9%=INSTR(I9%,L$,CHR$(9%))
    WHILE I9%
      L$=LEFT(L$,I9%-1%)+SPACE$(8%-((I9%-1%) AND 7%))+RIGHT(L$,I9%+1%)
      I9%=INSTR(I9%,L$,CHR$(9%))
    NEXT
    FNUNTAB$=L$
    FNEND
    */

    /***** old code (doesn't handle multiple lines)
    k = (long)strlen(sout);
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((i - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((i - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((i - 1) & 7);
    }
    *****/

    /* Untab string containing multiple lines */ /* 9-Jul-2011 nm */
    /* (Currently this is needed by outputStatement() in mmpars.c) */
    k = (long)strlen(sout);
    m = 0;  /* Position on line relative to last '\n' */
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] == '\n') {
        m = 0;
        continue;
      }
      m++; /* Should equal i for one-line string */
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((m - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((m - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((m - 1) & 7);
    }
  }

  /* Tab the line */
  /* (Note that this does not [yet?] handle string with multiple lines) */
  if (tab_flag) {

    /*
    DEF FNTAB$(L$)        ! TAB LINE L$
    I9%=0%
    FOR I9%=8% STEP 8% WHILE I9%<LEN(L$)
      J9%=I9%
      J9%=J9%-1% UNTIL ASCII(MID(L$,J9%,1%))<>32% OR J9%=I9%-8%
      IF J9%<=I9%-2% THEN
        L$=LEFT(L$,J9%)+CHR$(9%)+RIGHT(L$,I9%+1%)
        I9%=J9%+1%
      END IF
    NEXT I9%
    FNTAB$=L$
    FNEND
    */

    k = (long)strlen(sout);
    for (i = 8; i < k; i = i + 8) {
      j = i;

      /* 26-May-2016 nm */
      /* gcc m*.c -o metamath.exe -O2 -Wall was giving:
             mmvstr.c:285:9: warning: assuming signed overflow does not occur
             when assuming that (X - c) <= X is always true [-Wstrict-overflow]
         Here we trick gcc into turning off this optimization by moving
         the computation of i - 2 here, then referencing m instead of i - 2
         below.  Note that if "m = i - 2" is moved _after_ the "while", the
         error message returns. */
      m = i - 2;

      while (sout[j - 1] == ' ' && j > i - 8) j--;
      /*if (j <= i - 2) {*/
      if (j <= m) {  /* 25-May-2016 nm */
        sout[j] = '\t';
        j = i;
        while (sout[j - 1] == ' ' && j > i - 8 + 1) {
          sout[j - 1] = 0;
          j--;
        }
      }
    }
    i = k;
    /* sout[i]=0 is the last character at this point */
    /* Clean up the deleted characters */
    for (j = 0, k = 0; j <= i; j++)
      if (sout[j] != 0) sout[k++] = sout[j];
    sout[k] = 0;
    /* sout[k] = 0 is the last character at this point */
  }

  return (sout);
} /* edit */


/* Return a string of the same character */
vstring string(long n, char c)
{
  vstring sout;
  long j = 0;
  if (n < 0) n = 0;
  sout=tempAlloc(n + 1);
  while (j < n) sout[j++] = c;
  sout[j] = 0;
  return (sout);
} /* string */


/* Return a string of spaces */
vstring space(long n)
{
  return (string(n, ' '));
} /* space */


/* Return a character given its ASCII value */
vstring chr(long n)
{
  vstring sout;
  sout = tempAlloc(2);
  sout[0] = (char)(n & 0xFF);
  sout[1] = 0;
  return(sout);
} /* chr */


/* Search for string2 in string1 starting at start_position */
/* If there is no match, 0 is returned */
/* If string2 is "", (length of the string) + 1 is returned */
long instr(long start_position, vstring string1, vstring string2)
{
  char *sp1, *sp2;
  long ls1, ls2;
  long found = 0;
  if (start_position < 1) start_position = 1;
  ls1 = (long)strlen(string1);
  ls2 = (long)strlen(string2);
  if (start_position > ls1) start_position = ls1 + 1;
  sp1 = string1 + start_position - 1;
  while ((sp2 = strchr(sp1, string2[0])) != 0) {
    if (strncmp(sp2, string2, (size_t)ls2) == 0) {
      found = sp2 - string1 + 1;
      break;
    } else
      sp1 = sp2 + 1;
  }
  return (found);
} /* instr */


/* 12-Jun-2011 nm Added rinstr */
/* Search for _last_ occurrence of string2 in string1 */
/* 1 = 1st string character; 0 = not found */
/* ??? Future - this could be made more efficient by searching directly,
   backwards from end of string1 */
long rinstr(vstring string1, vstring string2)
{
  long pos = 0;
  long savePos = 0;

  while (1) {  /* Scan until substring no longer found */
    pos = instr(pos + 1, string1, string2);
    if (!pos) break;
    savePos = pos;
  }
  return (savePos);
} /* rinstr */


/* Translate string in sin to sout based on table.
   Table must be 256 characters long!! <- not true anymore? */
vstring xlate(vstring sin,vstring table)
{
  vstring sout;
  long len_table, len_sin;
  long i, j;
  long table_entry;
  char m;
  len_sin = (long)strlen(sin);
  len_table = (long)strlen(table);
  sout = tempAlloc(len_sin+1);
  for (i = j = 0; i < len_sin; i++)
  {
    table_entry = 0x000000FF & (long)sin[i];
    if (table_entry < len_table)
      if ((m = table[table_entry])!='\0')
        sout[j++] = m;
  }
  sout[j]='\0';
  return (sout);
} /* xlate */


/* Returns the ascii value of a character */
long ascii_(vstring c)
{
  return ((long)c[0]);
} /* ascii_ */


/* Returns the floating-point value of a numeric string */
double val(vstring s)
{
  double v = 0;
  char signFound = 0;
  double power = 1.0;
  long i;
  for (i = (long)strlen(s); i >= 0; i--) {
    switch (s[i]) {
      case '.':
        v = v / power;
        power = 1.0;
        break;
      case '-':
        signFound = 1;
        break;
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
        v = v + ((double)(s[i] - '0')) * power;
        power = 10.0 * power;
        break;
    }
  }
  if (signFound) v = - v;
  return v;
  /*
  return (atof(s));
  */
} /* val */


/* Returns current date as an ASCII string */
vstring date()
{
  vstring sout;
  struct tm *time_structure;
  time_t time_val;
  char *month[12];

  /* (Aggregrate initialization is not portable) */
  /* (It must be done explicitly for portability) */
  month[0] = "Jan";
  month[1] = "Feb";
  month[2] = "Mar";
  month[3] = "Apr";
  month[4] = "May";
  month[5] = "Jun";
  month[6] = "Jul";
  month[7] = "Aug";
  month[8] = "Sep";
  month[9] = "Oct";
  month[10] = "Nov";
  month[11] = "Dec";

  time(&time_val); /* Retrieve time */
  time_structure = localtime(&time_val); /* Translate to time structure */
  sout = tempAlloc(12);
  /* "%02d" means leading zeros with min. field width of 2 */
  /* sprintf(sout,"%d-%s-%02d", */
  sprintf(sout,"%d-%s-%04d", /* 10-Apr-06 nm 4-digit year */
      time_structure->tm_mday,
      month[time_structure->tm_mon],
      /* time_structure->tm_year); */ /* old */
      /* (int)((time_structure->tm_year) % 100)); */ /* Y2K */
      (int)((time_structure->tm_year) + 1900)); /* 10-Apr-06 nm 4-digit yr */
  return(sout);
} /* date */


/* Return current time as an ASCII string */
vstring time_()
{
  vstring sout;
  struct tm *time_structure;
  time_t time_val;
  int i;
  char *format;
  char *format1 = "%d:%d %s";
  char *format2 = "%d:0%d %s";
  char *am_pm[2];
  /* (Aggregrate initialization is not portable) */
  /* (It must be done explicitly for portability) */
  am_pm[0] = "AM";
  am_pm[1] = "PM";

  time(&time_val); /* Retrieve time */
  time_structure = localtime(&time_val); /* Translate to time structure */
  if (time_structure->tm_hour >= 12)
    i = 1;
  else
    i = 0;
  if (time_structure->tm_hour > 12)
    time_structure->tm_hour -= 12;
  if (time_structure->tm_hour == 0)
    time_structure->tm_hour = 12;
  sout = tempAlloc(12);
  if (time_structure->tm_min >= 10)
    format = format1;
  else
    format = format2;
  sprintf(sout,format,
      time_structure->tm_hour,
      time_structure->tm_min,
      am_pm[i]);
  return(sout);
} /* time */


/* Return a number as an ASCII string */
vstring str(double f)
{
  /* This function converts a floating point number to a string in the */
  /* same way that %f in printf does, except that trailing zeroes after */
  /* the one after the decimal point are stripped; e.g., it returns 7 */
  /* instead of 7.000000000000000. */
  vstring s;
  long i;
  s = tempAlloc(50);
  sprintf(s,"%f", f);
  if (strchr(s, '.') != 0) { /* The string has a period in it */
    for (i = (long)strlen(s) - 1; i > 0; i--) {  /* Scan string backwards */
      if (s[i] != '0') break; /* 1st non-zero digit */
      s[i] = 0; /* Delete the trailing 0 */
    }
    if (s[i] == '.') s[i] = 0; /* Delete trailing period */
  }
  return (s);
} /* str */


/* Return a number as an ASCII string */
/* (This may have differed slightly from str() in BASIC but I forgot how.
   It should be considered deprecated.) */
vstring num1(double f)
{
  return (str(f));
} /* num1 */


/* Return a number as an ASCII string surrounded by spaces */
/* (This should be considered deprecated.) */
vstring num(double f)
{
  return (cat(" ",str(f)," ",NULL));
} /* num */



/*** NEW FUNCTIONS ADDED 11/25/98 ***/

/* Emulate PROGRESS "entry" and related string functions */
/* (PROGRESS is a 4-GL database language) */

/* A "list" is a string of comma-separated elements.  Example:
   "a,b,c" has 3 elements.  "a,b,c," has 4 elements; the last element is
   an empty string.  ",," has 3 elements; each is an empty string.
   In "a,b,c", the entry numbers of the elements are 1, 2 and 3 (i.e.
   the entry numbers start a 1, not 0). */

/* Returns a character string entry from a comma-separated
   list based on an integer position. */
/* If element is less than 1 or greater than number of elements
   in the list, a null string is returned. */
vstring entry(long element, vstring list)
{
  vstring sout;
  long commaCount, lastComma, i, length;
  if (element < 1) return ("");
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) commaCount++;
  if (element > commaCount) return ("");
  length = i - lastComma - 1;
  if (length < 1) return ("");
  sout = tempAlloc(length + 1);
  strncpy(sout, list + lastComma + 1, (size_t)length);
  sout[length] = 0;
  return (sout);
}

/* Emulate PROGRESS lookup function */
/* Returns an integer giving the first position of an expression
   in a comma-separated list. Returns a 0 if the expression
   is not in the list. */
long lookup(vstring expression, vstring list)
{
  long i, exprNum, exprPos;
  char match;

  match = 1;
  i = 0;
  exprNum = 0;
  exprPos = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      exprNum++;
      if (match) {
        if (expression[exprPos] == 0) return exprNum;
      }
      exprPos = 0;
      match = 1;
      i++;
      continue;
    }
    if (match) {
      if (expression[exprPos] != list[i]) match = 0;
    }
    i++;
    exprPos++;
  }
  exprNum++;
  if (match) {
    if (expression[exprPos] == 0) return exprNum;
  }
  return 0;
}


/* Emulate PROGRESS num-entries function */
/* Returns the number of items in a comma-separated list.  If the
   list is the empty string, return 0. */
long numEntries(vstring list)
{
  long i, commaCount;
  if (list[0] == 0) {
    commaCount = -1; /* 26-Apr-2006 nm Return 0 if list empty */
  } else {
    commaCount = 0;
    i = 0;
    while (list[i] != 0) {
      if (list[i] == ',') commaCount++;
      i++;
    }
  }
  return (commaCount + 1);
}

/* Returns the character position of the start of the
   element in a list - useful for manipulating
   the list string directly.  1 means the first string
   character. */
/* If element is less than 1 or greater than number of elements
   in the list, a 0 is returned.  If entry is null, a 0 is
   returned. */
long entryPosition(long element, vstring list)
{
  long commaCount, lastComma, i;
  if (element < 1) return 0;
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) {
    if (i == 0) return 0;
    if (list[i - 1] == ',') return 0;
    commaCount++;
  }
  if (element > commaCount) return (0);
  if (list[lastComma + 1] == ',') return 0;
  return (lastComma + 2);
}


void print2(char* fmt,...)
{
  /* This performs the same operations as printf, except that if a log file is
    open, the characters will also be printed to the log file. */
  va_list ap;
  char printBuffer[10001];

  va_start(ap, fmt);
  vsprintf(printBuffer, fmt, ap); /* Put formatted string into buffer */
  va_end(ap);

  printf("%s", printBuffer); /* Terminal */

  if (fplog != NULL) {
    fprintf(fplog, "%s", printBuffer);  /* Print to log file */
  }
  return;
}


/* Bug check */
void bug(int bugNum)
{
  /*print2("?Error: Program bug # %d\n", bugNum);*/
  fprintf(stderr, "?Error: Program bug # %d\n", bugNum);
  exit(0);
}


/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode)
{
  FILE *fp;
  vstring prefix = "";
  vstring postfix = "";
  vstring bakName = "";
  vstring newBakName = "";
  long v;

  if (!strcmp(mode, "r")) {
    fp = fopen(fileName, "r");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }
    return (fp);
  }

  if (!strcmp(mode, "w")) {
    /* See if the file already exists. */
    fp = fopen(fileName, "r");

    if (fp) {
      fclose(fp);

#define VERSIONS 9
      /* The file exists.  Rename it. */

#if defined __WATCOMC__ /* MSDOS */
      /* Make sure file name before extension is 8 chars or less */
      i = instr(1, fileName, ".");
      if (i) {
        let(&prefix, left(fileName, i - 1));
        let(&postfix, right(fileName, i));
      } else {
        let(&prefix, fileName);
        let(&postfix, "");
      }
      let(&prefix, cat(left(prefix, 5), "~", NULL));
      let(&postfix, cat("~", postfix, NULL));
      if (0) goto skip_backup; /* Prevent compiler warning */

#elif defined __GNUC__ /* Assume unix */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined THINK_C /* Assume Macintosh */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined VAXC /* Assume VMS */
      /* For debugging on VMS: */
      /* let(&prefix, cat(fileName, "-", NULL));
         let(&postfix, "-"); */
      /* Normal: */
      goto skip_backup;

#else /* Unknown; assume unix standard */
      /*if (1) goto skip_backup;*/  /* [if no backup desired] */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#endif


      /* See if the lowest version already exists. */
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      fp = fopen(bakName, "r");
      if (fp) {
        fclose(fp);
        /* The lowest version already exists; rename all to lower versions. */

        /* If version VERSIONS exists, delete it. */
        let(&bakName, cat(prefix, str(VERSIONS), postfix, NULL));
        fp = fopen(bakName, "r");
        if (fp) {
          fclose(fp);
          remove(bakName);
        }

        for (v = VERSIONS - 1; v >= 1; v--) {
          let(&bakName, cat(prefix, str((double)v), postfix, NULL));
          fp = fopen(bakName, "r");
          if (!fp) continue;
          fclose(fp);
          let(&newBakName, cat(prefix, str((double)v + 1), postfix, NULL));
          rename(bakName, newBakName);
        }

      }
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      rename(fileName, bakName);

      /***
      printLongLine(cat("The file \"", fileName,
          "\" already exists.  The old file is being renamed to \"",
          bakName, "\".", NULL), "  ", " ");
      ***/
    } /* End if file already exists */
   /*skip_backup:*/

    fp = fopen(fileName, "w");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }

    let(&prefix, "");
    let(&postfix, "");
    let(&bakName, "");
    let(&newBakName, "");

    return (fp);
  } /* End if mode = "w" */

  bug(1510); /* Illegal mode */
  return(NULL);

}

/***********************************************************************/
/************ End of "vstring" body stuff ******************************/
/***********************************************************************/
