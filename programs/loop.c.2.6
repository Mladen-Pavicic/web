/* loop.c - This is a quick-and-dirty derivative of latticeg.c to
      list all possible loops in an MMP diagram. */
/* ./loop --help prints help message */

/*****************************************************************************/
/*            loop.c - Loop finder for MMP diagrams                          */
/*                                                                           */
/*       Copyright (C) 2018  NORMAN D. MEGILL  nm @ alum.mit.edu             */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/
/*34567890123456 (79-character line to adjust text window width) 678901234567*/

#define VERSION "2.6 8-Aug-2018"
/* 2.6 8-Aug-2018 nm - comment out code skipped by "i == i" to prevent
   compiler warning */
/* 2.5 18-May-2017 nm - take out "#if", "#ifdef" surrounding fflush(stdout) */
/* 2.4 26-Apr-2017 nm - add fflush(stdout) after all printf statements */
/* 2.3 20-Mar-2017 nm Updated edit() to remove gcc compiler warning.
   Added -t<n> timeout option, default -t10000 - see ./loop --help */
/* 2.2 15-May-2016 nm Add -2 option; major revision of core algorithm */
/* 2.1 30-Jan-2014 nm Add -p option; unlimited linput() line length; cleanup */
/* 2.0 20-Jan-2012 nm Add -b, -b<n>, -m<n> options */
/* 1.9 18-Jan-2012 nm Fix 15-Jan-2012 bug for case of first and last blocks */
/* 1.8 17-Jan-2012 nm Incorporate loopbig.c */
/* 1.7 15-Jan-2012 nm If two blocks have more than one atom in common,
   they won't be part of a loop. */
/* 1.6 27-Sep-2009 nm Also print normalized Greechie diagram (123,345,...) */
/* 1.5 10-Oct-2003 nm See "10-Oct-03" changes */

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>


/* Mapping for Greechie diagram atoms */
#define ATOM_MAP "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs" \
    "tuvwxyz!\"#$%&'()*-/:;<=>?@[\\]^_`{|}~"
/* Maximum number of blocks */
#define MAX_BLOCKS 2000
/* Maximum number of atoms */
#define MAX_ATOMS 1000
/* Minimum block size - only 3 and 4 are implemented */
#define MIN_BLOCK_SIZE 1
/* Maximum block size - only 3 and 4 are implemented */
#define MAX_BLOCK_SIZE 10

/******************** Start of string handling prototypes ********************/
typedef char* vstring;

typedef short wideChar;
typedef wideChar* wideVstring;
#define WIDE_ENDCHAR 0
wideChar wideNullString[] = {WIDE_ENDCHAR};

/* String assignment - MUST be used to assign vstrings */
void let(vstring *target,vstring source);
void wideLet(wideVstring *target, wideVstring source);
/* String concatenation - last argument MUST be NULL */
vstring cat(vstring string1,...);
wideVstring wideCat(wideVstring string1,...);

/* Emulate BASIC linput statement; returns NULL if EOF */
/* Note that linput assigns target string with let(&target,...) */
  /*
    BASIC:  linput "what";a$
    c:      linput(NULL,"what?",&a);

    BASIC:  linput #1,a$                        (error trap on EOF)
    c:      if (!linput(file1,NULL,&a)) break;  (break on EOF)

  */
int linput(FILE *stream, const char* ask, vstring *target);

/* Emulation of BASIC string functions */
vstring seg(vstring sin, long p1, long p2);
vstring mid(vstring sin, long p, long l);
wideVstring wideMid(wideVstring sin, long p, long l);
vstring left(vstring sin, long n);
wideVstring wideLeft(wideVstring sin, long n);
vstring right(vstring sin, long n);
wideVstring wideRight(wideVstring sin, long n);
vstring edit(vstring sin, long control);
vstring space(long n);
vstring string(long n, char c);
wideVstring wideString(long n, wideChar c);
wideVstring wide(vstring s);
vstring chr(long n);
vstring xlate(vstring sin, vstring control);
vstring date(void);
vstring time_(void);
vstring num(double x);
vstring num1(double x);
vstring str(double x);
long len(vstring s);
long wideLen(wideVstring s);
void wideCpy(wideVstring t, wideVstring s);
long instr(long start, vstring sin, vstring s);
long wideChrInStr(long start, wideVstring s, wideChar c);
long ascii_(vstring c);
double val(vstring s);
/* Emulation of PROGRESS string functions added 11/25/98 */
vstring entry(long element, vstring list);
long lookup(vstring expression, vstring list);
long numEntries(vstring list);
long entryPosition(long element, vstring list);
/* Print to log file as well as terminal if fplog opened */
void print2(char* fmt,...);
FILE *fplog = NULL;
/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode);


/******* Special pupose routines for better
      memory allocation (use with caution) *******/
/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the vstring may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s);   /* Make string have temporary allocation to be
                                    released by next let() */
/* Remaining prototypes (outside of mmvstr.h) */
void *tempAlloc(long size);     /* String memory allocation/deallocation */

#define MAX_ALLOC_STACK 100
int tempAllocStackTop=0;        /* Top of stack for tempAlloc functon */
int startTempAllocStack=0;      /* Where to start freeing temporary allocation
                                    when let() is called (normally 0, except in
                                    special nested vstring functions) */
void *tempAllocStack[MAX_ALLOC_STACK];

/* Bug check error */
void bug(int bugNum);

/******************** End of string handling prototypes **********************/

/******************** Prototypes *********************************************/
void printhelp(void);
void testAllLattices(void);
void init(void);
void initLattice(long latticeNum);

void greechie3(vstring name, vstring glattice);

/* loop.c */
void loop(wideVstring thisLoopSoFar);
vstring getAtomName(long atomNumber);

vstring printableAtomName(long atomNum);

/******************** Global variables ***************************************/

/* For loop.c */
#define MAX_LOOPS 100000
long userMaxLoops = 1000; /* Default maximum, overridden by -m<nnn> */
vstring allLoopsSoFar = ""; /* All loops so far for duplicate detection */
long loopListSize = 0; /* Number of loops found */
char loopWarning = 0; /* A warning of loops exceeded is in the output file */
vstring loopList[MAX_LOOPS + 1]; /* List of loops found */
long loopSizeList[MAX_LOOPS + 1]; /* Size of loops found */
long nBiggestLoops; /* Up to how many biggest loops to print out in -b<nn> mode */
char pipeMode = 0;
char twoOrMore = 0; /* If 0, loop edges should intersect at exactly 1 vertex */

/* 20-Mar-2017 nm */
long userTimeout = 10000; /* If 0, no timeout; otherwise start at new
        block if loop() calls exceed it */
long failedTrials; /* Counts the number of loop() calls since last loop found */
char timedOut = 0; /* If 1, it means at least one timeout occurred */

vstring latticeName = ""; /* Name of lattice being worked with */
long userArg; /* -1 = test all; n = test only nth lattice */
long startArg = 0; /* Lattice # to start from */
long endArg = 0; /* Lattice # to end at */
/* Special for Greechie diagram program latticeg.c */
long ATOM_MAPLen; /* Pre-computed length of ATOM_MAP */
long glatticeNum;
long glatticeCount;
vstring greechieStmt = ""; /* Greechie lattice C statement */
wideVstring atomReverseMap = wideNullString; /* Map back to input diagram */
char oneLineOutput = 0; /* Set to 1 by -1 option */
char removeLegs = 0; /* Set to 1 by -l option */
FILE *fptr = NULL;  /* Input file of greechie diagrams */
char stdInputMode = 1; /* Set to 1 by --i option (default), then to 2 on EOF */
long fileLattices = 0; /* Number of input file diagrams */
long fileLineNum = 0; /* Most recent line number (= lattice number) read */

/* The block stuff was made global for use outside of greechie3() */
/* Block information for Greechie diagrams */
long atoms;
long block[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
long blockSize[MAX_BLOCKS + 1];
long block4Offset[MAX_BLOCKS + 1];
long blocks;




/******************** Main program *******************************************/

int main(int argc, char *argv[])
{

  vstring str1 = "";
  /*vstring str2 = "";*/
  long /*i,*/ argOffset;
  char argOffsetChanged;
  /*vstring contLine = "";*/ /* Continuation line */

  /* argc is the number of arguments; argv points to array containing them */

  /****** deleted 18-May-2017 nm  Obsolete
  /@ Line continuation for DOS: "$x" means get argument x from prompt @/
  for (i = 1; i < argc; i++) {
    let(&str1, argv[i]);
    if (str1[0] == '$') {
      if (str1[0] == '\'' || str1[0] == '\"') {
        /@ Strip quotes @/
        let(&str1, seg(str1, 2, (long)strlen(str1) - 1));
      }
      /@ Strip off successive "$x"s and replace with continuation lines @/
      while (str1[0] == '$') {
        let(&str2, cat(left(str1, 2), "> ", NULL));
        linput(NULL, str2, &contLine);
        let(&str1, cat(right(str1, 3), contLine, NULL));
      }
      /@ Note that we'll just give up and not free the memory argv[i] points
         to; it seems the safest thing to do since it may not be a real malloc
         object depending on compiler @/
      /@ To be extra safe we might want to clone the argv pointer array first
         before reassigning it; maybe in a future version @/
      argv[i] = str1;
      str1 = ""; /@ Relinquish string ownership to argv[i] (instead of let()) @/
    }
  }
  let(&str1, ""); /@ Deallocate string @/
  let(&str2, ""); /@ Deallocate string @/
  let(&contLine, ""); /@ Deallocate string @/
  ******* end of 18-May-2017 deletion *****/

  if (argc <= 1) {
    /* No arguments means print help */
    /* For loop.c, it means use default options */
    /* printhelp(); */
    /* return 0; */
  }

  /* Get command line options */
  /* Important: none of the options have the syntax of a legal wff.   This
     should be the case for any future options as well. */
  userArg = 0;
  argOffset = 0;
  argOffsetChanged = 1;
  while (argOffsetChanged) {
    argOffsetChanged = 0;
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "--help")) {
      printhelp();
      return 0;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-a")) {
      argOffset++;
      argOffsetChanged = 1;
      userArg = -1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-p")) {
      argOffset++;
      argOffsetChanged = 1;
      pipeMode = 1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-2")) {
      argOffset++;
      argOffsetChanged = 1;
      twoOrMore = 1;
    }
    /*
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-1")) {
      argOffset++;
      argOffsetChanged = 1;
      oneLineOutput = 1;
      nBiggestLoops = 1;
    }
    */
    if (argc - argOffset > 1 && !strcmp(left(argv[1 + argOffset], 2), "-b")) {
      oneLineOutput = 1;
      let(&str1, right(argv[1 + argOffset], 3));
      nBiggestLoops = 1; /* Default to 1 biggest loop */
      if (str1[0]) {
        nBiggestLoops = (long)val(str1); /* "-b2" shows up to 2 biggest, etc. */
      } else {
        nBiggestLoops = 1; /* Default to 1 biggest loop */
      }
      argOffset++;
      argOffsetChanged = 1;
    }
    if (argc - argOffset > 1 && !strcmp(left(argv[1 + argOffset], 2), "-m")) {
      oneLineOutput = 1;
      let(&str1, right(argv[1 + argOffset], 3));
      if (str1[0]) {
        userMaxLoops = (long)val(str1); /* "-m100" finds first 100 loops, etc. */
      } else {
        fprintf(stderr,
            "?You must specify a positive integer after -m (no space).\n");
        exit(1);
      }
      if (userMaxLoops > MAX_LOOPS) {
        fprintf(stderr,
 "?Maximum -m argument is %ld.  Increase MAX_LOOPS and recompile for more.\n",
            (long)MAX_LOOPS);
        exit(1);
      }
      argOffset++;
      argOffsetChanged = 1;
    }

    /* 20-May-2017 nm */
    if (argc - argOffset > 1 && !strcmp(left(argv[1 + argOffset], 2), "-t")) {
      let(&str1, right(argv[1 + argOffset], 3));
      if (str1[0]) {
        userTimeout = (long)val(str1); /* "-t100" times out after 100
                                           loop() calls, etc. */
      } else {
        fprintf(stderr,
            "?You must specify a non-negative integer after -t (no space).\n");
        exit(1);
      }
      argOffset++;
      argOffsetChanged = 1;
    }

    /*
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-l")) {
      argOffset++;
      argOffsetChanged = 1;
      removeLegs = 1;
    }
    */
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-i")) {
      if (argc - argOffset > 2) {
        stdInputMode = 0; /* Turn off default of standard input */
        /* Open the output file */
        fptr = fopen(argv[2 + argOffset], "r");
        if (fptr == NULL) {
          print2("?Error: Couldn't open the file \"%s\".\n",
              argv[2 + argOffset]);
          return 0;
        }
      } else {
        print2("?Error: No input file specified.\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-o")) {
      if (argc - argOffset > 2) {
        if (fplog != NULL) {
          print2("?Error: Cannot specify more than one output file.\n");
          return 0;
        }
        /* Open the output file */
        fplog = fSafeOpen(argv[2 + argOffset], "w");
        if (fplog == NULL) {
          return 0;
        }
        /* Disable buffering of the output file so that all partial results
           will be there in case a run is aborted before completion */
        setbuf(fplog, NULL);
      } else {
        print2("?Error: No output log file specified.\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "--o")) {
      if (argc - argOffset > 2) {
        if (fplog != NULL) {
          print2("?Error: Cannot specify more than one output file.\n");
          return 0;
        }
        /* Open the output file - append mode */
        fplog = fopen(argv[2 + argOffset], "a");
        if (fplog == NULL) {
          print2("?Error: Couldn't open the file \"%s\".\n",
              argv[2 + argOffset]);
          return 0;
        }
        /* Disable buffering of the output file so that all partial results
           will be there in case a run is aborted before completion */
        setbuf(fplog, NULL);
      } else {
        print2("?Error: No output log file specified.\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    /*
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-n")) {
      if (argc - argOffset > 2) userArg = (long)val(argv[2 + argOffset]);
      if (userArg <= 0  || strcmp(argv[2 + argOffset], str(userArg))) {
        print2("?Error: Expected positive integer after -n\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-s")) {
      if (argc - argOffset > 2) startArg = (long)val(argv[2 + argOffset]);
      if (startArg <= 0  || strcmp(argv[2 + argOffset], str(startArg))) {
        print2("?Error: Expected positive integer after -s\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    if (argc - argOffset > 1 && !strcmp(argv[1 + argOffset], "-e")) {
      if (argc - argOffset > 2) endArg = (long)val(argv[2 + argOffset]);
      if (endArg <= 0  || strcmp(argv[2 + argOffset], str(endArg))) {
        print2("?Error: Expected positive integer after -e\n");
        return 0;
      }
      argOffset += 2;
      argOffsetChanged = 1;
    }
    */
  }

  /* loop.c */
  if (argc - argOffset != 1) {
    print2("?Invalid option:  %s\n", argv[1 + argOffset]);
    exit(1);
  }

  init(); /* One-time initialization */


  testAllLattices(); /* Run the program */

  /****** loop.c ********/
  if (loopWarning == 1) {
    fprintf(stderr,
        "Warning:  Some loops were not exhausted (look for '?' in output).\n");
  }

  /* 20-Mar-2017 nm */
  if (timedOut == 1) {
    fprintf(stderr,
      "Warning:  Time-out(s) with -t=%ld occurred (look for '?' in output).\n",
      userTimeout);
  }

  return 0;
} /* main */

void printhelp(void)
{

/* loop.c */
printf("loop.c - Finds loops in MMP diagrams - Version %s\n", VERSION);
printf("\n");
printf("Usage: loop [options] < inputfile > outputfile\n");
printf("The options are:\n");
printf("  -b - Show only the first biggest loop for each input line.\n");
printf("  -b<n> - Show only up to n loops of the biggest size (-b1 is\n");
printf("      the same as -b).\n");
printf("  -m<n> - Stop searching afer n loops are found (default 1000).\n");
printf("      For example, -m100 will look at only the first 100 loops\n");
printf("      for each input diagram.  This option is ignored unless -b\n");
printf("      or -b<n> is specified.\n");
printf("  -p - Use \".\" instead of \"*\" to show that an atom is connected\n");
printf("      to loop.  This allows the MMP to be recovered from the\n");
printf("      output for piping to next stage, after stripping the prefix,\n");
printf("      \",,\", and all \".\" but the last.  This will avoid errors\n");
printf("      when \"*\" is an atom name.  This option is ignored unless\n");
printf("      -b or -b<n> is specified.\n");
printf("  -2 - Allow loop edges to overlap at two or more vertices.  By\n");
printf("      default, loop edges must intersect at a unique vertex.\n");

/* 20-Mar-2017 nm */
printf("  -t<n> - Time out (give up) on the current starting block after n\n");
printf("      search iterations and continue with next starting block.  For\n");
printf("      example, -t1000 will time out after 1000 iterations.  The\n");
printf("      default is -t%ld.  -t0 means never time out, but run times\n",
    userTimeout);
printf("      may be very long.\n");

printf("  -i <file> - Read input from <file> instead of standard input.\n");
printf("  -o (--o) <file> - Write (append) output to <file> in addition\n");
printf("      to standard output.\n");
printf("\n");
printf("\"loop --help\" prints this message.\n");
printf("\n");
printf("Example:  Suppose <inputfile> contains the Peterson OML:\n");
printf("  \"'123,345,567,789,9AB,BC1,2E8,4FA,6DC,DEF.\"\n");
printf("\n");
printf("Case 1: Default output\n");
printf("----------------------\n");
printf("\n");
printf("If -b or -b<n> is NOT specified, then only the first line is read\n");
printf("from the input file.  The output consists of all possible loops.\n");
printf("An example of an output line will be the following (the\n");
printf("description letters underneath are not part of the output):\n");
printf("\n");
printf("  6 123,345,567,789,9AB,BC1.  2*E.8* 4*F.A* 6*D.C* D.E.F.\n");
printf("  a bbbbbbbbbbbbbbbbbbbbbbbb  cdcecd cdcecd cdcecd cecece\n");
printf("where\n");
printf("  a = loop size\n");
printf("  b = blocks around the outer loop\n");
printf("  c = remaining blocks\n");
printf("  d = * means the atom is connected to the loop\n");
printf("  e = . means the atom is not connected to the loop\n");
printf("\n");
printf("After each loop, a renormalized MMP diagram with atoms in loop\n");
printf("order is shown, preceded by '=' to indicate 'isomorphic'.  For\n");
printf("this example, the renormalized MMP will read:\n");
printf("\n");
printf("= 6 123,345,567,789,9AB,BC1,2D8,4EA,6FC,FDE.\n");
printf("\n");
printf("\n");
printf("Case 2: Output with -b or -b<n>\n");
printf("-------------------------------\n");
printf("\n");
printf("If -b or -b<n> is specified, then every input file line is read,\n");
printf("and for each input line, up to n (n=1 for -b) loops of the biggest\n");
printf("size are output on a single line (separated by a space if more\n");
printf("than one).  By default, only the first 1000 loops are generated;\n");
printf("this can be increased or decreased with -m<n>.  The above example\n");
printf("would produce (with -b or -b1):\n");
printf("\n");
printf("00-6-a15-b10-00 123,345,567,789,9AB,BC1,,,2*E8*,4*FA*,6*DC*,DEF.\n");
printf("\n");
printf("Note that 00 = fixed marker, 6 = loop size, a15 = number of\n");
printf("vertices, b10 = number of edges, 00 = fixed marker.\n");
printf("\n");
printf("In case there are more than n loops (where n is specified by -m<n>\n");
printf("or 1000 if -m<n> is omitted), the true biggest loop size will not\n");
printf("be known, and only the biggest found will be shown.  The loop\n");
printf("size will be followed by '?' to indicate this, so the above line\n");
printf("would read:\n");
printf("\n");
printf("00-6?-a15-b10-00 123,345,567,789,9AB,BC1,,,2*E8*,4*FA*,6*DC*,DEF.\n");
printf("\n");
printf("In case a timeout occurred during -b or -b<n>, the loop size will\n");
printf("also be followed by '?', again to indicate that the true biggest\n");
printf("loop size may not be represented.  In this case, a timeout warning\n");
printf("message will be printed on the stderr output.\n");
return;
} /* printhelp() */


void testAllLattices(void)
{
  long latticeCase = 0;
  if (userArg > 0) latticeCase = userArg - 1;

  while (1) {
    latticeCase++;
    if (/* latticeCase > MAX_LATTICES */   /* Built-in lattice limit */
        /*&&*/ latticeCase > fileLattices /* External file lattices */
        && !stdInputMode      /* Not in standard input mode */
        && userArg <= 0) break;                   /* Exhausted lattice cases */
    if (stdInputMode == 2) break; /* EOF flag in standard input mode */
    initLattice(latticeCase);
  }

  return;
} /* testAllLattices() */



void init(void) /* Should be called only once!! */
{
  vstring tmpStr = "";
  if (fptr != NULL) {
    /* The user specified an input file */
    /* Count the lines - each line is a lattice */

    fileLattices = 0;
    while (linput(fptr, NULL, &tmpStr)) {
      fileLattices++;
    }
    if (!oneLineOutput)
    /* Don't print for loop.c */
    /* print2("The input file has %ld lattice(s).\n", fileLattices); */
    rewind(fptr);
    fileLineNum = 0;
  }

  ATOM_MAPLen = (long)strlen(ATOM_MAP); /* For + notation */

} /* init */

void initLattice(long latticeNum)
{
  vstring fileLine = "";

  if (endArg && latticeNum > endArg) {
    if (stdInputMode) {
      /* Read and discard the rest of the input stream */
      /*while (linput(fptr, NULL, &fileLine));*/ /* necessary? */
      if (stdInputMode != 1) bug(21);
      stdInputMode = 2; /* Set end-of-file flag */
    }
    return;
  }

  /* Global variables used by greechie3() */
  glatticeNum = latticeNum;
  glatticeCount = 0;

  /* Get the Greechie diagram corresponding to glatticeNum */
  if (fptr == NULL && !stdInputMode) {
    /* Use the ones hard-coded into this program */
    bug(200); /*usersGreechieDiagrams();*/
  } else {
    /* We read from an input file or standard input */
    /* Trick greechie3() into thinking we've already done latticeNum cases */
    glatticeCount = latticeNum - 1;
    /* Call greechie3() as if this were a hard-coded user lattice */
    if (latticeNum <= fileLattices || stdInputMode) {
      if (stdInputMode) {
        if (stdInputMode != 1) bug(16);
        fileLattices = latticeNum;
      }
      /* The program should never try to read "backwards" */
      if (fileLineNum >= latticeNum) bug(13);
      /* Skip any input lines before latticeNum in case of -n,-p options */
      while (fileLineNum < latticeNum - 1) {
        fileLineNum++;
        /* Note:  in stdInputMode, fptr is NULL telling linput() to use stdin */
        if (!linput(fptr, NULL, &fileLine)) {
          if (stdInputMode) {
            if (stdInputMode != 1) bug(17);
            stdInputMode = 2; /* Set end-of-file flag */
            return;
          }
          bug(14); /* Beyond EOF */
        }
      }
      /* Read the line we're interested in */
      fileLineNum++;
      if (!linput(fptr, NULL, &fileLine)) {
        if (stdInputMode) {
          if (stdInputMode != 1) bug(19);
          stdInputMode = 2; /* Set end-of-file flag */
          return;
        }
        bug(15); /* Beyond EOF */
      }
      greechie3("", fileLine);
    }
  }


  let(&fileLine, "");

} /* initLattice() */


/* Parses an MMP diagram */
void greechie3(vstring name, vstring glattice) {
  long msize, /*legs,*/ i, j, k, /*m,*/ n;
  vstring jptr;
  vstring glattice1 = "";
  vstring str1 = "";
  vstring str2 = "";
  long extendedNotationOffset; /* For + notation */
  /*wideVstring atomRemap = wideNullString;*/ /* To fill in atom gaps */
  /*** These are now global
  long atoms;
  long block[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
  long blockSize[MAX_BLOCKS + 1];
  long block4Offset[MAX_BLOCKS + 1];
  long blocks;
  ***/
  /* loop.c */
  wideVstring wideStr1 = wideNullString;
  long maxLoopSize;
  long biggestCount;

  glatticeCount++;  /* Global variable */
  if (glatticeCount != glatticeNum) return; /* Early exit if not the one */
  if (startArg && glatticeNum < startArg) return;

  /* In case of temp alloc of glattice; also trim leading, trailing spaces */
  /* Also trim CR in case of DOS file read in Unix */
  let(&glattice1, edit(glattice, 8 + 128 + 4));

  /* Assign the lattice name */
  if (name[0] == 0) {
    /* Blank argument - assign default name */
    let(&latticeName, cat("#", str((double)glatticeNum), NULL));
  } else {
    let(&latticeName, name); /* User's name */
  }

  if (/*oneLineOutput ||*/ removeLegs)
    print2("%s original: %s\n", latticeName, glattice1);

  /* Parse the input string describing the lattice */

  /* if (instr(1, glattice1, ".") == 0) { */
  if (strchr(glattice1, '.') == NULL) {
    if (glattice1[0] == 0) {
      print2("%s: %s\n", latticeName, glattice1);
      print2("?Error: Blank lines are not allowed.\n");
      exit(0);
    }
    /* No period - assume old standard:  3-atom blocks */
    /* No period - assume old standard:  3-atom blocks */

    /* The following code allows free-formatted lists with spaces and/or
       commas as delimiters */
    i = 0;
    while (glattice1[i]) { /* Convert commas to spaces */
      if (glattice1[i] == ',') glattice1[i] = ' ';
      i++;
    }
    let(&glattice1, edit(glattice1, 8 + 16 + 128)); /* Reduce & trim spaces */
    i = 0;
    while (glattice1[i]) { /* Convert spaces to commas */
      if (glattice1[i] == ' ') glattice1[i] = ',';
      i++;
    }

    msize = numEntries(glattice1); /* Total matrix entries (nx3 matrix) */
    if ((msize / 3) * 3 != msize) {
      print2("%s: %s\n", latticeName, glattice1);
      print2(
"?Error: Number of Greechie matrix entries not factor of 3 (or missing '.')\n");
      exit(0);
    }
    blocks = msize / 3;
    atoms = 0;
    for (i = 1; i <= msize; i++) {
      j = (long)val(entry(i, glattice1));
      let(&str1, ""); /* Purge temp alloc in entry() */
      if (j <= 0) {
        print2("%s: %s\n", latticeName, glattice1);
        print2(
"?Error: Greechie matrix atoms must be numbers > 1 (or missing '.')\n");
        exit(0);
      }
      if (j > atoms) atoms = j;
    }

    for (i = 1; i < msize; i = i + 3) {
      blockSize[(i + 2) / 3] = 3; /* Fixed block size of 3 */
      for (j = 0; j < 3; j++) {
        block[(i + 2) / 3][j + 1] = (long)val(entry(i + j, glattice1));
      }
    }
  } else {
    /* glattice1 has period - assume new (Brendan) compact standard */
    /* let(&glattice1, edit(glattice1, 2)); */ /* Remove spaces */
    /* Remove the above line for speed; the program input should ensure this */
    if (strchr(glattice1, ' ') != NULL) {
      print2("%s: %s\n", latticeName, glattice1);
      print2("?Error: The diagram may not contain spaces\n");
      exit(0);
    }
    n = (long)strlen(glattice1);
    if (glattice1[n - 1] != '.') {
      print2("%s: %s\n", latticeName, glattice1);
      print2("?Error: Last character should be a period\n");
      exit(0);
    }
    /* if (instr(1, left(glattice1, n - 1), ".") != 0) { */
    if (strchr(glattice1, '.') != glattice1 + n - 1) {
      print2("%s: %s\n", latticeName, glattice1);
      print2("?Error: Period can only be last character\n");
      exit(0);
    }
    if (n == 1) {
      print2("%s: %s\n", latticeName, glattice1);
      print2("?Error: Diagram must have at least one block\n");
      exit(0);
    }
    atoms = 0;
    blocks = 1;
    blockSize[blocks] = 0;
    extendedNotationOffset = 0; /* For + notation */
    for (i = 0; i < n; i++) {
      if (glattice1[i] == ',' || glattice1[i] == '.') {
        /* End of block */
        if (blockSize[blocks] < MIN_BLOCK_SIZE) {
          print2("%s: %s\n", latticeName, glattice1);
          print2(
            "?Error: Block %ld has %ld atoms, but minimum block size is %ld\n",
              blocks, blockSize[blocks], (long)MIN_BLOCK_SIZE);
          exit(0);
        }
        if (glattice1[i] == ',') {
          /* Start of new block */
          blocks++;
          if (blocks > MAX_BLOCKS) {
            print2("%s: %s\n", latticeName, glattice1);
            print2(
   "?Error: Maximum blocks allowed is %ld.  Increase MAX_BLOCKS in program.\n",
                (long)MAX_BLOCKS);
            exit(0);
          }
          blockSize[blocks] = 0;
        }
        continue;
      }
      if (glattice1[i] == '+') {
        /* Process the extended notation
           12...9A...Za...`{|}~+1+2...+|+}+~++1...++~+++1....
           From 23-Apr-2009 email to Mladen:
             "If in the far future we get to say 10000 atoms, that would be
             around 100 +'s per atom, obviously extremely inefficient.  But,
             we still have "0" unused, and can have an alternate (and
             compatible) notation where "0" is the start of a decimal number,
             with some non-digit, say ".", terminating it.  I'll leave a
             comment to that effect in the latticeg.c file, for when it
             becomes a problem for a future generation" */
        extendedNotationOffset += ATOM_MAPLen;
        continue;
      }

      /* Get the atom number */
      /*j = instr(1, ATOM_MAP, chr(glattice1[i]));*/
      /*let(&str1, "");*/ /* Deallocate chr call */
      jptr = strchr(ATOM_MAP, glattice1[i]);
      /* if (j == 0) { */
      if (jptr == NULL) {
        print2("%s: %s\n", latticeName, glattice1);
        print2("?Error: Illegal character '%c' in diagram\n", glattice1[i]);
        exit(0);
      }
      j = jptr - ATOM_MAP + 1; /* Atom number */

      j += extendedNotationOffset; /* For + notation */
      extendedNotationOffset = 0; /* For + notation */
      blockSize[blocks]++;
      if (blockSize[blocks] > MAX_BLOCK_SIZE) {
        print2("%s: %s\n", latticeName, glattice1);
        print2(
           "?Error: Block %ld has %ld atoms, but maximum block size is %ld \n",
             blocks, blockSize[blocks], (long)MIN_BLOCK_SIZE);
        exit(0);
      }
      /* Assign the atom */
      block[blocks][blockSize[blocks]] = j;
      if (j > atoms) atoms = j; /* Maximum atom number */
    } /* next i */
  } /* glattice1 has a period (new compact standard) */

  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i] - 1; j++) {
      for (k = j + 1; k <= blockSize[i]; k++) {
        if (block[i][j] == block[i][k]) {
          print2("%s: %s\n", latticeName, glattice1);
          print2("?Error: Duplicate Greechie atom numbers in a block\n");
          exit(0);
        }
      }
    }
  }

  /* Special function:  see if diagram has 1 or more "legs" i.e. a block
     of rank 1. */
  /* This function also checks to see that 2-atom blocks are disconnected. */
  /****** 8-Aug-2018 nm This function is not used
  legs = 0;
  if (/@oneLineOutput ||@/ removeLegs) {
    for (i = 1; i <= blocks; i++) {
      n = 0; /@ rank of block @/
      for (j = 1; j <= blockSize[i]; j++) {
        /@ Scan all other blocks for atom block[i][j] @/
        for (k = 1; k <= blocks; k++) {
          if (k == i) continue;
          for (m = 1; m <= blockSize[k]; m++) {
            if (block[i][j] == block[k][m]) {
              if (blockSize[i] == 2 || blockSize[k] == 2) {
                print2("%s: %s\n", latticeName, glattice1);
                print2("?Error: Connected 2-atom blocks are not allowed\n");
                exit(0);
              }
              n++; /@ Increase rank @/
              goto exit_scan;
            }
          }
        }
       exit_scan:
        continue;
      }
      if (n == 1) {
        /@ This is a foot @/
        legs = 1; /@ Means at least one foot @/
        break;
      }
    } /@ next i @/
  }
  *******/

  /* Count gaps in atom numbering */
  let(&str1, string(atoms + 1, '0'));
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      str1[block[i][j]] = '1';
    }
  }
  n = 0; /* Number of gaps in atom numbering */
  for (i = 1; i <= atoms; i++) {
    if (str1[i] == '0') n++;
  }


  /********* loop.c program ************/
  /* If we wish to have gaps filled in, uncomment the line below
     (and the label it goes to below) */
  /* if (i==i) goto SKIP_TO_FILLED_IN_GAPS; */
  /* Deallocate and re-initialize from any previous pass */
  for (i = 1; i <= loopListSize; i++) {
    let(&loopList[i], "");
  }
  loopListSize = 0;
  let(&allLoopsSoFar, "");

  if (!oneLineOutput) print2("Original: %s\n", /*greechieStmt*/ glattice1);
  for (i = 1; i <= blocks; i++) {
    if (!oneLineOutput) print2("Starting block = %ld\n", i);

    failedTrials = 0; /* Initialize for starting block */ /* 20-Mar-2017 nm */

    wideLet(&wideStr1, wideString(1, (wideChar)i));
    /* Call the main loop-finding function */
    loop(wideStr1);

    /* 20-Mar-2017 nm */
    if (userTimeout != 0 && failedTrials >= userTimeout) {
      timedOut = 1;
    }

  }
  if (!oneLineOutput) exit(0); /* Only process the 1st diagram */

  /* Process -b, -b<n> options from here on */

  /* If no loop was found, use a fake loop of size 0 so that we
     won't get a blank line for the output */
  if (loopListSize == 0) {
    loopListSize++;
    loopSizeList[loopListSize] = 0;
    loopList[loopListSize] = "";
    let(&(loopList[loopListSize]), cat(",,", glattice1, NULL));
  }

  if (loopListSize == /*MAX_LOOPS*/ userMaxLoops) {
    loopWarning = 1;
  }

  /* Output up to nBiggestLoops of the biggest loops */
  maxLoopSize = 0;
  for (i = 1; i <= loopListSize; i++) {
    if (loopSizeList[i] > maxLoopSize) maxLoopSize = loopSizeList[i];
  }
  biggestCount = 0;
  for (i = 1; i <= loopListSize; i++) {
    if (loopSizeList[i] == maxLoopSize) {
      if (biggestCount != 0) print2(" "); /* Separate multiple loops on line */
      let(&str1, cat("00-", str((double)(loopSizeList[i])),
          /* Put ? after loop size if max loops exceeded */
          /*(loopListSize == /&MAX_LOOPS&/ userMaxLoops*/
          (loopWarning == 1
              || timedOut == 1  /* 20-Mar-2017 nm */
              ) ? "?" : "",
          /* Note that "atoms" is max atom# here; subtract # of gaps */
                "-a", str((double)(atoms - n)), "-b",
                str((double)blocks), "-00 ",
                loopList[i], NULL));
      print2("%s", str1);
      biggestCount++;
      if (biggestCount >= nBiggestLoops) break;
    }
  }
  print2("\n");
  /* Skip the rest of this for loop.c */
  /* 8-Aug-2018 nm "i == i" causes compiler warning, so just comment
     out the skipped code. */
  /***** start of commented out for loop.c
  if (i == i) goto returnPoint; /@ Skip the rest of this for loop.c @/
  /@ SKIP_TO_FILLED_IN_GAPS: @/
  /@@@@@@@@ end loop.c part @@@@@@@@@@@/


  /@ Error if gaps in numbering @/
  /@ 24-Apr-09 - gaps in atom numbering are now allowed @/
  /@
  if (n > 0) {
    print2("%s: %s\n", latticeName, glattice1);
    print2("?Error: There are gaps in atom numbering\n");
    exit(0);
  }

  @/

  wideLet(&atomReverseMap, wideString(atoms + 1, '?'));
  /@ If there are gaps, remap the atoms to fill in the gaps @/
  if (n > 0) {
    wideLet(&atomRemap, wideString(atoms + 1, '?'));
    j = 0;
    for (i = 1; i <= atoms; i++) {
      if (str1[i] == '1') {
        j++; /@ Atom is used @/
        atomRemap[i] = (wideChar)j;
        atomReverseMap[j] = (wideChar)i; /@ To correlate to input diagram @/
      }
    }
    if (atoms - j != n) bug(24); /@ Sanity check @/
    atoms = j; /@ True number of atoms, with no gaps @/
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        block[i][j] = atomRemap[block[i][j]];
      }
    }
    wideLet(&atomRemap, wideNullString); /@ Deallocate memory @/
  } else {
    /@ There is no remapping needed; make the reverse map the identity fn. @/
    for (i = 1; i <= atoms; i++) {
      atomReverseMap[i] = (wideChar)i;
    }
  }
  atomReverseMap[0] = 0; /@ In case non-atoms 0 or 1 are used @/


  /@ This is the global greechie diagram for use wherever
     we want to print it out. @/
  /@ if (instr(1, glattice1, ".") == 0 @/
  if (strchr(glattice1, '.') == NULL
                          /@ No period - assume old standard:  3-atom blocks @/
         || n > 0) {
             /@ Also, if there are atom numbering gaps, rewrite the diagram. @/
    /@ First, compute the size of the new diagram @/
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > ATOM_MAPLen) {
          /@ Handle extended notation @/
          m++;
          k -= ATOM_MAPLen;
        }
        m++;
      }
      m++;
    }
    let(&greechieStmt, space(m)); /@ Preallocate string to computed size @/
    /@ Next, fill in the characters @/
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > ATOM_MAPLen) {
          /@ Handle extended notation @/
          greechieStmt[m] = '+';
          m++;
          k -= ATOM_MAPLen;
        }
        greechieStmt[m] = ATOM_MAP[k - 1];
        m++;
      }
      if (i < blocks) {
        greechieStmt[m] = ',';
        m++;
      } else {
        greechieStmt[m] = '.';
        m++;
      }
    }
    if (greechieStmt[m] != 0) bug(25); /@ Must be end of string @/
  } else {
    /@ It is already in the new compact form @/
    let(&greechieStmt, glattice1);
  }

  /@ Enhance lattice name with atom/block count @/
  let(&latticeName, cat(latticeName, " (", str((double)atoms), "/",
      str((double)blocks), ")", NULL));

  if (removeLegs && legs > 0) {
    if (!oneLineOutput) print2("%s >0 legs, skipped: %s\n", latticeName,
        greechieStmt);
    /@nodes = 0;@/ /@ Force lattice to be skipped @/
    goto returnPoint;
  }

  /@@@@@@@@@ loop.c program @@@@@@@@@@@@/
  /@ This block is never executed.  It uses the greechieStmt with
     atom gaps filled in.  To use this block, uncomment the
     SKIP_TO_FILLED_IN_GAPS goto above. @/
  /@ Deallocate and re-initialize from previous pass @/
  for (i = 1; i <= loopListSize; i++) {
    let(&loopList[i], "");
  }
  loopListSize = 0;
  let(&allLoopsSoFar, "");

  if (!oneLineOutput) print2("%s original\n", greechieStmt);
  for (i = 1; i <= blocks; i++) {
    if (!oneLineOutput) print2("Starting block = %ld\n", i);
    failedTrials = 0; /@ Initialize for starting block @/ /@ 20-Mar-2017 nm @/
    wideLet(&wideStr1, wideString(1, (wideChar)i));
    loop(wideStr1);
  }
  if (!oneLineOutput) exit(0); /@ Only process the 1st diagram @/
  /@ Output the largest n loops @/
  maxLoopSize = 0;
  for (i = 1; i <= loopListSize; i++) {
    if (loopSizeList[i] > maxLoopSize) maxLoopSize = loopSizeList[i];
  }
  biggestCount = 0;
  for (i = 1; i <= loopListSize; i++) {
    if (loopSizeList[i] == maxLoopSize) {
      print2("%s\n", loopList[i]);
      biggestCount++;
      if (biggestCount >= nBiggestLoops) break;
    }
  }
 returnPoint:
  ********** end of commented out for loop.c ****/

  wideLet(&wideStr1, wideNullString); /* Deallocate */
  let(&str1, ""); /* Deallocate */
  let(&str2, ""); /* Deallocate */
  let(&glattice1, ""); /* Deallocate */

} /* greechie3 */

/***** loop.c program *******/
/* loop() calls itself recursively */
void loop(wideVstring thisLoopSoFar  /* Starts at index 0 */ ) {
  /* Test case:

    loop -i 1.tmp x=x

    123,345,561.

  */
  long i, j, k, g, m, n, trialBlock, a1, a2, m1, m2;
  long i1, i2, i3;
  long prevIntersection;
  long j2;
  long numOfAtoms;
  char loopFound;
  char f;
  long sharedAtoms; /* 10-Oct-03 */
  char foundShared; /* 10-Oct-03 */
  wideVstring trialLoop = wideNullString;  /* Starts at index 0 */
  static long biggestSoFar = 0;
  char straightLineTest = 0; /* 0 = loops, 1 = straight line test */
  static char s1 = 1;
  vstring revLoopStr = "";
  vstring printStr = "";
  vstring loopStr = "";
  /* 27-Sep-2009 */
  /* Blocks that will be re-ordered by atom number */
  static long ordBlock[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
          /* Start at index 1,1 */
      /* ordBlock[][] is static to prevent function call stack exhaustion
         for long loops.  Even though loop() is recursive, ordBlock[][] is
         assigned and used in the same loop() call so static should be ok. */
  long ordBlockSize[MAX_BLOCKS + 1];   /* Starts at index 1 */
  long ordBlocks = 0;
  long ordAtomInBlock = 0;
  long ordRemap[MAX_ATOMS + 1];    /* Starts at index 1 */

  static long intersection[MAX_BLOCKS + 1];    /* Starts at index 1 */
      /* This is static on purpose to save the "official" intersections so far
         to ensure a fixed, consistent intersection atom when the intersection
         has multiple atoms */
      /* The intersection atom chosen between this block and
         next block (or this block and first block if this is last block). */
                /* 15-May-2016 nm */
  long ordChars;
  vstring ordGreechieStmt = "";
  vstring ordGreechieStmtPrefix = "";
  vstring atomUsedFlags = ""; /* Temporary Y/N indicators */

  if (s1) {  /* First time */
    /*
    if (straightLineTest == 0) print2(
          "Loop test - change straightLineTest to 1 for straight line test\n");
    if (straightLineTest == 1) print2(
          "Straight line test - change straightLineTest to 0 for loop test\n");
    */
    s1 = 0;
    for (i = 1; i <= blocks; i++) {
      intersection[blocks] = 0;  /* Init not required, just for safety */
    }
  }

  /* 20-Mar-2017 nm */
  failedTrials++;  /* The number of loop() calls without finding a loop */

  /* If we found too many loops, abort to prevent array overflow */
  if (loopListSize == /*MAX_LOOPS*/ userMaxLoops) return;

  for (trialBlock = 1; trialBlock <= blocks; trialBlock++) {

    if (straightLineTest == 0) {
      /* Look for loop */

      /* Make sure this block isn't already in the thisLoopSoFar */
      f = 0;
      for (k = 0; k < wideLen(thisLoopSoFar); k++) {
        if (trialBlock == (long)(thisLoopSoFar[k])) {
          f = 1;
          break;
        }
      }
      if (f == 1) continue;

      /* See if trialBlock intersects last block in thisLoopSoFar */
      f = 0;
      if (wideLen(thisLoopSoFar) > 1) {
        prevIntersection = intersection[wideLen(thisLoopSoFar) - 1];
      } else {
        prevIntersection = -1; /* There is no previous intersection */
      }
      for (i = 1; i<= blockSize[trialBlock]; i++) {
        if (wideLen(thisLoopSoFar) == 0) bug(128);
        for (j = 1; j <= blockSize[
              /* thisLoopSoFar starts at index 0 (it is a string), so
                 thisLoopSoFar[wideLen(thisLoopSoFar)-1])] is its last entry */
              (long)(thisLoopSoFar[wideLen(thisLoopSoFar)-1])]; j++) {
          if (block[trialBlock][i] == block[
                (long)(thisLoopSoFar[wideLen(thisLoopSoFar)-1])][j]
              /* We don't want two intersections at same atom */
              && block[trialBlock][i] != prevIntersection) {
            f = 1;
            /* intersection[] starts at index 1 (it is an array) */
            /* Note that intersection[k] means the atom where block k
               intersects block k + 1 (or block 0 if end of loop) */
            intersection[wideLen(thisLoopSoFar)] = block[trialBlock][i];
            break;
          }
        }
        if (f == 1) break;
      }
      if (f == 0) continue;

      /* See if this block shares an atom with both its left and right
         blocks; if so, reject it */
      f = 0;
      if (wideLen(thisLoopSoFar) > 1) {
        for (i1 = 1;
            i1 <= blockSize[(long)(thisLoopSoFar[wideLen(thisLoopSoFar)-1])];
            i1++) {
          for (i2 = 1;
              i2 <= blockSize[(long)(thisLoopSoFar[wideLen(thisLoopSoFar)-2])];
              i2++) {
            if (block[(long)(thisLoopSoFar[wideLen(thisLoopSoFar)-1])][i1]
                == block[(long)(thisLoopSoFar[wideLen(thisLoopSoFar)-2])][i2]) {
              for (i3 = 1; i3 <= blockSize[trialBlock];  i3++) {
                if (block[(long)(thisLoopSoFar[wideLen(thisLoopSoFar)-1])][i1]
                    == block[trialBlock][i3]) {
                  f = 1;  /* An atom is shared by left,middle,right blocks */
                  break;
                }
              } /* next i3 */
              if (f == 1) break;
            } /* if */
          } /* next i2 */
          if (f == 1) break;
        } /* next i1 */
      } /* if */
      if (f == 1) continue; /* left,middle,right share an atom; reject it */


      /* 15-May-2016 nm */
      if (twoOrMore == 0) {
        /* 15-Jan-2012 nm Added this section to detect "...,24GF,FGIH,..." */
        /* Make sure trialBlock doesn't intersect previous block at another
           atom */
        f = 0;
        /* (The following loop has 1 iteration, which is the previous block) */
        for (k = wideLen(thisLoopSoFar) - 1; k <= wideLen(thisLoopSoFar) - 1;
            k++) {
          for (i = 1; i<= blockSize[trialBlock]; i++) {
            for (j = 1; j <= blockSize[(long)(thisLoopSoFar[k])]; j++) {
              if (block[trialBlock][i] == block[(long)(thisLoopSoFar[k])][j]) {
                if (block[trialBlock][i]
                      != intersection[wideLen(thisLoopSoFar)]) {
                  f = 1;
                  break;
                }
              }
            }
            if (f == 1) break;
          }
        }
        if (f == 1) continue;
      } /* if twoOrMore == 0 */

      /* Make sure trialBlock doesn't intersect middle blocks, or 1st
         block at intersection point of last block */
      f = 0;
      /* Scan all blocks that shouldn't share atoms (note the -1 and that
         we don't include the first block k=0 since it may form a loop,
         detected later) */
      for (k = 1; k < wideLen(thisLoopSoFar) - 1; k++) {
        for (j = 1; j <= blockSize[(long)(thisLoopSoFar[k])]; j++) {
          for (i = 1; i<= blockSize[trialBlock]; i++) {
            if (block[trialBlock][i] == block[(long)(thisLoopSoFar[k])][j]) {
              /* We have an intersection with a middle block. */
              f = 1;
              break;
            }
          }
          if (f == 1) break;
        }
      }
      if (f == 1) continue;

      /* See if trialBlock intersects 1st block */
      loopFound = 0;
      f = 0;
      /* (The following loop has 1 iteration, which is the 1st block) */
      for (k = 0; k < 1; k++) {
        for (i = 1; i<= blockSize[trialBlock]; i++) {
          for (j = 1; j <= blockSize[(long)(thisLoopSoFar[k])]; j++) {
            if (block[trialBlock][i] == block[(long)(thisLoopSoFar[k])][j]
                  && block[trialBlock][i]
                      != intersection[wideLen(thisLoopSoFar)]) {
              f = 1;
              /* This is the intersection with the "next" block i.e. the
                 beginning of the loop */
              intersection[wideLen(thisLoopSoFar) + 1] = block[trialBlock][i];
              break;
            }
          }
          if (f == 1) break;
        }
      }
      if (f == 1) loopFound = 1;

      if (loopFound) {

        /* 20-Mar-2017 nm */
        failedTrials = 0; /* Reset the timeout counter */

        /* 15-May-2016 nm */
        if (twoOrMore == 0) {
          /* 15-Jan-2012 nm Added this section to detect "24GF,...,FGIH." */
          /* Make sure trialBlock doesn't intersect last block at another
             atom */
          f = 0;
          /* (The following loop has 1 iteration, which is the 1st block) */
          for (k = 0; k < 1; k++) {
            for (i = 1; i<= blockSize[trialBlock]; i++) {
              for (j = 1; j <= blockSize[(long)(thisLoopSoFar[k])]; j++) {
                if (block[trialBlock][i] == block[
                    (long)(thisLoopSoFar[k])][j]) {
                  if (block[trialBlock][i]
                        != intersection[wideLen(thisLoopSoFar) + 1]) {
                    f = 1;
                    break;
                  }
                }
              } /* next j */
              if (f == 1) break;
            } /* next i */
          } /* next k */
          if (f == 1) continue;
        } /* if twoOrMore == 0 */
      } /* if loopFound */

      wideLet(&trialLoop, wideCat(thisLoopSoFar, wideString(1,
             (wideChar)trialBlock), NULL));

      /* For better diagram - make sure that no other block shares
         all atoms with the blocks so far */
      /* 10-Oct-03 nm - The above only works for 3-atom blocks.  For the
         general case, we make sure that no block (not in the blocks
         collected so far) shares 3 or more atoms with the blocks so far. */
      g = 0;
      for (m = 1; m <= blocks; m++) { /* For each remaining block */
        sharedAtoms = 0; /* 10-Oct-03 */
        if (wideChrInStr(1, trialLoop, (wideChar)m) != 0) continue; /* Skip blocks so far */
        for (n = 1; n <= blockSize[m]; n++) { /* For each atom in it */
          foundShared = 0;
          for (k = 0; k < wideLen(trialLoop); k++) { /* For each block so far */
            for (i = 1; i<= blockSize[(long)(trialLoop[k])]; i++) {
                                                      /* For each atom in it */
              if (block[(long)(trialLoop[k])][i] == block[m][n]) {
                foundShared = 1; /* A shared atom was found */
                break;
              }
            } /* next i */
            if (foundShared == 1) break;
                               /* Skip the rest of this block if a shared
                                  atom was found (two can't be shared in
                                  a Greechie diagram) */
                               /* 10-Oct-03 - may have to revisit this for
                                  MMP diagrams? */
          } /* next k */
          /* if (g == 0) break; */  /* (removed 10-Oct-03) */
          /* 10-Oct-03 */
          if (foundShared == 1) sharedAtoms++;  /* Count the shared atom found */
          if (sharedAtoms >= 3) {
            g = 1; /* Can't draw straight line */
            break;
          } else {
            g = 0; /* Still possible to draw straight line; continue search */
          }
          /* End of 10-Oct-03 */
        } /* next n */
        if (g == 1) break;  /* If g=1 it means we can't draw w/ only straight
                               lines */
      } /* next m */
      /*if (g == 1) continue;*/  /* This is if we don't even want to print it */


      if (loopFound == 1 && wideLen(thisLoopSoFar) > 1) { /* Loop found */
             /* The trialBlock hasn't been added yet, so if
                wideLen(thisLoopSoFar) >= 2, then the loop is size >= 3 */
        if (wideLen(thisLoopSoFar) + 1 != wideLen(trialLoop)) bug(129);
                             /* Make sure trialLoop has the trialBlock added */
        /*
        for (k = 0; k < wideLen(trialLoop); k++) {
          for (i = 1; i<= blockSize[(long)(trialLoop[k])]; i++) {
            print2(" %ld", block[(long)(trialLoop[k])][i]);
          }
          print2(" ");
        }
        if (g) print2(" g");
        print2("\n");
        */

        /* Print right-justified loop size for later sorting by user */
        if (!oneLineOutput) {
          let(&printStr, cat(
              space(3 - (long)strlen(str((double)(wideLen(trialLoop))))),
              str((double)(wideLen(trialLoop))), " ", NULL));
        } else {
          let(&printStr, "");
        }
        let(&loopStr, "");
        /* trialLoop has a list of the blocks in the loop */
        let(&ordGreechieStmtPrefix, printStr);
        ordBlocks = 0;

        /* trialLoop has a list of the blocks in the loop */
        for (k = 0; k < wideLen(trialLoop); k++) {
          /* Note that the block numbers start at 0, not 1, here for
             use as index to the wideStrings */
          /* Get the previous block (0-based) */
          if (k == 0) {
            m1 = wideLen(trialLoop) - 1;
          } else {
            m1 = k - 1;
          }

          /* Get the next block (0-based) */
          if (k == wideLen(trialLoop) - 1) {
            m2 = 0;
          } else {
            m2 = k + 1;
          }

          /* Find the (an) atom intersecting the previous block */
          /* Add 1 to m1 because intersection[] is 1-based */
          a1 = intersection[m1 + 1];

          /* Find the (an) atom intersecting the next block */
          /* I.e., the intersection[] value at _this_ block k+1 */
          /* Add 1 to k because intersection[] is 1-based */
          a2 = intersection[k + 1];
          /* Initialize char string of Y/N flags */
          let(&atomUsedFlags, string(blockSize[(long)(trialLoop[k])], 'N'));

          /* Add the "official" left intersection as the first atom */
          for (i = blockSize[(long)(trialLoop[k])]; i >= 1; i--) {
            if (atomUsedFlags[i - 1] != 'N') bug(130);
            if (block[(long)(trialLoop[k])][i] == a1) {
              atomUsedFlags[i - 1] = 'Y';
            }
          }
          let(&printStr, cat(printStr,
              /* chr(ATOM_MAP[a1 - 1]) */ getAtomName(a1), NULL));
          /*let(&loopStr, cat(loopStr, getAtomName(a1), NULL)); */
          /*let(&revLoopStr, cat(getAtomName(a1), revLoopStr, NULL)); */
          ordBlocks++;
          ordAtomInBlock = 1;
          ordBlockSize[ordBlocks] = blockSize[(long)(trialLoop[k])];
          ordBlock[ordBlocks][ordAtomInBlock] = a1;

          /* Add any other atoms intersecting the left block */
          for (i = 1; i <= blockSize[(long)(trialLoop[k])]; i++) {
            if (atomUsedFlags[i - 1] == 'Y') continue;
            f = 0;
            for (j2 = 1; j2 <= blockSize[(long)(trialLoop[m1])]; j2++) {
              if (block[(long)(trialLoop[m1])][j2] ==
                   block[(long)(trialLoop[k])][i]) {
                f = 1;
                break;
              }
            }
            if (f == 1) {
              let(&printStr, cat(printStr,
                  /* chr(ATOM_MAP[block[(long)(trialLoop[k])][i] - 1]) */
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL));
              /*let(&loopStr, cat(loopStr,
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL));*/
              ordAtomInBlock++;
              ordBlock[ordBlocks][ordAtomInBlock] = block[(long)(trialLoop[k])][i];
              atomUsedFlags[i - 1] = 'Y';
            }
          } /* Next i */

          /* Add any atoms not intersecting the right block */
          for (i = 1; i <= blockSize[(long)(trialLoop[k])]; i++) {
            if (atomUsedFlags[i - 1] == 'Y') continue;
            f = 0;
            for (j2 = 1; j2 <= blockSize[(long)(trialLoop[m2])]; j2++) {
              if (block[(long)(trialLoop[m2])][j2] ==
                   block[(long)(trialLoop[k])][i]) {
                f = 1;  /* It does intersect the block on the right */
                break;
              }
            }
            if (f == 0) {
              let(&printStr, cat(printStr,
                  /* chr(ATOM_MAP[block[(long)(trialLoop[k])][i] - 1]) */
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL));
              /* let(&loopStr, cat(loopStr,
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL)); */
              ordAtomInBlock++;
              ordBlock[ordBlocks][ordAtomInBlock] = block[(long)(trialLoop[k])][i];
              atomUsedFlags[i - 1] = 'Y';
            }
          } /* Next i */

          /* Add any atoms intersecting the right block that aren't the
             right-intersecting atom */
          for (i = 1; i <= blockSize[(long)(trialLoop[k])]; i++) {
            if (atomUsedFlags[i - 1] == 'Y') continue;
            f = 0;
            for (j2 = 1; j2 <= blockSize[(long)(trialLoop[m2])]; j2++) {
              if (block[(long)(trialLoop[m2])][j2] ==
                    block[(long)(trialLoop[k])][i]
                  && block[(long)(trialLoop[k])][i] != a2) {
                f = 1;
                break;
              }
            }
            if (f == 1) {
              let(&printStr, cat(printStr,
                  /* chr(ATOM_MAP[block[(long)(trialLoop[k])][i] - 1]) */
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL));
              /*let(&loopStr, cat(loopStr,
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL)); */
              ordAtomInBlock++;
              ordBlock[ordBlocks][ordAtomInBlock] = block[(long)(trialLoop[k])][i];
              atomUsedFlags[i - 1] = 'Y';
            }
          } /* Next i */

          /* Add the "official" right-intersecting atom */
          for (i = 1; i <= blockSize[(long)(trialLoop[k])]; i++) {
            if (atomUsedFlags[i - 1] == 'Y') continue;
            f = 0;
            for (j2 = 1; j2 <= blockSize[(long)(trialLoop[m2])]; j2++) {
              if (block[(long)(trialLoop[m2])][j2] ==
                    block[(long)(trialLoop[k])][i]
                  && block[(long)(trialLoop[k])][i] == a2) {
                f = 1;
                break;
              }
            }
            if (f == 1) {
              let(&printStr, cat(printStr,
                  /* chr(ATOM_MAP[block[(long)(trialLoop[k])][i] - 1]) */
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL));
              /*let(&loopStr, cat(loopStr,
                  getAtomName(block[(long)(trialLoop[k])][i]), NULL)); */
              ordAtomInBlock++;
              ordBlock[ordBlocks][ordAtomInBlock] = block[(long)(trialLoop[k])][i];
              atomUsedFlags[i - 1] = 'Y';
              break;
            }
          } /* Next i */

          if (f == 0) {
            printf(
 "######debug: ordAtomInBlock=%ld ordBlocks=%ld ordBlockSize[ordBlocks]=%ld\n",
                ordAtomInBlock, ordBlocks, ordBlockSize[ordBlocks]);
            fflush(stdout);
            bug(131);
          }

          if (ordAtomInBlock != ordBlockSize[ordBlocks]) {
            printf(
 "######debug: ordAtomInBlock=%ld ordBlocks=%ld ordBlockSize[ordBlocks]=%ld\n",
                ordAtomInBlock, ordBlocks, ordBlockSize[ordBlocks]);
            fflush(stdout);
            bug(123);
          }

          if (k < wideLen(trialLoop) - 1) {
            let(&printStr, cat(printStr, ",", NULL));
            /*let(&loopStr, cat(loopStr, ",", NULL));*/
            /*let(&revLoopStr, cat(",", revLoopStr, NULL));*/
          }
          if (k == wideLen(trialLoop) - 1) {
            if (!oneLineOutput) {
              let(&printStr, cat(printStr, ".", NULL));
            } else {
              let(&printStr, cat(printStr, ",,,", NULL));
            }
          }
        } /* (k = 0; k < wideLen(trialLoop); k++) */

        /* Build the loopStr for eliminating matches to previously found loops */
        /* The loopStr has a string of block numbers */
        let(&loopStr, ",");
        let(&revLoopStr, ",");
        for (k = 0; k < wideLen(trialLoop); k++) {
          /* Forward loop */
          let(&loopStr, cat(loopStr, str((double)(trialLoop[k])),
              ",", NULL));
          /* Reverse loop */
          let(&revLoopStr, cat(revLoopStr,
              str((double)(trialLoop[wideLen(trialLoop) - k - 1])),
              ",", NULL));
        }

        if (!instr(1, allLoopsSoFar, loopStr) &&
            !instr(1, allLoopsSoFar, revLoopStr)) {

          /* It is a new loop */
          /* Add to loop list - add twice so rotated loops will be matched */
          let(&allLoopsSoFar, cat(allLoopsSoFar, " ", loopStr,
              right(loopStr, 2), /* Trim leading comma */
              " ", NULL));

          if (!oneLineOutput) {
            let(&printStr, cat(printStr, "  ", NULL));
          }

          /* Print remaining blocks for reference */
          for (k = 1; k <= blocks; k++) {
            /*if (strchr(trialLoop, k) == NULL) {*/
            if (wideChrInStr(1, trialLoop, (wideChar)k) == 0) {
              ordBlocks++;
              ordBlockSize[ordBlocks] = blockSize[k];

              for (i = 1; i<= blockSize[k]; i++) {
                /* print2("%c", ATOM_MAP[block[k][i] - 1]); */
                let(&printStr, cat(printStr,
                    /* chr(ATOM_MAP[block[k][i] - 1]) */
                    getAtomName(block[k][i]),
                    NULL));

                ordBlock[ordBlocks][i] = block[k][i];

                /* Show if it occurs in loop */
                /* 19-Jan-2012 nm Deleted old code: */
                /* if (strchr(loopStr, ATOM_MAP[block[k][i] - 1]) != NULL) { */
                /* 19-Jan-2012 nm The replacement code below handles
                   extended ++ notation */
                f = 0;
                for (m = 0; m < wideLen(trialLoop); m++) {
                  for (n = 1; n <= blockSize[(long)(trialLoop[m])]; n++) {
                    if (block[(long)(trialLoop[m])][n] == block[k][i]) {
                      f = 1;
                      break;
                    }
                  }
                  if (f == 1) break;
                }
                if (f == 1) {

                  /* Occurs */
                  /* print2("*"); */
                  let(&printStr, cat(printStr,
                      (pipeMode ? "." : "*"),
                      NULL));
                } else {
                  /* Does not occur */
                  /* print2("."); */
                  if (!oneLineOutput) {
                    let(&printStr, cat(printStr, ".", NULL));
                  }
                }
              }
              /* print2(" "); */
              if (!oneLineOutput) {
                let(&printStr, cat(printStr, " ", NULL));
              } else {
                let(&printStr, cat(printStr, ",", NULL));
              }
            }
          }
          if (oneLineOutput) {
            /* Change the last comma to a dot */
            n = (long)strlen(printStr);
            if (printStr[n - 1] != ',') {
              bug(285);
            }
            printStr[n - 1] = '.';
          }

          if (g && !oneLineOutput) {
            /* print2(" can't be drawn with all straight lines"); */
            let(&printStr, cat(printStr,
                " can't be drawn with all straight lines", NULL));
          }
          if (!oneLineOutput) {
            print2("%s\n", printStr);
          } else {
            if (loopListSize == /*MAX_LOOPS*/ userMaxLoops)
                                                /* Prevent array overflow */
              break; /* Out of trialBlock loop */
            loopListSize++;
            loopList[loopListSize] = ""; /* Make sure vstring initialized */
            let(&(loopList[loopListSize]), printStr);
            loopSizeList[loopListSize] = wideLen(trialLoop);
          }
          /* print2("\n"); */
          /* Added 27-Sep-2009 - print Greechie diag. w/ 123,456, etc. */

          if (ordBlocks != blocks) bug(124);

          /* First, re-order the ordBlock atom numbers */

          /* Renumber the atoms starting at 1 from left to right */
          /* This code is roughly from mmpsubset.c */
          for (i = 0; i <= MAX_ATOMS; i++) {
               /* It seems "atoms" is not avail. so use MAX_ATOMS */
            ordRemap[i] = 0;
          }
          numOfAtoms = 0;
          for (i = 1; i <= ordBlocks; i++) {
            for (j = 1; j <= ordBlockSize[i]; j++) {
              if (ordRemap[ordBlock[i][j]] == 0) {
                numOfAtoms++; /* A new atom was found */
                if (numOfAtoms > MAX_ATOMS) bug(126);
                if (ordBlock[i][j] >  MAX_ATOMS) bug(125);
                ordRemap[ordBlock[i][j]] = numOfAtoms;
              }
              ordBlock[i][j] = ordRemap[ordBlock[i][j]];
            }
          }

          if (oneLineOutput) {
            /* We now know the number of atoms.  Add atom and block
               info to output string. */
            /*
            let(&(loopList[loopListSize]), cat("00-", str(wideLen(trialLoop)),
                "-a", str(numOfAtoms), "-b", str(blocks), "-00 ", printStr,
                NULL));
            */
            continue; /* To next trialBlock */
          }

          /* First, compute the size of the new diagram */
          /* (extended notation code is from mmpsubset.c) */
          ordChars = 0;
          for (i = 1; i <= ordBlocks; i++) {
            for (j = 1; j <= ordBlockSize[i]; j++) {
              k = ordBlock[i][j];
              while (k > ATOM_MAPLen) {
                /* Handle extended notation */
                ordChars++;
                k -= ATOM_MAPLen;
              }
              ordChars++;
            }
            ordChars++;
          }
          let(&ordGreechieStmt, space(ordChars)); /* Preallocate string to
                                                     computed size */
          /* Next, fill in the characters */
          ordChars = 0;
          for (i = 1; i <= ordBlocks; i++) {
            for (j = 1; j <= ordBlockSize[i]; j++) {
              k = ordBlock[i][j];
              while (k > ATOM_MAPLen) {
                /* Handle extended notation */
                ordGreechieStmt[ordChars] = '+';
                ordChars++;
                k -= ATOM_MAPLen;
              }
              ordGreechieStmt[ordChars] = ATOM_MAP[k - 1];
              ordChars++;
            }
            if (i < ordBlocks) {
              ordGreechieStmt[ordChars] = ',';
              ordChars++;
            } else {
              ordGreechieStmt[ordChars] = '.';
              ordChars++;
            }
          }
          if (ordGreechieStmt[ordChars] != 0) bug(127); /* Must be end of
                                                           string */
          ordGreechieStmtPrefix[0] = '=';
          if (!oneLineOutput) {
            print2("%s%s\n", ordGreechieStmtPrefix, ordGreechieStmt);
          }
          let(&ordGreechieStmt, ""); /* Deallocate memory */
          let(&ordGreechieStmtPrefix, ""); /* Deallocate memory */

          /* End of 27-Sep-2009 mod */
        } /* if (!instr(1, allLoopsSoFar, loopStr)) */
        continue; /* To next trialBlock */
      } else {
        loop(trialLoop); /* We don't have a loop yet, so add another block */

        /* 20-Mar-2017 nm */
        /* If there was a timeout, abort further searches for this starting
           block */
        /* This return will pop up all the way back to the initial loop()
           call */
        if (userTimeout != 0 && failedTrials >= userTimeout) {
          goto RETURN_POINT;
        }

      } /* if (loopFound && strlen(sofar) > 1) */
      wideLet(&trialLoop, wideNullString);
    } /* if (straightLineTest == 0) - if we're looking for loop */


    /*******************/
    if (straightLineTest == 1) {
      /* we're looking for biggest set drawable with
                       straight lines only */

      /* Look for duplicate blocks */
      f = 0;
      for (k = 0; k < wideLen(thisLoopSoFar); k++) {
        if (trialBlock == (long)(thisLoopSoFar[k])) {
          f = 1;
          break;
        }
      }
      if (f == 1) continue;


      wideLet(&trialLoop, wideCat(thisLoopSoFar, wideString(1, (wideChar)trialBlock), NULL));

      /* For straight lines - make sure that no other block shares
         all atoms with the blocks so far */
      g = 0;
      for (m = 1; m <= blocks; m++) {
        if (wideChrInStr(1, trialLoop, (wideChar)m) != 0) continue;
        for (n = 1; n <= blockSize[m]; n++) {
          g = 0;
          for (k = 0; k < wideLen(trialLoop); k++) {
            for (i = 1; i<= blockSize[(long)(trialLoop[k])]; i++) {
              if (block[(long)(trialLoop[k])][i] == block[m][n]) {
                g = 1;
                break;
              }
            }
            if (g == 1) break;
          }
          if (g == 0) break;
        }
        if (g == 1) break;
      }
      if (g == 1) continue;



      if (wideLen(thisLoopSoFar) > biggestSoFar) {
                      /* Found a biggest one drawable with straight lines */
        /*
        for (k = 0; k < wideLen(trialLoop); k++) {
          for (i = 1; i<= blockSize[(long)(trialLoop[k])]; i++) {
            print2(" %ld", block[(long)(trialLoop[k])][i]);
          }
          print2(" ");
        }
        if (g) print2(" g");
        print2("\n");
        */
        for (k = 0; k < wideLen(trialLoop); k++) {
          for (i = 1; i<= blockSize[(long)(trialLoop[k])]; i++) {
            print2("%c", ATOM_MAP[block[(long)(trialLoop[k])][i] - 1]);
          }
          if (k < wideLen(trialLoop) - 1) print2(",");
          if (k == wideLen(trialLoop) - 1) print2(".");
        }

        print2(" %ld", wideLen(trialLoop));
        print2("\n");
        biggestSoFar = wideLen(thisLoopSoFar);
        continue;
      } else {
        if (wideLen(thisLoopSoFar) < blocks) {
          loop(trialLoop);

          /* 20-Mar-2017 nm */
          /* If there was a timeout, abort further searches for this starting
             block */
          /* This return will pop up all the way back to the initial loop()
             call */
          if (userTimeout != 0 && failedTrials >= userTimeout) {
            goto RETURN_POINT;
          }

        }
      }
      wideLet(&trialLoop, wideNullString);

    } /* if (straightLineTest == 1) - if we're looking for biggest set
              drawable with straight lines only */


  } /* next trialblock */

  /* Deallocate strings */
 RETURN_POINT:
  wideLet(&trialLoop, wideNullString);
  let(&revLoopStr, "");
  let(&printStr, "");
  let(&loopStr, "");
  let(&atomUsedFlags, "");
} /* loop() */


/* Return the ASCII name of an atom */
/* This returns a temporary allocation for use with let()  */
vstring getAtomName(long atomNumber) {
  long k, m;
  vstring atomName;
  /* First, compute the size of the return string */
  k = atomNumber;
  m = 1;
  while (k > ATOM_MAPLen) {
    /* Handle extended notation */
    m++;
    k -= ATOM_MAPLen;
  }
  atomName = tempAlloc(m + 1); /* Preallocate string to computed size */
  /* Next, fill in the characters */
  atomName[m] = 0; /* End of string */
  k = atomNumber;
  m = 1;
  while (k > ATOM_MAPLen) {
    /* Handle extended notation */
    atomName[m - 1] = '+';
    m++;
    k -= ATOM_MAPLen;
  }
  atomName[m - 1] = ATOM_MAP[k - 1];
  if (atomName[m] != 0) bug(18); /* Must be end of string */
  return (atomName);
} /* getAtomName() */



/* Use like any vstring function (left, right,...) */
vstring printableAtomName(long atomNum)
{
  /* Returns the ASCII name corresponding to an atom
     1,2,3,.....  =>
     12...9A...Za...`{|}~+1+2...+|+}+~++1...++~+++1.... */
  long m, k;
  vstring atomName = "";
  if (atomNum <= 0) return ""; /* Not an atom (e.g. 0 or 1 node) */
  m = 1;
  k = atomNum;
  while (k > ATOM_MAPLen) {
    /* Handle extended notation */
    m++;
    k -= ATOM_MAPLen;
  }
  /*let(&atomName, space(m));*/ /* Pre-allocate space for atom name */
  atomName = tempAlloc(m + 1); /* Pre-allocate space for atom name */
  atomName[m] = 0;
  k = atomNum;
  m = 0;
  while (k > ATOM_MAPLen) {
    /* Handle extended notation */
    atomName[m] = '+';
    m++;
    k -= ATOM_MAPLen;
  }
  atomName[m] = ATOM_MAP[k - 1];
  return atomName;
}



/*****************************************************************************/
/*       Copyright (C) 2000  NORMAN D. MEGILL  <nm@alum.mit.edu>             */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/

/*34567890123456 (79-character line to adjust text window width) 678901234567*/
/*
mmvstr.h - VMS-BASIC variable length string library routines header
This is a collection of useful built-in string functions available in VMS BASIC.
*/

/**************************************************************************

Variable-length string handler
------------------------------

     This collection of string-handling functions emulate most of the
string functions of VMS BASIC.  The objects manipulated by these functions
are strings of a special type called 'vstring' which
have no pre-defined upper length limit but are dynamically allocated
and deallocated as needed.  To use the vstring functions within a program,
all vstrings must be initially set to the null string when declared or
before first used, for example:

        vstring string1 = "";
        vstring stringArray[] = {"","",""};

        vstring bigArray[100][10]; /- Must be initialized before using -/
        int i,j;
        for (i=0; i<100; i++)
          for (j=0; j<10; j++)
            bigArray[i][j] = ""; /- Initialize -/


     After initialization, vstrings should be assigned with the 'let(&'
function only; for example the statements

        let(&string1,"abc");
        let(&string1,string2);
        let(&string1,left(string2,3));

all assign the second argument to 'string1'.  The 'let(&' function must
not be used to initialize a vstring for the first time.

     The 'cat' function emulates the '+' concatenation operator in BASIC.
It has a variable number of arguments, and the last argument should always
be NULL.  For example,

        let(&string1,cat("abc","def",NULL));

assigns "abcdef" to 'string1'.  Warning: 0 will work instead of NULL on the
VAX but not on the Macintosh, so always use NULL.

     All other functions are generally used exactly like their BASIC
equivalents.  For example, the BASIC statement

        let string1$=left$("def",len(right$("xxx",2)))+"ghi"+string2$

is emulated in c as

        let(&string1,cat(left("def",len(right("xxx",2))),"ghi",string2,NULL));

Note that ANSII c does not allow "$" as part of an identifier
name, so the names in c have had the "$" suffix removed.

     The string arguments of the vstring functions may be either standard c
strings or vstrings (except that the first argument of the 'let(&' function
must be a vstring).  The standard c string functions may use vstrings or
vstring functions as their string arguments, as long as the vstring variable
itself (which is a char * pointer) is not modified and no attempt is made to
increase the length of a vstring.  Caution must be excercised when
assigning standard c string pointers to vstrings or the results of
vstring functions, as the memory space may be deallocated when the
'let(&' function is next executed.  For example,

        char *stdstr; /- A standard c string pointer -/
         ...
        stdstr=left("abc",2);

will assign "ab" to 'stdstr', but this assignment will be lost when the
next 'let(&' function is executed.  To be safe, use 'strcpy':

        char stdstr1[80]; /- A fixed length standard c string -/
         ...
        strcpy(stdstr1,left("abc",2));

Here, of course, the user must ensure that the string copied to 'stdstr1'
does not exceed 79 characters in length.

     The vstring functions allocate temporary memory whenever they are called.
This temporary memory is deallocated whenever a 'let(&' assignment is
made.  The user should be aware of this when using vstring functions
outside of 'let(&' assignments; for example

        for (i=0; i<10000; i++)
          print2("%s\n",left(string1,70));

will allocate another 70 bytes or so of memory each pass through the loop.
If necessary, dummy 'let(&' assignments can be made periodically to clear
this temporary memory:

        for (i=0; i<10000; i++)
          {
          print2("%s\n",left(string1,70));
          let(&dummy,"");
          }

It should be noted that the 'linput' function assigns its target string
with 'let(&' and thus has the same effect as 'let(&'.

************************************************************************/


void *tempAlloc(long size)    /* String memory allocation/deallocation */
{
  /* When "size" is >0, "size" bytes are allocated. */
  /* When "size" is 0, all memory previously allocated with this */
  /* function is deallocated. */
  /* EXCEPT:  When startTempAllocStack != 0, the freeing will start at
     startTempAllocStack. */
  int i;
  if (size) {
    if (tempAllocStackTop>=(MAX_ALLOC_STACK-1)) {
      print2("?Error: Temporary string stack overflow\n");
      bug(101);
    }
    if (!(tempAllocStack[tempAllocStackTop++]=malloc((size_t)size))) {
      print2("?Error: Temporary string allocation failed\n");
      bug(102);
    }
    return (tempAllocStack[tempAllocStackTop-1]);
  } else {
    for (i=startTempAllocStack; i<tempAllocStackTop; i++) {
      free(tempAllocStack[i]);
    }
    tempAllocStackTop=startTempAllocStack;
    return (NULL);
  }
}


/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the string may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s)
{
    if (tempAllocStackTop>=(MAX_ALLOC_STACK-1)) {
      print2("?Error: Temporary string stack overflow\n");
      bug(103);
    }
    tempAllocStack[tempAllocStackTop++]=s;
}


void let(vstring *target,vstring source)        /* String assignment */
/* This function must ALWAYS be called to make assignment to */
/* a vstring in order for the memory cleanup routines, etc. */
/* to work properly.  If a vstring has never been assigned before, */
/* it is the user's responsibility to initialize it to "" (the */
/* null string). */
{
  long targetLength,sourceLength;

  sourceLength=(long)strlen(source);  /* Save its length */
  targetLength=(long)strlen(*target); /* Save its length */
  if (targetLength) {
    if (sourceLength) { /* source and target are both nonzero length */

      if (targetLength>=sourceLength) { /* Old string has room for new one */
        strcpy(*target,source); /* Re-use the old space to save CPU time */
      } else {
        /* Free old string space and allocate new space */
        free(*target);  /* Free old space */
        *target=malloc((size_t)sourceLength+1); /* Allocate new space */
        if (!*target) {
          print2("?Error: String memory couldn't be allocated\n");
          bug(104);
        }
        strcpy(*target,source);
      }

    } else {    /* source is 0 length, target is not */
      free(*target);
      *target= "";
    }
  } else {
    if (sourceLength) { /* target is 0 length, source is not */
      *target=malloc((size_t)sourceLength+1);   /* Allocate new space */
      if (!*target) {
        print2("?Error: Could not allocate string memory\n");
        bug(105);
      }
      strcpy(*target,source);
    } else {    /* source and target are both 0 length */
      *target= "";
    }
  }

  tempAlloc(0); /* Free up temporary strings used in expression computation */

}
void wideLet(wideVstring *target, wideVstring source)
                                                   /* Wide string assignment */
/* This function must ALWAYS be called to make assignment to */
/* a wideVstring in order for the memory cleanup routines, etc. */
/* to work properly.  If a wideVstring has never been assigned before, */
/* it is the user's responsibility to initialize it to the empty string). */
{
  long targetLength,sourceLength;

  sourceLength = wideLen(source);  /* Save its length */
  targetLength = wideLen(*target); /* Save its length */
  if (targetLength) {
    if (sourceLength) { /* source and target are both nonzero length */
      if (targetLength >= sourceLength) { /* Old string has room for new one */
        wideCpy(*target, source); /* Re-use the old space to save CPU time */
      } else {
        /* Free old string space and allocate new space */
        free(*target);  /* Free old space */
        *target = malloc(((size_t)sourceLength + 1) * sizeof(wideChar));
                                                       /* Allocate new space */
        if (!*target) {
          print2("?Error: Wide string memory couldn't be allocated\n");
          bug(104);
        }
        wideCpy(*target,source);
      }
    } else {    /* source is 0 length, target is not */
      free(*target);
      *target = wideNullString;
    }
  } else {
    if (sourceLength) { /* target is 0 length, source is not */
      *target = malloc((size_t)(sourceLength + 1) * sizeof(wideChar));
                                                       /* Allocate new space */
      if (!*target) {
        print2("?Error: Could not allocate wide string memory\n");
        bug(105);
      }
      wideCpy(*target, source);
    } else {    /* source and target are both 0 length */
      *target = wideNullString;
    }
  }

  tempAlloc(0); /* Free up temporary strings used in expression computation */

}




vstring cat(vstring string1,...)        /* String concatenation */
#define MAX_CAT_ARGS 30
{
  va_list ap;   /* Declare list incrementer */
  vstring arg[MAX_CAT_ARGS];    /* Array to store arguments */
  long argLength[MAX_CAT_ARGS]; /* Array to store argument lengths */
  int numArgs=1;        /* Define "last argument" */
  int i;
  long j;
  vstring ptr;

  arg[0]=string1;       /* First argument */

  va_start(ap,string1); /* Begin the session */
  while ((arg[numArgs++]=va_arg(ap,char *)))
        /* User-provided argument list must terminate with 0 */
    if (numArgs>=MAX_CAT_ARGS-1) {
      print2("?Error: Too many cat() arguments\n");
      bug(106);
    }
  va_end(ap);           /* End var args session */

  numArgs--;    /* The last argument (0) is not a string */

  /* Find out the total string length needed */
  j=0;
  for (i=0; i<numArgs; i++) {
    argLength[i]=(long)strlen(arg[i]);
    j=j+argLength[i];
  }
  /* Allocate the memory for it */
  ptr=tempAlloc(j+1);
  /* Move the strings into the newly allocated area */
  j=0;
  for (i=0; i<numArgs; i++) {
    strcpy(ptr+j,arg[i]);
    j=j+argLength[i];
  }
  return (ptr);

}
wideVstring wideCat(wideVstring string1, ...)  /* Wide string concatenation */
{
  va_list ap;   /* Declare list incrementer */
  wideVstring arg[MAX_CAT_ARGS];    /* Array to store arguments */
  long argLength[MAX_CAT_ARGS]; /* Array to store argument lengths */
  int numArgs = 1;        /* Define "last argument" */
  int i;
  long j;
  wideVstring ptr;

  arg[0] = string1;       /* First argument */

  va_start(ap, string1); /* Begin the session */
  while ((arg[numArgs++] = va_arg(ap, wideVstring)))
        /* User-provided argument list must terminate with 0 */
    if (numArgs >= MAX_CAT_ARGS - 1) {
      print2("?Error: Too many cat() arguments\n");
      bug(106);
    }
  va_end(ap);           /* End var args session */

  numArgs--;    /* The last argument (NULL) is not a string */

  /* Find out the total string length needed */
  j = 0;
  for (i = 0; i < numArgs; i++) {
    argLength[i] = wideLen(arg[i]);
    j = j + argLength[i];
  }
  /* Allocate the memory for it */
  ptr = tempAlloc((j + 1) * (long)sizeof(wideChar));
  /* Move the strings into the newly allocated area */
  j = 0;
  for (i = 0; i < numArgs; i++) {
    wideCpy(ptr + j, arg[i]);
    j = j + argLength[i];
  }
  return (ptr);
}


/* 20-Oct-2013 Wolf Lammen - allow unlimited input line lengths */
/* Input a line from the user or from a file */
/* Returns 1 if a (possibly empty) line was successfully read, 0 if EOF */
int linput(FILE *stream, const char* ask, vstring *target)
{                           /* Note: "vstring *target" means "char **target" */
  /*
    BASIC:  linput "what"; a$
    c:      linput(NULL, "what?", &a);

    BASIC:  linput #1, a$                         (error trap on EOF)
    c:      if (!linput(file1, NULL, &a)) break;  (break on EOF)

  */
  /* This function prints a prompt (if 'ask' is not NULL), gets a line from
    the stream, and assigns it to target using the let(&...) function.
    0 is returned when end-of-file is encountered.  The vstring
    *target MUST be initialized to "" or previously assigned by let(&...)
    before using it in linput. */
  char f[10001]; /* Read in chunks up to 10000 characters */
  int result = 0;
  int eol_found = 0;
  if (ask) {
    printf("%s", ask);
    fflush(stdout);
  }
  if (stream == NULL) stream = stdin;
  while (!eol_found && fgets(f, sizeof(f), stream))
  {
    size_t endpos = strlen(f) - 1;
    eol_found = (f[endpos] == '\n');
    /* If the last line in the file has no newline, eol_found will be 0 here.
       The fgets() above will return 0 and prevent another loop iteration. */
    if (eol_found)
      f[endpos] = 0; /* The return string will have any newline stripped. */
    if (result)
      /* Append additional parts of the line to *target */
      /* The let() reallocates *target and copies the concatenation of the
         old *target and the additional input f[] to it */
      let(target /* = &(*target) */, cat(*target, f, NULL));
    else
      /* This is the first time through the loop, and normally
         the only one unless the input line overflows f[] */
      let(target, f);  /* Allocate *target and copy f to it */
    result = 1;
  }
  return result;
} /* linput */


/* Find out the length of a string */
long len(vstring s)
{
  return ((long)strlen(s));
}


/* Extract sin from character position start to stop into sout */
long wideLen(wideVstring s)
{
  long n;
  for (n = 0; *s != WIDE_ENDCHAR; s++)
    n++;
  return n;
}

/* Copy wide string s to t, analogous to strcpy */
void wideCpy(wideVstring t, wideVstring s)
{
  while ((*t++ = *s++) != WIDE_ENDCHAR)
    ;
}


/* Extract sin from character position start to stop into sout */
vstring seg(vstring sin,long start,long stop)
{
  vstring sout;
  long length;
  if (start<1) start=1;
  if (stop<1) stop=0;
  length=stop-start+1;
  if (length<0) length=0;
  sout=tempAlloc(length+1);
  strncpy(sout,sin+start-1,(size_t)length);
  sout[length]=0;
  return (sout);
}

/* Extract sin from character position start for length len */
vstring mid(vstring sin,long start,long length)
{
  vstring sout;
  if (start<1) start=1;
  if (length<0) length=0;
  sout=tempAlloc(length+1);
  strncpy(sout,sin+start-1,(size_t)length);
/*??? Should db be substracted from if length > end of string? */
  sout[length]=0;
  return (sout);
}

/* Extract leftmost n characters */
wideVstring wideMid(wideVstring sin, long start, long length)
{
  wideVstring sout;
  long i, l;
  if (start < 1) start = 1;
  l = wideLen(sin) - start + 1;
  if (length > l) length = l;
  if (length < 0) length = 0;
  sout = tempAlloc((length + 1) * (long)sizeof(wideChar));
  /* Emulate strncpy(sout,sin+start-1,(size_t)length); */
  for (i = 0; i < length; i++) sout[i] = sin[i + start - 1];
  sout[length] = WIDE_ENDCHAR;
  return (sout);
}


/* Extract leftmost n characters */
vstring left(vstring sin,long n)
{
  vstring sout;
  if (n < 0) n = 0;
  sout=tempAlloc(n+1);
  strncpy(sout,sin,(size_t)n);
  sout[n]=0;
  return (sout);
}

/* Extract after character n */
wideVstring wideLeft(wideVstring sin, long n)
{
  wideVstring sout;
  long i, l;
  if (n < 0) n = 0;
  sout = tempAlloc((n + 1) * (long)sizeof(wideChar));

  /* Emulate strncpy(sout, sin, (size_t)n); */
  l = wideLen(sin);
  if (n > l) n = l;
  for (i = 0; i < n; i++) sout[i] = sin[i];
  sout[n] = WIDE_ENDCHAR;

  return (sout);
}


/* Extract after character n */
vstring right(vstring sin,long n)
{
  /*??? We could just return &sin[n-1], but this is safer for debugging. */
  vstring sout;
  long i;
  if (n<1) n=1;
  i = (long)strlen(sin);
  if (n>i) return ("");
  sout = tempAlloc(i - n + 2);
  strcpy(sout,&sin[n-1]);
  return (sout);
}

wideVstring wideRight(wideVstring sin, long n)
{
  /*??? We could just return &sin[n-1], but this is safer for debugging. */
  wideVstring sout;
  long i;
  if (n < 1) n = 1;
  i = wideLen(sin);
  if (n > i) return (wideNullString);
  sout = tempAlloc((i - n + 2) * (long)sizeof(wideChar));
  wideCpy(sout, &sin[n - 1]);
  return (sout);
}


/* Emulate VMS BASIC edit$ command */
vstring edit(vstring sin,long control)
#define isblank_(c) ((c==' ') || (c=='\t'))
    /* 11-Sep-2009 nm Added _ to fix '"isblank" redefined' compiler warning */
{
  /* EDIT$ (from VMS BASIC manual)
       Syntax:  str-vbl = EDIT$(str-exp, int-exp)
       Values   Effect
       1        Trim parity bits
       2        Discard all spaces and tabs
       4        Discard characters: CR, LF, FF, ESC, RUBOUT, and NULL
       8        Discard leading spaces and tabs
       16       Reduce spaces and tabs to one space
       32       Convert lowercase to uppercase
       64       Convert [ to ( and ] to )
       128      Discard trailing spaces and tabs
       256      Do not alter characters inside quotes

       (non-BASIC extensions)
       512      Convert uppercase to lowercase
       1024     Tab the line (convert spaces to equivalent tabs)
       2048     Untab the line (convert tabs to equivalent spaces)
       4096     Convert VT220 screen print frame graphics to -,|,+ characters

       (Added 10/24/03:)
       8192     Discard CR only (to assist DOS-to-Unix conversion)
  */
  vstring sout;
  long i, j, k, m;
  int last_char_is_blank;
  int trim_flag, discardctrl_flag, bracket_flag, quote_flag, case_flag;
  int alldiscard_flag, leaddiscard_flag, traildiscard_flag, reduce_flag;
  int processing_inside_quote=0;
  int lowercase_flag, tab_flag, untab_flag, screen_flag, discardcr_flag;
  unsigned char graphicsChar;

  /* Set up the flags */
  trim_flag = control & 1;
  alldiscard_flag = control & 2;
  discardctrl_flag = control & 4;
  leaddiscard_flag = control & 8;
  reduce_flag = control & 16;
  case_flag = control & 32;
  bracket_flag = control & 64;
  traildiscard_flag = control & 128;
  quote_flag = control & 256;

  /* Non-BASIC extensions */
  lowercase_flag = control & 512;
  tab_flag = control & 1024;
  untab_flag = control & 2048;
  screen_flag = control & 4096; /* Convert VT220 screen prints to |,-,+
                                   format */
  discardcr_flag = control & 8192; /* Discard CR's */

  /* Copy string */
  i = (long)strlen(sin) + 1;
  if (untab_flag) i = i * 7; /* Allow for max possible length */
  sout=tempAlloc(i);
  strcpy(sout,sin);

  /* Discard leading space/tab */
  i=0;
  if (leaddiscard_flag)
    while ((sout[i] != 0) && isblank_(sout[i]))
      sout[i++] = 0;

  /* Main processing loop */
  while (sout[i] != 0) {

    /* Alter characters inside quotes ? */
    if (quote_flag && ((sout[i] == '"') || (sout[i] == '\'')))
       processing_inside_quote = ~ processing_inside_quote;
    if (processing_inside_quote) {
       /* Skip the rest of the code and continue to process next character */
       i++; continue;
    }

    /* Discard all space/tab */
    if ((alldiscard_flag) && isblank_(sout[i]))
        sout[i] = 0;

    /* Trim parity (eighth?) bit */
    if (trim_flag)
       sout[i] = sout[i] & 0x7F;

    /* Discard CR,LF,FF,ESC,BS */
    if ((discardctrl_flag) && (
         (sout[i] == '\015') || /* CR  */
         (sout[i] == '\012') || /* LF  */
         (sout[i] == '\014') || /* FF  */
         (sout[i] == '\033') || /* ESC */
         /*(sout[i] == '\032') ||*/ /* ^Z */ /* DIFFERENCE won't work w/ this */
         (sout[i] == '\010')))  /* BS  */
      sout[i] = 0;

    /* Discard CR */
    if ((discardcr_flag) && (
         (sout[i] == '\015')))  /* CR  */
      sout[i] = 0;

    /* Convert lowercase to uppercase */
    /*
    if ((case_flag) && (islower(sout[i])))
       sout[i] = toupper(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((case_flag) && (sout[i] >= 'a' && sout[i] <= 'z'))
       sout[i] = (char)(sout[i] - ('a' - 'A'));

    /* Convert [] to () */
    if ((bracket_flag) && (sout[i] == '['))
       sout[i] = '(';
    if ((bracket_flag) && (sout[i] == ']'))
       sout[i] = ')';

    /* Convert uppercase to lowercase */
    /*
    if ((lowercase_flag) && (isupper(sout[i])))
       sout[i] = tolower(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((lowercase_flag) && (sout[i] >= 'A' && sout[i] <= 'Z'))
       sout[i] = (char)(sout[i] + ('a' - 'A'));

    /* Convert VT220 screen print frame graphics to +,|,- */
    if (screen_flag) {
      graphicsChar = (unsigned char)sout[i]; /* Need unsigned char for >127 */
      /* vt220 */
      if (graphicsChar >= 234 && graphicsChar <= 237) sout[i] = '+';
      if (graphicsChar == 241) sout[i] = '-';
      if (graphicsChar == 248) sout[i] = '|';
      if (graphicsChar == 166) sout[i] = '|';
      /* vt100 */
      if (graphicsChar == 218 /*up left*/ || graphicsChar == 217 /*lo r*/
          || graphicsChar == 191 /*up r*/ || graphicsChar == 192 /*lo l*/)
        sout[i] = '+';
      if (graphicsChar == 196) sout[i] = '-';
      if (graphicsChar == 179) sout[i] = '|';
    }

    /* Process next character */
    i++;
  }
  /* sout[i]=0 is the last character at this point */

  /* Clean up the deleted characters */
  for (j = 0, k = 0; j <= i; j++)
    if (sout[j]!=0) sout[k++]=sout[j];
  sout[k] = 0;
  /* sout[k] = 0 is the last character at this point */

  /* Discard trailing space/tab */
  if (traildiscard_flag) {
    --k;
    while ((k >= 0) && isblank_(sout[k])) --k;
    sout[++k] = 0;
  }

  /* Reduce multiple space/tab to a single space */
  if (reduce_flag) {
    i = j = last_char_is_blank = 0;
    while (i <= k - 1) {
      if (!isblank_(sout[i])) {
        sout[j++] = sout[i++];
        last_char_is_blank = 0;
      } else {
        if (!last_char_is_blank)
          sout[j++]=' '; /* Insert a space at the first occurrence of a blank */
        last_char_is_blank = 1; /* Register that a blank is found */
        i++; /* Process next character */
      }
    }
    sout[j] = 0;
  }

  /* Untab the line */
  if (untab_flag || tab_flag) {

    /*
    DEF FNUNTAB$(L$)      ! UNTAB LINE L$
    I9%=1%
    I9%=INSTR(I9%,L$,CHR$(9%))
    WHILE I9%
      L$=LEFT(L$,I9%-1%)+SPACE$(8%-((I9%-1%) AND 7%))+RIGHT(L$,I9%+1%)
      I9%=INSTR(I9%,L$,CHR$(9%))
    NEXT
    FNUNTAB$=L$
    FNEND
    */

    /***** old code (doesn't handle multiple lines)
    k = (long)strlen(sout);
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((i - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((i - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((i - 1) & 7);
    }
    *****/

    /* Untab string containing multiple lines */ /* 9-Jul-2011 nm */
    /* (Currently this is needed by outputStatement() in mmpars.c) */
    k = (long)strlen(sout);
    m = 0;  /* Position on line relative to last '\n' */
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] == '\n') {
        m = 0;
        continue;
      }
      m++; /* Should equal i for one-line string */
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((m - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((m - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((m - 1) & 7);
    }
  }

  /* Tab the line */
  /* (Note that this does not [yet?] handle string with multiple lines) */
  if (tab_flag) {

    /*
    DEF FNTAB$(L$)        ! TAB LINE L$
    I9%=0%
    FOR I9%=8% STEP 8% WHILE I9%<LEN(L$)
      J9%=I9%
      J9%=J9%-1% UNTIL ASCII(MID(L$,J9%,1%))<>32% OR J9%=I9%-8%
      IF J9%<=I9%-2% THEN
        L$=LEFT(L$,J9%)+CHR$(9%)+RIGHT(L$,I9%+1%)
        I9%=J9%+1%
      END IF
    NEXT I9%
    FNTAB$=L$
    FNEND
    */

    k = (long)strlen(sout);
    for (i = 8; i < k; i = i + 8) {
      j = i;

      /* 26-May-2016 nm */
      /* gcc m*.c -o metamath.exe -O2 -Wall was giving:
             mmvstr.c:285:9: warning: assuming signed overflow does not occur
             when assuming that (X - c) <= X is always true [-Wstrict-overflow]
         Here we trick gcc into turning off this optimization by moving
         the computation of i - 2 here, then referencing m instead of i - 2
         below.  Note that if "m = i - 2" is moved _after_ the "while", the
         error message returns. */
      m = i - 2;

      while (sout[j - 1] == ' ' && j > i - 8) j--;
      /*if (j <= i - 2) {*/
      if (j <= m) {  /* 25-May-2016 nm */
        sout[j] = '\t';
        j = i;
        while (sout[j - 1] == ' ' && j > i - 8 + 1) {
          sout[j - 1] = 0;
          j--;
        }
      }
    }
    i = k;
    /* sout[i]=0 is the last character at this point */
    /* Clean up the deleted characters */
    for (j = 0, k = 0; j <= i; j++)
      if (sout[j] != 0) sout[k++] = sout[j];
    sout[k] = 0;
    /* sout[k] = 0 is the last character at this point */
  }

  return (sout);
} /* edit */


/* Return a string of the same character */
vstring string(long n, char c)
{
  vstring sout;
  long j=0;
  if (n<0) n=0;
  sout=tempAlloc(n+1);
  while (j<n) sout[j++]=c;
  sout[j]=0;
  return (sout);
}


/* Return a string of spaces */
wideVstring wideString(long n, wideChar c)
{
  wideVstring sout;
  long j = 0;
  if (n < 0) n = 0;
  sout = tempAlloc((n + 1) * (long)sizeof(wideChar));
  while (j < n) sout[j++] = c;
  sout[j] = WIDE_ENDCHAR;
  return (sout);
}

/* Convert a character string to a wide string */
wideVstring wide(vstring s)
{
  long n, j;
  wideVstring sout;
  n = (long)strlen(s);
  sout = tempAlloc((n + 1) * (long)sizeof(wideChar));
  for (j = 0; j < n; j++) sout[j] = (wideChar)(s[j]);
  sout[n] = WIDE_ENDCHAR;
  return (sout);
}


/* Return a string of spaces */
vstring space(long n)
{
  return (string(n,' '));
}


/* Return a character given its ASCII value */
vstring chr(long n)
{
  vstring sout;
  sout = tempAlloc(2);
  sout[0] = (char)(n & 0xFF);
  sout[1] = 0;
  return(sout);
} /* chr */


/* Search for string2 in string 1 starting at start_position */
long instr(long start_position,vstring string1,vstring string2)
{
   char *sp1,*sp2;
   long ls1,ls2;
   long found=0;
   if (start_position<1) start_position=1;
   ls1=(long)strlen(string1);
   ls2=(long)strlen(string2);
   if (start_position>ls1) start_position=ls1+1;
   sp1=string1+start_position-1;
   while ((sp2=strchr(sp1,string2[0]))!=0) {
     if (strncmp(sp2,string2,(size_t)ls2)==0) {
        found=sp2-string1+1;
        break;
     } else
        sp1=sp2+1;
   }
   return (found);
}
/* Search for wide char in wide string starting at start */
/* First char in string is position 1 (not 0), like instr() */
/* Returns 0 if not found */
long wideChrInStr(long start, wideVstring s, wideChar c)
{
  long l, i;
  l = wideLen(s);
  if (start < 1) start = 1;
  for (i = start - 1; i < l; i++) {
    if (s[i] == c) return i + 1;
  }
  return 0;
}


/* Translate string in sin to sout based on table.
   Table must be 256 characters long!! <- not true anymore? */
vstring xlate(vstring sin,vstring table)
{
  vstring sout;
  long len_table,len_sin;
  long i,j;
  long table_entry;
  char m;
  len_sin=(long)strlen(sin);
  len_table=(long)strlen(table);
  sout=tempAlloc(len_sin+1);
  for (i=j=0; i<len_sin; i++)
  {
    table_entry= 0x000000FF & (long)sin[i];
    if (table_entry<len_table)
      if ((m=table[table_entry])!='\0')
        sout[j++]=m;
  }
  sout[j]='\0';
  return (sout);
}


/* Returns the ascii value of a character */
long ascii_(vstring c)
{
  return (long)((unsigned char)(c[0]));
}

/* Returns the floating-point value of a numeric string */
double val(vstring s)
{
  /*
  return (atof(s));
  */
  /* 12/10/98 - NDM - atof may corrupt memory when processing
     random character strings.
     The implementation below makes best guess of value of any
     random string, ignoring commas, etc. and tolerating numbers
     suffixed with sign.  "E" notation is not handled. */
  double v = 0;
  char signFound = 0;
  double power = 1.0;
  long i, length;
  length = (long)strlen(s);
  /* Scan from lsd backwards to minimize rounding errors */
  for (i = length - 1; i >= 0; i--) {
    switch (s[i]) {
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
        v = v + ((double)(s[i] - '0')) * power;
        power = 10.0 * power;
        break;
      case '.':
        v = v / power;
        power = 1.0;
        break;
      case '-':
        signFound = 1;
        break;
    }
  }
  if (signFound) v = - v;
  return v;
}


/* Returns current date as an ASCII string */
vstring date()
{
        vstring sout;
        struct tm *time_structure;
        time_t time_val;
        char *month[12];

        /* (Aggregrate initialization is not portable) */
        /* (It must be done explicitly for portability) */
        month[0]="Jan";
        month[1]="Feb";
        month[2]="Mar";
        month[3]="Apr";
        month[4]="May";
        month[5]="Jun";
        month[6]="Jul";
        month[7]="Aug";
        month[8]="Sep";
        month[9]="Oct";
        month[10]="Nov";
        month[11]="Dec";

        time(&time_val);                        /* Retrieve time */
        time_structure=localtime(&time_val); /* Translate to time structure */
        sout=tempAlloc(12);
        /* "%02d" means leading zeros with min. field width of 2 */
        sprintf(sout,"%d-%s-%02d",
                time_structure->tm_mday,
                month[time_structure->tm_mon],
                (int)((time_structure->tm_year) % 100)); /* Y2K */
        return(sout);
}

/* Return current time as an ASCII string */
vstring time_()
{
        vstring sout;
        struct tm *time_structure;
        time_t time_val;
        int i;
        char *format;
        char *format1="%d:%d %s";
        char *format2="%d:0%d %s";
        char *am_pm[2];
        /* (Aggregrate initialization is not portable) */
        /* (It must be done explicitly for portability) */
        am_pm[0]="AM";
        am_pm[1]="PM";

        time(&time_val);                        /* Retrieve time */
        time_structure=localtime(&time_val); /* Translate to time structure */
        if (time_structure->tm_hour>=12) i=1;
        else                             i=0;
        if (time_structure->tm_hour>12) time_structure->tm_hour-=12;
        if (time_structure->tm_hour==0) time_structure->tm_hour=12;
        sout=tempAlloc(12);
        if (time_structure->tm_min>=10)
          format=format1;
        else
          format=format2;
        sprintf(sout,format,
                time_structure->tm_hour,
                time_structure->tm_min,
                am_pm[i]);
        return(sout);

}


/* Return a number as an ASCII string */
vstring str(double f)
{
  /* This function converts a floating point number to a string in the */
  /* same way that %f in printf does, except that trailing zeroes after */
  /* the one after the decimal point are stripped; e.g., it returns 7 */
  /* instead of 7.000000000000000. */
  vstring s;
  long i;
  s = tempAlloc(50);
  sprintf(s, "%f", f);
  if (strchr(s, '.') != 0) {              /* the string has a period in it */
    for (i = (long)strlen(s) - 1; i > 0; i--) { /* scan string backwards */
      if (s[i] != '0') break;             /* 1st non-zero digit */
      s[i] = 0;                           /* delete the trailing 0 */
    }
    if (s[i] == '.') s[i] = 0;            /* delete trailing period */
  }
  return (s);
}


/* Return a number as an ASCII string */
vstring num1(double f)
{
  return (str(f));
}


/* Return a number as an ASCII string surrounded by spaces */
vstring num(double f)
{
  return (cat(" ",str(f)," ",NULL));
}


/*** NEW FUNCTIONS ADDED 11/25/98 ***/

/* Emulate PROGRESS "entry" and related string functions */
/* (PROGRESS is a 4-GL database language) */

/* A "list" is a string of comma-separated elements.  Example:
   "a,b,c" has 3 elements.  "a,b,c," has 4 elements; the last element is
   an empty string.  ",," has 3 elements; each is an empty string.
   In "a,b,c", the entry numbers of the elements are 1, 2 and 3 (i.e.
   the entry numbers start a 1, not 0). */

/* Returns a character string entry from a comma-separated
   list based on an integer position. */
/* If element is less than 1 or greater than number of elements
   in the list, a null string is returned. */
vstring entry(long element, vstring list)
{
  vstring sout;
  long commaCount, lastComma, i, length;
  if (element < 1) return ("");
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) commaCount++;
  if (element > commaCount) return ("");
  length = i - lastComma - 1;
  if (length < 1) return ("");
  sout = tempAlloc(length + 1);
  strncpy(sout, list + lastComma + 1, (size_t)length);
  sout[length] = 0;
  return (sout);
}

/* Emulate PROGRESS lookup function */
/* Returns an integer giving the first position of an expression
   in a comma-separated list. Returns a 0 if the expression
   is not in the list. */
long lookup(vstring expression, vstring list)
{
  long i, exprNum, exprPos;
  char match;

  match = 1;
  i = 0;
  exprNum = 0;
  exprPos = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      exprNum++;
      if (match) {
        if (expression[exprPos] == 0) return exprNum;
      }
      exprPos = 0;
      match = 1;
      i++;
      continue;
    }
    if (match) {
      if (expression[exprPos] != list[i]) match = 0;
    }
    i++;
    exprPos++;
  }
  exprNum++;
  if (match) {
    if (expression[exprPos] == 0) return exprNum;
  }
  return 0;
}


/* Emulate PROGRESS num-entries function */
/* Returns the number of items in a comma-separated list. */
long numEntries(vstring list)
{
  long i, commaCount;
  i = 0;
  commaCount = 0;
  while (list[i] != 0) {
    if (list[i] == ',') commaCount++;
    i++;
  }
  return (commaCount + 1);
}

/* Returns the character position of the start of the
   element in a list - useful for manipulating
   the list string directly.  1 means the first string
   character. */
/* If element is less than 1 or greater than number of elements
   in the list, a 0 is returned.  If entry is null, a 0 is
   returned. */
long entryPosition(long element, vstring list)
{
  long commaCount, lastComma, i;
  if (element < 1) return 0;
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) {
    if (i == 0) return 0;
    if (list[i - 1] == ',') return 0;
    commaCount++;
  }
  if (element > commaCount) return (0);
  if (list[lastComma + 1] == ',') return 0;
  return (lastComma + 2);
}


void print2(char* fmt,...)
{
  /* This performs the same operations as printf, except that if a log file is
    open, the characters will also be printed to the log file. */
  va_list ap;
  char printBuffer[100001];

  va_start(ap, fmt);
  vsprintf(printBuffer, fmt, ap); /* Put formatted string into buffer */
  va_end(ap);

  printf("%s", printBuffer); /* Terminal */
  fflush(stdout);

  if (fplog != NULL) {
    fprintf(fplog, "%s", printBuffer);  /* Print to log file */
  }
  return;
}

/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode)
{
  FILE *fp;
  vstring prefix = "";
  vstring postfix = "";
  vstring bakName = "";
  vstring newBakName = "";
  long v;

  if (!strcmp(mode, "r")) {
    fp = fopen(fileName, "r");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }
    return (fp);
  }

  if (!strcmp(mode, "w")) {
    /* See if the file already exists. */
    fp = fopen(fileName, "r");

    if (fp) {
      fclose(fp);

#define VERSIONS 9
      /* The file exists.  Rename it. */

#if defined __WATCOMC__ /* MSDOS */
      /* Make sure file name before extension is 8 chars or less */
      i = instr(1, fileName, ".");
      if (i) {
        let(&prefix, left(fileName, i - 1));
        let(&postfix, right(fileName, i));
      } else {
        let(&prefix, fileName);
        let(&postfix, "");
      }
      let(&prefix, cat(left(prefix, 5), "~", NULL));
      let(&postfix, cat("~", postfix, NULL));
      if (0) goto skip_backup; /* Prevent compiler warning */

#elif defined __GNUC__ /* Assume unix */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined THINK_C /* Assume Macintosh */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined VAXC /* Assume VMS */
      /* For debugging on VMS: */
      /* let(&prefix, cat(fileName, "-", NULL));
         let(&postfix, "-"); */
      /* Normal: */
      goto skip_backup;

#else /* Unknown; assume unix standard */
      /*if (1) goto skip_backup;*/  /* [if no backup desired] */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#endif


      /* See if the lowest version already exists. */
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      fp = fopen(bakName, "r");
      if (fp) {
        fclose(fp);
        /* The lowest version already exists; rename all to lower versions. */

        /* If version VERSIONS exists, delete it. */
        let(&bakName, cat(prefix, str(VERSIONS), postfix, NULL));
        fp = fopen(bakName, "r");
        if (fp) {
          fclose(fp);
          remove(bakName);
        }

        for (v = VERSIONS - 1; v >= 1; v--) {
          let(&bakName, cat(prefix, str((double)v), postfix, NULL));
          fp = fopen(bakName, "r");
          if (!fp) continue;
          fclose(fp);
          let(&newBakName, cat(prefix, str((double)v + 1), postfix, NULL));
          rename(bakName, newBakName);
        }

      }
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      rename(fileName, bakName);

      /***
      printLongLine(cat("The file \"", fileName,
          "\" already exists.  The old file is being renamed to \"",
          bakName, "\".", NULL), "  ", " ");
      ***/
    } /* End if file already exists */
   /*skip_backup:*/

    fp = fopen(fileName, "w");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }

    let(&prefix, "");
    let(&postfix, "");
    let(&bakName, "");
    let(&newBakName, "");

    return (fp);
  } /* End if mode = "w" */

  bug(1510); /* Illegal mode */
  return(NULL);

}


/* Bug check */
void bug(int bugNum)
{
  print2("?Error: Program bug # %d\n", bugNum);
  exit(0);
}
