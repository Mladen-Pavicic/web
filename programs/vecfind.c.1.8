/* vecfind.c */
#define VERSION "1.8 24-Mar-2017"
/* Author: Norman Megill  nm(at)alum(dot)mit(dot)edu */

/* To run this program, type:
      vecfind <option> < file1 > file2
   where
      file1 = input file with MMP diagrams in Brendan McKay's format
      file2 = output file with vector information
   See  vecfind --help  for the options and explanation.
*/

/* 1.8 24-Mar-2018 nm - fix bug that confused atom name "{" with the "{" that
   surrounds vector components; add -7d, -8d, and -9d for -master */
/* 1.7 3-Mar-2017 nm - add -5d and -6d for -master */
/* 1.6 4-Dec-2017 nm - speedup: regenerate vector pool only if MMP or
   previous MMP has a vector assignment suffix */
/* 1.5 3-Dec-2017 nm - fix memory leaks */
/* 1.4 27-Nov-2017 nm - add -master */
/* 1.3 18-Nov-2017 nm - increase maxError 2 orders of magnitude to tolerate
   more roundoff error (see Mladen email "vecfind 1.2 bug" 18-Nov-2017) */
/* 1.2 17-Nov-2017 nm - cosmetic improvements in cross product printout */
/* 1.1 17-Nov-2017 nm - fix bug in 1.0 */
/* 1.0 16-Nov-2017 nm - EXPERIMENTAL - remove vectors without orth mate if -orth;
   remove vectors not in orth basis if -basis;
   in 3d, add cross-product of every orth pair if -xp specified */
/* 0.9 18-May-2017 nm - take out "#if", "#ifdef" surrounding fflush(stdout) */
/* 0.8 26-Apr-2017 nm - better info for 2 vertices in common;
   add fflush(stdout) after all printf statements */
/* 0.7 13-Jan-2017 nm - always print explicit atom name in vector assignment
   list after the MMP, even for passing assignments */
/* 0.6 11-Jan-2017 nm - added -big option;
   workaround init bug - delete line w/ "firstTime == 0" below when fixed */
/* 0.5 10-Jan-2017 nm - speed up initial vector generation
   (-vgen) about 3-4 times. */
/* 0.4 28-Dec-2016 nm - dynamically allocate vecProdNonzero[][] to allow
   MAX_VECTORS to be increased */
/* 0.3 5-Dec-2016 nm - fixed minor errors in -v (verbose) output */
/* 0.2 5-Dec-2016 nm - removed automatic 0 and negatives from -vgen */
/* 0.1 3-Dec-2016 nm - extended dimensions to 32; increased MAX_BLOCK_SIZE
   to 32; added constant omega = e^(2*pi*i/3) */
/* 0.alpha 13-Oct-2016 nm - initial version starting from vectorfind.c */

/* History for old vectorfind.c */
/* 1.9 1-Sep-2016 nm - added -nkast option */
/* 1.8 29-Aug-2016 nm - print the deepest partial assignment of version 1.7 */
/* 1.7 16-Aug-2016 nm - add info about deepest assignment for failing MMP */
/* 1.6 19-Jun-2016 nm - fix a bug, some cleanup of variable names, comments */
/* 1.5 17-Jun-2016 nm - Added dynamic selection of next atom; removed
   -wA, -wB, -wC, -wD commands; added -static for old algorithm */
/* 1.4 9-Jun-2016 nm - Revised clustering algorithm; added commands
   -wA, -wB, -wC, -wD for user to override weights */
/* 1.3 6-Jun-2016 nm - Added -3dmany, -nc */
/* 1.2 5-May-2016 nm - fixed gcc compiler warnings */
/* 1.1 23-Jan-2014 nm - linput() now allows unlimited input line length */
/* 1.0 22-Jan-2014 nm  Added -s3, -ara, -6d */
/* 0.8 30-Mar-2010 nm  Added -ph option for using phi=(1+sqr(5))/2
   components for 4d vectors */

/*****************************************************************************/
/*       Copyright (C) 2017  NORMAN D. MEGILL  <nm at alum.mit.edu>          */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
/* #include <math.h> */
#include <complex.h>

/***********************************************************************/
/************ Start of "vstring" header stuff **************************/
/************ Do not touch anything in this section ********************/
/***********************************************************************/
typedef char* vstring;

/* String assignment - MUST be used to assign vstrings */
void let(vstring *target,vstring source);
/* String concatenation - last argument MUST be NULL */
vstring cat(vstring string1,...);

/* Emulate BASIC linput statement; returns NULL if EOF */
/* Note that linput assigns target string with let(&target,...) */
  /*
    BASIC:  linput "what";a$
    c:      linput(NULL,"what?",&a);

    BASIC:  linput #1,a$                        (error trap on EOF)
    c:      if (!linput(file1,NULL,&a)) break;  (break on EOF)

  */
/*vstring linput(FILE *stream,vstring ask,vstring *target);*/
int linput(FILE *stream, const char* ask, vstring *target);

/* Emulation of BASIC string functions */
vstring seg(vstring sin, long p1, long p2);
vstring mid(vstring sin, long p, long l);
vstring left(vstring sin, long n);
vstring right(vstring sin, long n);
vstring edit(vstring sin, long control);
vstring space(long n);
vstring string(long n, char c);
vstring chr(long n);
vstring xlate(vstring sin, vstring control);
vstring date(void);
vstring time_(void);
vstring num(double x);
vstring num1(double x);
vstring str(double x);
long len(vstring s);
long instr(long start, vstring sin, vstring s);
long rinstr(vstring string1, vstring string2);
long ascii_(vstring c);
double val(vstring s);
/* Emulation of PROGRESS string functions added 11/25/98 */
vstring entry(long element, vstring list);
vstring entry2(long element, vstring list, char c);
long lookup(vstring expression, vstring list);
long numEntries(vstring list);
long numEntries2(vstring list, char c);
long entryPosition(long element, vstring list);
/* Print to log file as well as terminal if fplog opened */
void print2(char* fmt,...);
FILE *fplog = NULL;
/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode);
/* Bug check error */
void bug(int bugNum);
/* End of functions you should call directly */


/* Do not call the ones below directly */
/******* Special pupose routines for better
      memory allocation (use with caution) *******/
/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the vstring may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s);   /* Make string have temporary allocation to be
                                    released by next let() */
#define MAX_ALLOC_STACK 100
int tempAllocStackTop=0;        /* Top of stack for tempAlloc functon */
int startTempAllocStack=0;      /* Where to start freeing temporary allocation
                                    when let() is called (normally 0, except in
                                    special nested vstring functions) */
char *tempAllocStack[MAX_ALLOC_STACK];


/*****************************************************************************/
/*********************** End of "vstring" header stuff ***********************/
/*****************************************************************************/

/* Constants */

/* Mapping for MMP diagram atoms */
#define ATOM_MAP "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs" \
    "tuvwxyz!\"#$%&'()*-/:;<=>?@[\\]^_`{|}~"
/* Maximum number of atoms - increase as needed, at expense of memory */
#define MAX_ATOMS 1000
/* Maximum number of blocks - increase as needed, at expense of memory */
#define MAX_BLOCKS 2000
/* Minimum block size */
#define MIN_BLOCK_SIZE 2
/* Maximum block size - increase as needed, at expense of memory */
#define MAX_BLOCK_SIZE 32


/* This is (81-1)/2=40 for 4d, (125-1)/2-7=55 for 3d */
/* The -nk option adds another 24 for 3d */
/* #define MAX_VECTORS 55 + 24 */  /* Old before -ph option */
/* #define MAX_VECTORS 472 */ /* After -ph option */
/* #define MAX_VECTORS 4913 */  /* After -3dmany option; 17^3 worst case */
#define MAX_VECTORS 100000
#define MAX_DIMS 32
    /* For more than 32, also need to add loop vars beyond l32 below */
#define MAX_VECGEN 100

/* Global variables */


char noClustering = 0; /* 6-Jun-2016 nm */
char nkAsterisks = 0; /* 1 if -nkast specified */ /* 31-Aug-2016 nm */
char nkSuppressPrint = 0; /* 1 to suppress "kicked" atoms in output */
char dontRemoveDupVecs = 0;
long dimensions = 0;
char noKick = 0;
char keepTryingAfterFail = 0; /* -retry mode */
char orthogonalBlockDisplay = 0;
char lockMMPAssignment = 0;
long unlockedMMPStart;
char dynamicAtomAssignment = 1; /* For -nodyn option */
char verboseMode = 0;
long backtrackLimit = 0; /* If non-zero, this is the backtrack timeout */
long lattices = 0;
char noErrorCheck = 0; /* 0 means always do error checking */
long atomMapLen; /* To store strlen(ATOM_MAP) */
long block[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
long blockSize[MAX_BLOCKS + 1];
long blocks;
long atoms; /* True number of atoms */
long maxAtom; /* Largest atom (!= atoms if there are gaps) */
long totalBacktrackCount = 0; /* For user information */

vstring MMPPrefix = ""; /* 27-Nov-2017 nm */
vstring MMPSuffix = ""; /* 27-Nov-2017 nm */
vstring inputMMP = ""; /* 27-Nov-2017 nm */

/* 9-Jun-2016 */
/* Default weights for clustering algorithm */
/* Weights below were determined experimentally for bub,peres,c-k.mmp */
/* Gives 2547,8701,7827 backtracks w/ bub,peres,conway-kochen */
long weightA = 200;
long weightB = 2;
long weightC = 100;
long weightD = 555;
/* Gives 4618 backtracks w/ bub.mmp: */
/*
long weightA = 10;
long weightB = 1;
long weightC = 10;
long weightD = 15;
*/
/* Gives 11052 backtracks w/ bub.mmp (approx. orig. algorithm) */
/*
long weightA = 1;
long weightB = 0;
long weightC = 100;
long weightD = 1;
*/
/*long double maxError = 1e-15;*/ /* Threshold below which long double is
                                 considered to be 0 */
/* See 18-Nov-2016 mladen emails "vecfind 1.2 bug" */
long double maxError = 1e-13;  /* Threshold below which long double is
                                 considered to be 0 */
char printVectorsOnlyMode = 0; /* If 1, output the vector list only; don't test */
char masterMMPOnlyMode = 0; /* If 1, generate master MMP from vector set */
char noMMPMode = 0;  /* If 1, don't read any MMP input (for -printvec mode) */
vstring preAssignment = "";  /* Preassigned vectors in MMP */
vstring vectorGenList = "";  /* List of numbers to generate vectors from */
vstring vectorFileList = "";  /* List of files to read vectors from */
/* 11-Jan-2017 nm */
char slowMode = 0; /* If 1, don't use lookup table to conserve memory */



/* Prototypes */
char addCrossProducts = 0; /* If 1, add missing cross products in -3d mode */
vstring crossComponentList = ""; /* Component list after "-xp=" */
char discardNonOrth = 0; /* If 1, discard vectors w/out orth. mate */
char discardNonBasis = 0; /* If 1, discard vectors that don't belong to
                    an orthogonal basis (more aggressive than discardNonOrth) */


/* Prototypes */
void parseAndTestMMPDiagram(vstring glattice);
char findVectorAssignment(long dims/* 3, 4, or 6 */, long *backtrackCount,
    long *highestBacktrack);
vstring parseMMP(vstring inputDiagram, char normalize);
vstring buildMMP(long blocks, long *blockSize,
    long (*block)[MAX_BLOCK_SIZE + 1], char *aTOM_MAP,
    long atomMapLen);
vstring extendedAtomName(long atom);
long extendedAtomNumber(vstring atomStr);
long double complex stringToComplex(vstring strexpr);
char vecProportional(long double complex *v1, long double complex *v2,
    long dims, long double maxErr);
char vecEqual(long double complex *v1, long double complex *v2,
    long dims, long double maxErr);
void vecStandardize(long double complex *v, long dims, long double maxErr);
long vecStringWeight(long vec, vstring (*sVecCoeff)[MAX_DIMS + 1], long dims);

/* 11-Jan-2017 nm */
char innerProductNonzero(long double complex *v1, long double complex *v2,
    long dims, long double maxErr);

char **alloc2DCharMatrix(long xsize, long ysize);
void free2DCharMatrix(char **matrix, long xsize /*, long ysize*/);
char ***alloc3DCharMatrix(long xsize, long ysize, long zsize);
void free3DCharMatrix(char ***matrix, long xsize, long ysize /*, long zsize*/);
vstring readFileToString(vstring fileName, char verbose);


/******************** Main program *******************************************/

int main(int argc, char *argv[])
{

  /* Integer variable declarations */

  /* This is how you declare some strings you want to work with */
  /* They MUST be initialized to the empty string, never to anything else */
  vstring str1 = "";
  vstring str2 = "";
  vstring argStr = "";
  long arg;
  long argLen;
  long p, q;
  /*long prevLen = 0;*/
  long double complex c;  /* General purpose complex number */

  /* if (strlen(ATOM_MAP) != MAX_ATOMS) bug(1); */ /* Before extended MMP */
  atomMapLen = (long)strlen(ATOM_MAP); /* Do here to speed up its reuse */
  if (sizeof(ATOM_MAP) - 1 != atomMapLen) bug(1);

  for (arg = 1; arg < argc; arg++) {
    let(&argStr, argv[arg]);
        /* Also purges any vstring function alloc. from previous iteration */
    argLen = (long)strlen(argStr);
    if (!strcmp(argStr, "-noclus")) {
      noClustering = 1;
    } else if (!strcmp(argStr, "-dup")) {
      dontRemoveDupVecs = 1;
    } else if (!strcmp(argStr, "-nkast")) {
      nkAsterisks = 1;
    } else if (!strcmp(argStr, "-nksup")) {
      nkSuppressPrint = 1;
    } else if (!strcmp(argStr, "-v")) {
      verboseMode = 1;
    } else if (!strcmp(argStr, "-ob")) {
      orthogonalBlockDisplay = 1;
/* Dynamic assignment is now the default
    } else if (!strcmp(argStr, "-dyn")) {
      dynamicAtomAssignment = 1;
*/
    } else if (!strcmp(argStr, "-nodyn")) {
      dynamicAtomAssignment = 0;
    } else if (!strcmp(argStr, "-retry")) {
      keepTryingAfterFail = 1;
    } else if (!strcmp(left(argStr, 2), "-t")) {
      /* Set backtrack timeout limit */
      let(&str1, right(argStr, 3));
      backtrackLimit = (long)val(str1);
      if (backtrackLimit <= 0 || strcmp(str((double)backtrackLimit), str1)) {
        fprintf(stderr, "?Error: -t argument > 2 billion, or format error\n");
        exit(1);
      }

    } else if (argStr[0] == '-' /* 1st char is "-" */
        && argStr[argLen - 1] == 'd' /* Last char is "d" */
        && !strcmp(str(val(seg(argStr, 2, argLen - 1))),
                           seg(argStr, 2, argLen - 1))) /* In btwn is a # */
        {
      if (dimensions != 0) {
        fprintf(stderr,
            "?Error: only one dimension (-3d, -4d, etc.) may be specified.\n");
        exit(1);
      }
      dimensions = (long)val(seg(argStr, 2, argLen - 1));
      if (dimensions < 3 || dimensions > MAX_DIMS) {
        fprintf(stderr,
            "?Error: dimension should be more than 2 and less than %ld.\n",
            (long)(MAX_DIMS + 1));
        exit(1);
      }
    } else if (!strcmp(argStr, "-nk")) {
      noKick = 1; /* Don't ignore vertices w/ connected to only 1 edge */
    } else if (!strcmp(argStr, "-printvec")) {
      printVectorsOnlyMode = 1; /* Output the vector list only; don't test */
    } else if (!strcmp(argStr, "-master")) {
      masterMMPOnlyMode = 1; /* Output an MMP built from vector set */
    } else if (!strcmp(argStr, "-nommp")) {
      noMMPMode = 1;  /* Don't read any MMP input (for -printvec mode) */
    } else if (!strcmp(argStr, "-big")) {  /* 11-Jan-2017 nm */
      slowMode = 1;  /* Don't use inner prod lookup table to conserve mem */
    } else if (!strcmp(left(argStr, 6), "-vgen=")) {
      let(&vectorGenList, right(argStr, 7));
    /* 16-Nov-2017 nm */
    } else if (!strcmp(left(argStr, 3), "-xp")) {
      addCrossProducts = 1;
      if (argStr[3] == '=') {
        let(&crossComponentList, right(argStr, 5));
      } else if (argStr[3] != 0) {
        fprintf(stderr, "?Error: Expected \"=\" or nothing after \"-xp\".\n");
        exit(1);
      }
    } else if (!strcmp(argStr, "-orth")) {
      discardNonOrth = 1;  /* Discard vectors w/out orthogonal mate */
    } else if (!strcmp(argStr, "-basis")) {
      discardNonBasis = 1; /* Discard vectors no in orth. basis */
    } else if (!strcmp(left(argStr, 7), "-vfile=")) {
      let(&vectorFileList, right(argStr, 8));
    } else if (!strcmp(left(argStr, 6), "-calc=")) {
      /* Do a complex number calculation and exit */
      let(&str1, right(argStr, 7));
      c = stringToComplex(str1);
      if (cimagl(c) == 0.0) {
        printf("%s = %LG\n", str1, creall(c));
      } else {
        printf("%s = %LG + %LG*i\n", str1, creall(c), cimagl(c));
      }
      fflush(stdout);
      goto return_point;
    } else if (!strcmp(argStr, "--help")) {
printf("vecfind.c  Version %s\n", VERSION);
printf("To run this program, type:\n");
printf(
"   vecfind <option> <option>... < file1 > file2\n");
printf(
"where\n");
printf(
"   file1 = input file with MMP diagrams in Brendan McKay's format\n");
printf(
"   file2 = output file with vector assignment information\n");
printf("\n");

printf(
"Mandatory option:  Exactly one of -3d,...,-32d must be specified.\n");
printf("\n");

printf(
"   -3d = use 3-dimensional vectors\n");
printf(
"   -4d = use 4-dimensional vectors\n");
printf(
"      ...\n");
printf(
"   -32d = use 32-dimensional vectors\n");
printf("\n");

printf(
"Vector source options:\n");
printf("\n");

printf(
"There are 3 sources of vectors:  (1) any preassigned vectors attached\n");
printf(
"to the input MMP from a previous run of this program, (2) any vectors in\n");
printf(
"files specified by -vfile, and (3) vectors generated from a list of\n");
printf(
"components specified by -vgen.  Any combination of these 3 sources may\n");
printf(
"be used.  A vector that is proportional to any previous vector is\n");
printf(
"ignored unless -dup is specified.  To obtain a file with a list of the\n");
printf(
"vectors that were read in, without processing any MMPs, use -printvec and\n");
printf(
"optionally -nommp.\n");
printf("\n");

printf(
"If preassigned vectors are attached to the input MMP in the form\n");
printf(
"<vertex>=<vector>, e.g.  \"A={0,0,1}\", they are attached to those\n");
printf(
"vertices at the start of the scan.\n");
printf("\n");

printf(
"   -vfile=<list> = read vectors from a comma-separated list of files.\n");
printf(
"         Each file should have a list of vectors, each of which consists\n");
printf(
"         of comma-separated components surrounded by \"{\" and \"}\",\n");
printf(
"         for example, \"{0,2,Sqrt[3],(1+iSqrt[2])^2}\" for a 4-dimensional\n");
printf(
"         vector.  There may be one or multiple vectors per line.\n");
printf(
"         Spaces are optional and ignored.  Use the -calc option to check\n");
printf(
"         whether a vector component evaluates as expected.\n");
printf(
"   -vgen=<list> = generate all possible vectors from a list of components\n");
printf(
"         e.g. \"-vgen=0,1,-1,Sqrt[2],2Sqrt[2]\" will generate vectors having\n");
printf(
"         components from the set consisting of these 5 values.\n");
printf(
"   -xp[=<component_list>] = in -3d mode, the cross products of all\n");
printf(
"         orthogonal vector pairs are added to the vector list if they are\n");
printf(
"         missing.  Normally cross products are long expressions like\n");
printf(
"         \"(1)*(-sqrt2)-(sqrt2)*(2)\", but if \"-3sqrt2\" is in either the\n");
printf(
"         -vgen <list> or the -xp <component_list> e.g.\n");
printf(
"         \"-xp=5,-3sqrt2,4\", then \"-3sqrt2\" will be used instead for\n");
printf(
"         better appearance.\n");
printf(
"   -orth = keep only vectors with orthogonal mates.\n");
printf(
"   -basis = keep only vectors that are part of an orthogonal basis.\n");
printf(
"   -printvec = print the list of vectors the program will assume based on\n");
printf(
"         -vfile, -vgen, and any pre-assignment in the first input MMP.\n");
printf(
"         The input MMP is not otherwise processed, and no output MMP.\n");
printf(
"         is created.\n");
printf(
"   -master = generate an MMP that is assigned the list of vectors,\n");
printf(
"         for use as a master MMP for the states01 -r option.\n");
printf(
"   -nommp = don't require an input MMP when -printvec or -master is specified,\n");
printf(
"         but just use the vectors from -vfile and/or -vgen.\n");
printf("\n");

printf(
"Other options:\n");
printf("\n");

printf(
"   -retry = don't give up as soon as a contradiction is found, but\n");
printf(
"         instead try to assign more vectors, at the price of a slower\n");
printf(
"         run time.  The -retry mode is useful to get a maximal partial\n");
printf(
"         assignment of non-conflicting vectors.\n");
printf(
"   -nk = \"no kick\" - don't ignore (kick out) vertices on only one edge\n");
printf(
"   -t = time limit per diagram (limit of number of backtracks).  -t should\n");
printf(
"         be followed by a positive integer less than 2 billion, with no\n");
printf(
"         space, for example -t1000000.  The output is \"timeoutnnn\"\n");
printf(
"         instead of \"pass\" or \"fail\" when this limit is exceeded.\n");
printf(
"         There is no limit if -t is not specified, and the program may run\n");
printf(
"         indefinitely (\"forever\").\n");
printf(
"   -ob = display the vectors in orthogonal blocks corresponding to the\n");
printf(
"         blocks in the MMP diagram.  The default is to display them in\n");
printf(
"         order corresponding to the atom numbering 123...ABC...abc... as\n");
printf(
"         described in mp/nm email of 27-Feb-04.\n");
/*
printf(
"   -dyn = use an algorithm that dynamically determines the atom with\n");
printf(
"         the fewest vectors that can be assigned and processes it next,\n");
printf(
"         in order to encourage earlier backtracking.  Without -dyn, the\n");
printf(
"         algorithm of vectorfind.c versions 1.4 and earlier is used.\n");
*/
printf(
"   -big = compute inner product as needed instead of pre-computing a\n");
printf(
"         a table.  This is less likely to run out of memory but takes\n");
printf(
"         longer to run.\n");
printf(
"   -v = verbose mode with extra output information for debugging\n");
printf(
"   -calc=<expression> = compute a complex number expression.  This option\n");
printf(
"         is standalone; if it is present, all other options are ignored.\n");
printf(
"          For example:  \"./vecfind -calc=Sqrt[-1]+2^3\" prints\n");
printf(
"         \"8 + 1*i\".  If expression has spaces or shell-interpreted\n");
printf(
"         characters such as parentheses, enclose the option in single\n");
printf(
"         quotes, such as \"./vecfind '-calc=1 * (3 + 2)'\".  Spaces in\n");
printf(
"         the expression are ignored.  Square brackets act the same as\n");
printf(
"         parentheses e.g.  \"2*(3+4)\" = \"2*[3+4]\".  Multiplication is\n");
printf(
"         expressed with either juxtaposition or explicitly with \"*\",\n");
printf(
"         so 2(5) = (2)5 = 2*5 = 10.  The other operations available are\n");
printf(
"         addition \"+\", subtraction \"-\", division \"/\", and\n");
printf(
"         exponentiation \"^\".  Unary plus and minus are also expressed\n");
printf(
"         with \"+\" and \"-\".  The imaginary constant is \"i\"; 2i = i2\n");
printf(
"         = i*2.  Square roots are expressed with \"sqr\" or \"sqrt\" (not\n");
printf(
"         case sensitive); Sqr4 = sqrt4 = Sqrt(4) = Sqrt[4] = 2;\n");
printf(
"         sqrsqr16 = sqr(sqr(16)) = 2. Addition, subtraction, unary plus,\n");
printf(
"         and unary minus have lower binding strength than multiplication\n");
printf(
"         and division, which are evaluated left to right:  5/2*3 = (5/2)*3.\n");
printf(
"         Exponentiation has higher binding strength:  5*2^2 = 5*(2^2) and\n");
printf(
"         -2^2 = -(2^2).  Nested exponentiation requires parenthesis to\n");
printf(
"         eliminate ambiguity:  2^2^2 is undefined; use 2^(2^2) or (2^2)^2.\n");
printf(
"         Square root has the highest binding strength:  sqr2^2 = (sqr2)^2;\n");
printf(
"         sqr-1 is undefined, use sqr(-1) = i. The built-in constants, which\n");
printf(
"         _are_ case-sensitive, are i, e, pi, phi (golden ratio), and\n");
printf(
"         omega = e^(2*pi*i/3).\n");
printf(
"         Decimal numbers can be expressed as usual: 3.1415.  Scientific\n");
printf(
"         notation (not yet implemented) uses capital E:  1E3, 4.2E-2.\n");
printf(
"   --help = print this help message\n");
printf("\n");

printf(
"Options mainly for debugging purposes:\n");
printf("\n");

printf(
"   -nkast = print an asterisk to tag isolated (one-edge) vertices.\n");
printf(
"   -nksup = suppress printing of isolated vertices when -nk is NOT\n");
printf(
"         specified.\n");
printf(
"   -noclus = turn off the clustering algorithm that tries tightly coupled\n");
printf(
"         blocks first.  Instead, process them in the order supplied by the\n");
printf(
"         user.  (This is mainly for debugging purposes.)\n");
printf(
"   -nodyn = turn off the dynamic clustering algorithm.  (This\n");
printf(
"         is mainly for debugging purposes.)\n");
printf(
"   -dup = don't strip out proportional (\"duplicate\") vectors when reading\n");
printf(
"         input files.  (This is mainly for reproducing the old\n");
printf(
"         vectorfind.c behavior for debugging purposes.)\n");
printf("\n");

printf(
"Notes:\n");
printf(
"    1. \"No kick\" means don't kick out (don't ignore) atoms occurring in\n");
printf(
"       only one block.   The -nkast option prints asterisks in the output\n");
printf(
"       to tag one-block atoms.\n");
printf("\n");
printf(
"Purpose:  This program determines whether a vector assignment to atoms\n");
printf(
"in an MMP diagram is possible per mp/nm email of 17-Jan-04.  The output is\n");
printf(
"in the format specified in that email.  The MMP input file notation is the\n");
printf(
"same as for Greechie diagrams described in the help for the program\n");
printf(
"latticeg.c\n");
printf("\n");
printf("Example of use:\n");
printf("  vecfind -4d -vgen=0,1,-1 < test.mmp\n");
printf("where test.mmp contains the two lines:\n");
printf("  1234,4567,789A,ABCD,DEFG,GHI1,35CE,29BI,68FH.\n");
printf("  1234,1A56,1789,37AB,2CDE,ACFG,8HIJ,4DHK,9EFI,BGJK.\n");
printf("corresponding to two diagrams, the first admitting a valid vector\n");
printf("assigment from the set 0, +1, -1 and the second one not admitting one.\n");
printf("\n");
/* See Mladen email "Re: 3d KS" 12:59PM 16-Aug-2016, 4:26 AM 26-Aug-2016 4:26 AM*/
printf("Output format (without -v):\n");
printf("  For passing diagrams:\n");
printf("    #1 pass:: 1234,4567,...,ABCD.{{0,0,0,1}{0,0,1,0} ...\n");
printf("        consisting of \"pass\" followed by the diagram followed by\n");
printf("        the assignment that was found\n");
printf("  For failing diagrams:\n");
printf("    #2(4/18=22%%) fail:: 1234,4567,...,ABCD.{{1={0,0,0,1},\n");
printf("             3={0,1,0,0},7={1,0,0,0},A={0,0,1,0}}\n");
printf("        where \"4/18=0%%22%%\" means that at most 4 vectors out of 18\n");
printf("        vertices were successfully assigned, or 22%%, followed by\n");
printf("        the diagram, then the partially successful assignment.\n");
printf("  For timed-out diagrams:\n");
printf("    #2(4/18=22%%)timeout10000:: 1234,4567,...,ABCD.{{1={0,0,0,1},\n");
printf("             3={0,1,0,0},7={1,0,0,0},A={0,0,1,0}}\n");

      goto return_point;
    } else {
      fprintf(stderr,
       "?Unrecognized option: \"%s\".  Type \"vecfind --help\" for help.\n",
          argv[arg]);
      exit(1);
    }
  }

  if (dimensions == 0) {
    fprintf(stderr,
        "?Error: exactly one of -3d, -4d, ..., -32d must be specified.\n");
    exit(1);
  }
  if (noMMPMode == 1 && printVectorsOnlyMode == 0 && masterMMPOnlyMode == 0) {
    fprintf(stderr,
        "?Error: -nommp may be used only with -printvec or -master.\n");
    exit(1);
  }
  if (printVectorsOnlyMode == 1 && masterMMPOnlyMode == 1) {
    fprintf(stderr,
        "?Error: Both -printvec and -master may not be specified.\n");
    exit(1);
  }
  if (addCrossProducts == 1 && dimensions != 3) {
    fprintf(stderr,
        "?Error: -xp may be specified only in -3d mode.\n");
    exit(1);
  }


  /* 9-Jun-2016 nm */
  /* 17-Jun-2016 -wA,B,C,D are hard-coded now */
  /*
  if (verboseMode) {
    printf(
"Clustering algorithm weights (see --help): -wA%ld -wB%ld -wC%ld -wD%ld\n",
        weightA, weightB, weightC, weightD);
    fflush(stdout);
  }
  */

  if (noMMPMode == 1) {
    /* noMMPMode will only generate a vector list without reading
       MMP's from standard input */
    parseAndTestMMPDiagram("");
    exit(0);
  }


  /* Start of input file scan */
  while (1) {
    /* Get line from 1st file */
    if (linput(NULL, NULL, &inputMMP) == 0) break; /* 0 means EOF */

    /* Get the partial (or full) vector assignment from a previous run
       of vecfind.c or the old vectorfind.c */
    /*prevLen = (long)strlen(preAssignment);*/ /* Previous length so we can
               tell whether we should recalculate vectors due to
               preAssignment change (to new one or to none) */
    /* If the MMP has a preassignment attached, it is assumed to be in the
       following format:
         #1(9/10=0%90%) fail:: 123,35,567,79,9AB,B1,2G,6G,AG.{1={0,0,1},
         2={0,1,0},3={1,0,0},5={0,1,-1},6={1,-1,-1},7={2,1,1},9={2,-2,-2},
         A={1,2,-1},G={1,0,1}}
       or
         #1(9/10=0%90%)timeout100:: 123,35,567,79,9AB,B1,2G,6G,AG.{1={0,0,1},

       The start of the MMP is determined by ":: ".  The end of the MMP is
       determined by ".".

    */

    /* Deleted 27-Nov-2017 nm */
    /*
    let(&preAssignment, ""); /@ global variable @/
    i = instr(1, str1, ":: ");
    if (i != 0) {
      j = instr(i, str1, ".");
      let(&preAssignment, seg(str1, j + 2, (long)strlen(str1) - 1));
      let(&str1, seg(str1, i + 3, j));
      if (instr(1, preAssignment, "{") == 0) {
        let(&preAssignment, left(" ", prevLen));  /@ Has no assignments @/
      }
    } else {
      if ((long)strlen(preAssignment) > 1) {
        /@ Nonzero previous length means re-gen vectors because the
           length changed (to zero) @/
        let(&preAssignment, left(" ", prevLen));
      }
    }
    *** end of 27-Nov-2017 deletion */

    /* Clean off carriage return (for Windows files under Cygwin) */
    let(&inputMMP, edit(inputMMP,  4 + 128/*trailing spaces*/));

    lattices++;


    /* 27-Nov-2017 nm */
    /* Get any prefix i.e. part of line before last space and any
       suffix i.e. part of line after "." */
    p = 0;
    while (1) {  /* Find last space */
      q = instr(p + 1, inputMMP, " ");
      if (q == 0) break;
      p = q;
    }
    q = instr(p + 1, inputMMP, "."); /* End of MMP, just before suffix */
    if (q == 0) {
      fprintf(stderr, "?Error: MMP #%ld doesn't end with period.\n", lattices);
    }
    if (p != 0) {
      let(&MMPPrefix, left(inputMMP, p));
    } else {
      let(&MMPPrefix, "");
    }
    let(&MMPSuffix, right(inputMMP, q + 1));
    let(&inputMMP, seg(inputMMP, p + 1, q));

    p = (long)strlen(MMPSuffix);
    if (p != 0) {
      if (MMPSuffix[0] != '{' && MMPSuffix[p - 1] != '}') {
        fprintf(stderr,
  "?Error: MMP %ld suffix isn't surrounded by \"{\" and \"}\".\n", lattices);
        /* Don't use suffix if it has an error */
        let(&preAssignment, "");
      } else {
        /* Strip off surrounding "{" and "}" */
        let(&preAssignment, mid(MMPSuffix, 2, p - 1));
      }
    } else {
      let(&preAssignment, ""); /* No suffix */
    }

    parseAndTestMMPDiagram(inputMMP);
    /*printf("%s\n", str2);*/
    if (printVectorsOnlyMode == 1) break; /* Get vector list from 1st MMP only */
  }

  if (verboseMode == 1 && printVectorsOnlyMode == 0) {
    printf("Total diagrams = %ld  Total backtrack count = %ld",
        lattices, totalBacktrackCount);
#ifdef CLOCKS_PER_SEC
    printf("  CPU time =%6.2f s", ((1.0 * (double)(clock()))/CLOCKS_PER_SEC));
#endif
    printf("\n");
    fflush(stdout);
  }

 return_point:
  /* Deallocate vstring memory */
  let(&str1, "");
  let(&str2, "");
  let(&inputMMP, "");

  return 0;
} /* End of main() */


void parseAndTestMMPDiagram(vstring glattice1) {
  long backtrackCount = 0; /* Returned statistic from findVectorAssignment */
  long highestBacktrack = 0; /* Returned statistic from findVectorAssignment */
  char result; /* Returned value of findVectorAssignment */

  vstring str1 = "";
  long i;

  /*let(&glattice1, glattice);*/
  /*let(&glattice1, edit(glattice, 2));*/ /* Remove spaces */


  if (noMMPMode == 0) {
    if (verboseMode) {
      printf("#%ld %s\n", lattices, glattice1);
      fflush(stdout);
    }
    str1 = parseMMP(glattice1 /* MMP diagram */,
      0 /* 0=don't, 1=do normalize output diagram */);
    let(&str1, ""); /* Deallocate */

    /* 22-Jan-2014 nm */
    if (atoms != maxAtom) {
      fprintf(stderr,
          "?Error: Input MMP #%ld has vertex (atom) numbering gaps.\n",
          lattices);
      fprintf(stderr, "Use \"mmpshuffle -na\" to normalize them.\n");
      /* return; */  /* 8-Oct-2016 nm */
      return; /* 10-Oct-2016 nm Too dangerous to continue without carefully
                  analyzing code behavior */
    }

    /* 22-Jan-2014 nm */
    for (i = 1; i <= blocks; i++) {
      if (dimensions != blockSize[i]) {
        fprintf(stderr, "?Error: Input MMP #");
        fprintf(stderr,
            "%ld edge (block) %ld has %ld vertices (atoms); should have %ld\n",
            lattices, i, blockSize[i], dimensions);
        /* return; */
        if (blockSize[i] > dimensions) return;
        /* 8-Oct-2016 nm */
        /* Tolerate less dimensions for no-kick stripped MMPs */
        fprintf(stderr,
            "Use \"mmpshuffle -fill\" to fill in isolated vertices\n");
        break; /* Only print first error */
      }
    }
  } /* if noMMPMode == 0 */


  result = findVectorAssignment(dimensions, &backtrackCount,
      &highestBacktrack);
  if (noMMPMode == 1) return;

  totalBacktrackCount += backtrackCount;
  if (verboseMode == 0 || printVectorsOnlyMode == 1) {
      /* #16 ((37)) passes:: 8HP,9KP,25A,23L,BCQ,5DN,7CL,9EN,67F,... */
      /*printf("#%ld %s:: %s%s\n", lattices,
          (!result[0]) ? "fails" : "passes", glattice1, result);*/
  } else {
    printf("#%ld Backtrack count = %ld,  deepest = %ld\n",
         lattices, backtrackCount, highestBacktrack);
    if (result) {
      printf("#%ld%s\n", lattices, " Admits a valid vector assignment");
    } else {
      printf(
 "#%ld Admits no valid assignment using the given vectors.\n",
       lattices);
    }
    fflush(stdout);
  }

  /* Deallocate strings */
} /* parseAndTestMMPDiagram */


/* 22-Jan-2014 nm - taken from mmpshuffle.c */
/* Parse an MMP diagram into globals:  blocks, blockSize[], block[][],
   atoms, maxAtom */
/* Depends on globals ATOM_MAP, atomMapLen */
/* Caller must deallocate returned string. */
vstring parseMMP(vstring inputDiagram /* MMP diagram */,
    char normalize /* 0=don't, 1=do normalize output diagram */) {
  long i, j, k, m, n;
  vstring jptr;
  long extendedNotationIncr; /* For + notation */
  long extendedNotationOffset; /* For + notation */
  /*vstring atomRemap = "";*/ /* To fill in atom gaps */
  long atomRemap[MAX_ATOMS + 1]; /* To fill in atom gaps */
  char atomUsed[MAX_ATOMS + 1]; /* To count actual atoms */
  /*vstring inputDiagram = "";*/
  vstring str1 = "";
  vstring outputDiagram = "";

  /* extendedNotationIncr = strlen(ATOM_MAP); */ /* For + notation */
  extendedNotationIncr = atomMapLen; /*  For + notation (faster than strlen) */

  /*let(&inputDiagram, glattice);*/
  /*let(&inputDiagram, edit(glattice, 2));*/ /* Remove spaces */

  n = (long)strlen(inputDiagram);

  if (!noErrorCheck) {
    /* The calling routine should ensure this */
    if (strchr(inputDiagram, ' ') != NULL) bug(2);
/*D*//*printf("%s\n",inputDiagram);*/
/*D*//*printf("n %ld\n",n);        */

    /* inputDiagram can't be a blank line */
    if (inputDiagram[0] == 0) {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr, "?Error: Blank lines are not allowed\n");
      exit(1);
    }

    /* inputDiagram must have ending period for new (Brendan) compact standard */
    if (inputDiagram[n - 1] != '.') {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr, "?Error: Last character should be a period\n");
      exit(1);
    }

    /* if (instr(1, left(inputDiagram, n - 1), ".") != 0) { */
    if (strchr(inputDiagram, '.') != inputDiagram + n - 1) {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr, "?Error: Period can only be last character\n");
      exit(1);
    }
    if (n == 1) {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr, "?Error: Diagram must have at least one block\n");
      exit(1);
    }
  }

  maxAtom = 0;
  blocks = 1;
  blockSize[blocks] = 0;
  extendedNotationOffset = 0; /* For + notation */
  for (i = 0; i < n; i++) {
    if (inputDiagram[i] == ',' || inputDiagram[i] == '.') {
      /* End of block */
      if (blockSize[blocks] < MIN_BLOCK_SIZE) {
        fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
        fprintf(stderr,
            "?Error: Block %ld has %ld atoms, but minimum block size is %ld\n",
             blocks, blockSize[blocks], (long)MIN_BLOCK_SIZE);
        exit(1);
      }
      if (inputDiagram[i] == ',') {
        /* Start of new block */
        blocks++;
        if (blocks > MAX_BLOCKS) {
          fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
          fprintf(stderr,
   "?Error: Maximum blocks allowed is %ld.  Increase MAX_BLOCKS in program.\n",
                (long)MAX_BLOCKS);
          exit(1);
        }
        blockSize[blocks] = 0;
      }
      continue;
    }

    /* TODO: call extendedAtomNumber() instead of this code */
    if (inputDiagram[i] == '+') {
      /* Process the extended notation
         12...9A...Za...`{|}~+1+2...+|+}+~++1...++~+++1....
         From 23-Apr-2009 email to Mladen:
           "If in the far future we get to say 10000 atoms, that would be
           around 100 +'s per atom, obviously extremely inefficient.  But,
           we still have "0" unused, and can have an alternate (and
           compatible) notation where "0" is the start of a decimal number,
           with some non-digit, say ".", terminating it.  I'll leave a
           comment to that effect in the latticeg.c file, for when it
           becomes a problem for a future generation" */
      extendedNotationOffset += extendedNotationIncr;
      continue;
    }

    /* Get the atom number */
    /*j = instr(1, ATOM_MAP, chr(inputDiagram[i]));*/
    /*let(&str1, "");*/ /* Deallocate chr call */
    jptr = strchr(ATOM_MAP, inputDiagram[i]);
    if (jptr == NULL) {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr, "?Error: Illegal character '%c' in diagram\n",
          inputDiagram[i]);
      exit(1);
    }
    j = jptr - ATOM_MAP + 1; /* Atom number */
    j += extendedNotationOffset; /* For + notation */
    extendedNotationOffset = 0; /* For + notation - initialize for next atom */
    blockSize[blocks]++;
    if (blockSize[blocks] > MAX_BLOCK_SIZE) {
      fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
      fprintf(stderr,
           "?Error: Block %ld has %ld atoms, but maximum block size is %ld \n",
           blocks, blockSize[blocks], (long)MAX_BLOCK_SIZE);
      exit(1);
    }
    /* Assign the atom */
    block[blocks][blockSize[blocks]] = j;
    if (j > maxAtom) maxAtom = j; /* Maximum atom number */
  } /* next i */  /* For i = 0 to n(=MMP diagram string length) - 1 */


  if (!noErrorCheck) {
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i] - 1; j++) {
        for (k = j + 1; k <= blockSize[i]; k++) {
          if (block[i][j] == block[i][k]) {
            fprintf(stderr, "#%ld: %s\n", lattices, inputDiagram);
            fprintf(stderr,
  "?Error: Duplicate atoms at positions %ld and %ld in block %ld\n", j, k, i);
            exit(1);
          }
        }
      }
    }
  }

  /* Prevent compiler unused variable warnings due to stripped code below */
  /* let(&atomRemap, ""); */
  let(&str1, "");


  /********* Start of canonical atom renaming section *******/

  /* Count gaps in atom numbering */
  for (i = 1; i <= maxAtom; i++) {
    atomUsed[i] = 0;
  }

  /*let(&atomUsed, string(maxAtom + 1, '0'));*/ /* obsolete */
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      atomUsed[block[i][j]] = 1;
    }
  }
  n = 0; /* Number of gaps in atom numbering */
  for (i = 1; i <= maxAtom; i++) {
    if (atomUsed[i] == 0) n++;
  }
  atoms = maxAtom - n; /* True number of atoms, even if gaps */
  if (normalize) { /* Don't skip renumbering */
    /***/
    /* If there are gaps, remap the atoms to fill in the gaps */
    if (n > 0) {
      /* 25-Sep-2009 This is taken from states.c, where atomRemap is
         wideString */
      /* It must be changed to wideString for > 127 (?) atoms */
      /* if (atoms >= 127) bug(3); */ /* Need to switch to wideString */
      /* 19-Apr-2010 We now use an array from atomRemap so we don't
         need the wideString stuff */
      /* (Here is the intended use of atomRemap[]) */
      /*let(&atomRemap, string(atoms + 1, '?'));*/ /*old*/
      for (i = 1; i <= maxAtom; i++) atomRemap[i] = '?';
      j = 0;
      for (i = 1; i <= maxAtom; i++) {
        if (atomUsed[i] == 1) {
          j++; /* Atom is used */
          atomRemap[i] = j;
        }
      }
      if (maxAtom - j != n) bug(4); /* Sanity check */
      maxAtom = j; /* True number of atoms, with no gaps */
      if (maxAtom != atoms) bug(5);
      for (i = 1; i <= blocks; i++) {
        for (j = 1; j <= blockSize[i]; j++) {
          block[i][j] = atomRemap[block[i][j]];
        }
      }
      /*let(&atomRemap, "");*/ /* Deallocate memory */
    }
    /***/
    /* Renumber the atoms starting at 1 from left to right */
    /* This will make sort | uniq find more duplicates to ignore */
    /* See wideString warning above */
    /*let(&atomRemap, string(atoms + 1, 127));*/
    for (i = 1; i <= maxAtom; i++) atomRemap[i] = -1; /* -1 = "not an atom" */
    k = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        /* if (atomRemap[block[i][j]] == 127) { */
        if (atomRemap[block[i][j]] == -1) {
          k++;
          /* if (k == 127) bug(6); */
          atomRemap[block[i][j]] = k;
        }
        block[i][j] = atomRemap[block[i][j]];
      }
    }
    /* let(&atomRemap, ""); */
    n = 1;  /* Force the diagram to be rewritten below */
  } /* if normalize */
  /********* End of canonical atom renaming section *******/



  if (!normalize) n = 0; /* Skip renumbering below */

  /* This is the global greechie diagram for use wherever
     we want to print it out. */
  /* if (instr(1, inputDiagram, ".") == 0 */
  if (strchr(inputDiagram, '.') == NULL
                          /* No period - assume old standard:  3-atom blocks */
         || n > 0) {
             /* Also, if there are atom numbering gaps, rewrite the diagram. */
    /* First, compute the size of the new diagram */
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > atomMapLen) {
          /* Handle extended notation */
          m++;
          k -= atomMapLen;
        }
        m++;
      }
      m++;
    }
    let(&outputDiagram, space(m)); /* Preallocate string to computed size */
    /* Next, fill in the characters */
    m = 0;
    for (i = 1; i <= blocks; i++) {
      for (j = 1; j <= blockSize[i]; j++) {
        k = block[i][j];
        while (k > atomMapLen) {
          /* Handle extended notation */
          outputDiagram[m] = '+';
          m++;
          k -= atomMapLen;
        }
        outputDiagram[m] = ATOM_MAP[k - 1];
        m++;
      }
      if (i < blocks) {
        outputDiagram[m] = ',';
        m++;
      } else {
        outputDiagram[m] = '.';
        m++;
      }
    }
    if (outputDiagram[m] != 0) bug(7); /* Must be end of string */
  } else {
    /* It is already in the new compact form */
    let(&outputDiagram, inputDiagram);
  }

  /* Deallocate strings */
  let(&str1, "");
  /*let(&inputDiagram, "");*/

  /* The caller must deallocate outputDiagram */
  return outputDiagram;
} /* parseMMP */


/* 22-Jan-2014 nm - taken from mmpshuffle.c */
/* Build an MMP diagram from input:  blocks, blockSize[], block[][],
   ATOM_MAP, and atomMapLen */
/* User must deallocate returned string */
vstring buildMMP(long blocks_, long *blockSize_,
    long (*block_)[MAX_BLOCK_SIZE + 1], char *aTOM_MAP,
    long atomMapLen_) {
  long m, b, ba, a, extendedNotationIncr;
  vstring newMMP = "";
  /* extendedNotationIncr = strlen(aTOM_MAP); */ /* For + notation */
  extendedNotationIncr = atomMapLen_; /*  For + notation (faster than strlen) */
  /* First, we compute the size of the new MMP diagram */
  m = 0; /* Pointer to MMP diagram character */
  for (b = 1; b <= blocks_; b++) {
    for (ba = 1; ba <= blockSize_[b]; ba++) {
      a = block_[b][ba]; /* Atom in block */
      while (a > extendedNotationIncr) {
        /* Handle extended notation */
        m++;
        a -= extendedNotationIncr;
      }
      m++;
    }
    m++;
  }
  let(&newMMP, space(m)); /* Preallocate string to computed size */
  /* Next, fill in the characters */
  m = 0;  /* Pointer to MMP diagram character */
  for (b = 1; b <= blocks_; b++) {
    for (ba = 1; ba <= blockSize_[b]; ba++) {
      a = block_[b][ba]; /* Atom */
      while (a > extendedNotationIncr) {
        /* Handle extended notation */
        if (newMMP[m] != ' ') bug(8);
        newMMP[m] = '+';
        m++;
        a -= extendedNotationIncr;
      }
      if (newMMP[m] != ' ') bug(9);
      newMMP[m] = aTOM_MAP[a - 1];
      m++;
    }
    if (newMMP[m] != ' ') bug(10);
    newMMP[m] = ',';
    m++;
  }
  if (newMMP[m] != 0) bug(11); /* Should be end of string */
  if (m == 0) bug(12);
  if (newMMP[m - 1] != ',') bug(13);
  newMMP[m - 1] = '.';
     /* This global is updated for possible later use so we don't have to
        call parseMMP again, but the other block_[] structure entries
        are NOT valid! */
  return newMMP; /* Caller must deallocate */
} /* buildMMP */


/* 22-Jan-2014 nm - taken from states01.c */
/* Get the extended notation name of a single atom */
/* The user must deallocate the output string */
/* This function is inefficient but is not expected to be used often;
   if it is, it can be rewritten to implement the buildMMP algorithm
   directly. */
vstring extendedAtomName(long atom) {
  long block_[2][MAX_BLOCK_SIZE + 1];
  long blockSize_[2];
  long blocks_ = 1;
  vstring newMMP = "";
  blockSize_[1] = 1;
  block_[1][1] = atom;
  /* Build the new MMP diagram */
  /* New 25-Dec-2013 */
  let(&newMMP, "");
  newMMP = buildMMP(blocks_, blockSize_, block_, ATOM_MAP, atomMapLen);
  let(&newMMP, left(newMMP, (long)strlen(newMMP) - 1)); /* Remove period */
  return newMMP;
} /* extendedAtomName */


/* Returns atom number corresponding to string such as "A", "++3", etc. */
long extendedAtomNumber(vstring atomStr)
{
  long extendedNotationOffset = 0; /* For + notation */
  long extendedNotationIncr; /* For + notation */
  long j = 0;
  long i, slen;
  vstring jptr; /* Use as pointer only */

  /* extendedNotationIncr = strlen(ATOM_MAP); */ /* For + notation */
  extendedNotationIncr = atomMapLen; /* Use global var (faster than strlen) */
  slen = (long)strlen(atomStr);
  for (i = 0; i < slen; i++) {
    if (atomStr[i] == '+') {
      /* Process the extended notation
         12...9A...Za...`{|}~+1+2...+|+}+~++1...++~+++1....
         From 23-Apr-2009 email to Mladen:
           "If in the far future we get to say 10000 atoms, that would be
           around 100 +'s per atom, obviously extremely inefficient.  But,
           we still have "0" unused, and can have an alternate (and
           compatible) notation where "0" is the start of a decimal number,
           with some non-digit, say ".", terminating it.  I'll leave a
           comment to that effect in the latticeg.c file, for when it
           becomes a problem for a future generation" */
      extendedNotationOffset += extendedNotationIncr;
      continue;
    }

    if (i < slen - 1) {
      fprintf(stderr,
          "#%ld: ?Error: vertex \"%s\" isn't in the form [+...+]<char>\n",
          lattices, atomStr);
      exit(1);
    }

    /* Get the atom number */
    /*j = instr(1, ATOM_MAP, chr(atomStr[i]));*/
    /*let(&str1, "");*/ /* Deallocate chr call */
    jptr = strchr(ATOM_MAP, atomStr[i]);
    if (jptr == NULL) {
      fprintf(stderr, "#%ld: %s\n", lattices, atomStr);
      fprintf(stderr, "?Error: Illegal character '%c' in diagram\n",
          atomStr[i]);
      exit(1);
    }
    j = jptr - ATOM_MAP + 1; /* Atom number */
    j += extendedNotationOffset; /* For + notation */
  } /* next i */
  return j;
} /* extendedAtomNumber */


/* Returns 1 if vector assignment found or 0 otherwise. */
char findVectorAssignment(long dims/* 3 or 4 or 6 */, long *backtrackCount,
    long *highestBacktrack)
{
  /* Note: almost all arrays start at 1, not 0, since I tend to make
     fewer "off by one" errors this way, at the expense of a small amount
     of additional memory. */
  /* Global variables from above for reference:
     long block[MAX_BLOCKS + 1][MAX_BLOCK_SIZE + 1];
     long blockSize[MAX_BLOCKS + 1];
     long blocks;
     long atoms;
     long totalBacktrackCount = 0; For user information
  */
  /* Static structures that are built once */
  static char firstTime = 1;
  static char hasPreassignment;
  static char hasPreassignmentOld = 0; /* Previous MMP had assignment */
  static long vectors = 0;
  static long vectorsOld = 0; /* Vectors used by previous MMP */
  /* static long vecCoeff[MAX_VECTORS + 1][MAX_DIMS + 1]; */ /*old*/
  /* http://en.cppreference.com/w/c/numeric/complex */
  /* 11-Jan-2017 nm: sizeof(long double complex) = 32 */
  static long double complex cVecCoeff[MAX_VECTORS + 1][MAX_DIMS + 1];
  /* Exact values in the form of strings, such as "1+2sqr3i" */
  static vstring sVecCoeff[MAX_VECTORS + 1][MAX_DIMS + 1];
  /* Storing complex product overflows compiler with 10000 vectors.
     instead, use vecProdNonzero[][]. */
  /*static long double complex  cVecProd[MAX_VECTORS + 1][MAX_VECTORS + 1];*/
  /* 28-Dec-2016 nm Changed to dynamic allocation below */
  /* static char vecProdNonzero[MAX_VECTORS + 1][MAX_VECTORS + 1]; */
  static char vecHasOrth[MAX_VECTORS + 1]; /* 16-Nov-2017 nm */

  static char **vecProdNonzero = NULL;
  static long unlabeledVectors;
  /*
  struct complex_number {
    long double re;
    long double im;
  };
  static struct complex_number vecCoeff[MAX_VECTORS + 1][MAX_DIMS + 1];
  */

  vstring sFrozenAtom = "";
  long frozenVec[MAX_ATOMS + 1]; /* nonzero if a fixed preassignment */
  /* long frozenAtom[MAX_VECTORS + 1]; */ /* nonzero if a fixed preassignment */
  long numFrozenAtoms = 0;
  long numPreassignedAtoms = 0;
  /* long numKickedAtoms = 0; */
  /* long numUnassignableAtoms = 0; */

  /* 11-Jan-2017 nm Make it "static" because it is initialized only when
     firstTime is 1 */
  static long zeroVec = 0; /* Location of the special zero vector
      (assigned when firstTime is 1; initialized to prevent compiler warning) */

  vstring sVec = "";
  long double complex cVecProduct;
  long double complex c; long cint; /* To compare to integer */
  long double complex sqrt2;
  long double minNZProd = 1e15;
  long double maxZProd = -1;
  long minNZVec1 = 0, minNZVec2 = 0, maxZVec1 = 0, maxZVec2 = 0;
  long dupCount, localVecs;

  long i, j, jloop, joffset, k, l, l1, l2, l3, l4, l5, l6, p, q, n, neiAt;
  /* 3-Dec-2016 nm Added up to 32 dims */
  long l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20;
  long l21, l22, l23, l24, l25, l26, l27, l28, l29, l30, l31, l32;
  char skip;
  /* 5-Dec-2016 nm Zero vector detected */
  char zFlag;
  /* Structures that are built for each diagram */
  long atomBlocks[MAX_ATOMS + 1]; /* # blocks atom occurs in */
  long goodAtoms;
  long numRetries;
  long atomNeighbors[MAX_ATOMS + 1];
  static long atomNeighbor[MAX_ATOMS + 1][MAX_ATOMS + 1];
  char vecUsed[MAX_VECTORS + 1]; /* 1 if vector is assigned */
  long availableVecs; /* Counts not used */
  long atomVec[MAX_ATOMS + 1]; /* Vector assigned to atom */
  long saveAtomVec[MAX_ATOMS + 1]; /* 29-Aug-2016 nm */
  long saveUnassignableAtom;

  long atomMap[MAX_ATOMS + 1];
  long atomReverseMap[MAX_ATOMS + 1];
  long mappedAtom /*, mappedNeighborAtom */;

  /* Structures for "clustering" algorithm */
  /* "Common" means in common with list of mapped atoms up to that point */
  long /*highestNeighborCount,*/ highestNeighborWeight, atomWithHighestWeight;
  long neighborWeight;

  /* Variables for main backtracking scan */
  /* 17-Jun-2016 nm No longer used: */
  char orthFlag = 0;
  long orthBasisVecs = 1;  /* 1...dims */
  long previous2ndVec; /* Stores 2nd dimension vector we are at */
  long orthBasis[MAX_DIMS + 1]; /* Accumulates a found orthogonal basis */

  /* Variables for main backtracking scan */
  /* 17-Jun-2016 nm No longer used: */
  /* long atomLowerNeighbors[MAX_ATOMS + 1]; */
  /* static long atomLowerNeighbor[MAX_ATOMS + 1][MAX_ATOMS + 1]; */
  char successFlag = 0;
  char realSuccessFlag = 0;
  char foundFlag;
  char conflict;
  /*char weAreBacktracking;*/

  long curVec, firstVec, leastFreeFirstVec, atomSeq, firstAt, lastAt;
  long freeVecs[MAX_ATOMS + 1];  /* For statistics purposes only */

  /* Local backtrack variables w/out indirection */
  long backtrackCountx = 0;
  long globalBacktrackCountx = 0; /* For all retries together */
  long highestBacktrackx = 0;
  long localHighestBacktrackx = 0;

  vstring extAtomName = "";
  vstring str1 = "";
  vstring str2 = "";
  vstring str3 = "";
  vstring str4 = "";
  vstring str5 = "";
  vstring str6 = "";
  vstring str7 = "";
  vstring str8 = "";
  vstring str9 = "";
  vstring str10 = "";
  long firstItemPrinted; /* To adjust printout */ /* 29-Aug-2016 nm */

  /*long m;*/

  /* 17-Jun-2016 nm */
  /* For dynamic atom assignment order */
  long at, vec;
  long freeVecCount, leastFreeVecCount, leastFreeAtom;
  long highestNeighborCount;
  long dynAtomMap[MAX_ATOMS + 1]; /* Remapping of atom scan order */
  long dynAtomRevMap[MAX_ATOMS + 1]; /* Reverse of atom scan order */

  hasPreassignment = (preAssignment[0] != 0) ? 1 : 0;

  /* Build static structures the first time this is called */
  /* The code in this section doesn't have to be as efficient since it is
     done only once */
  if (firstTime == 1
/*D*//*|| firstTime == 0*/  /* Always do it for now due to bug 51 - 11-Jan-2017 nm */
/*D*/ /* Without this, the 2nd diagram gives bug 51:
Zaw,Xbv,RXc,NYr,LPq,JVb,Ibm,IMl,Hak,FKy,FHM,Dc!,CMe,CDO,BSb,BGf,BDZ,AQa,9Ra,9Gg,9CT,8Nh,8AS,7QW,7Ld,6Pc,6FV,6EU,5Os,5Ez,4Jo,4Hj,48c,457,3Px,3GY,3Ai,35I,2Wu,2Tb,2Kp,2EN,1Ua,1Ot,1KL,1Jn.
Zco,Zab,Xdn,Wam,VXt,QYj,PZw,PQi,Odx,KPR,FYh,FHT,FGX,EWy,ENO,EIP,DOe,DHR,CFz,BU!,BEV,ARf,AGS,9Vu,9LR,8cd,8Sk,89C,7FM,7Eg,6bq,6TU,6IJ,5as,5JM,4Tv,4SW,3bp,3OY,34K,2Ul,2QS,27L,1cr,1NT,15Q.
      */
      || hasPreassignment
      || hasPreassignmentOld /* Regen if we're using a pre-assigned list
                                  or if previous MMP used one */
      ) {
    vectors = 0;

    if (firstTime == 1) {
      /* Initialize string array */
      for (i = 0; i <= MAX_VECTORS; i++)
        for (j = 0; j <= MAX_DIMS; j++)
          sVecCoeff[i][j] = "";
      firstTime = 0;
    }

    /* Initialize fixed preassignments */
    for (i = 0; i <= MAX_ATOMS; i++) {
      frozenVec[i] = 0; /* Atom to vector in MMP preassignment */
      /* frozenAtom[i] = 0; */ /* Vector to atom in MMP preassignment */
      /* frozenAtom[i] = 0; */ /* Vector to atom in MMP preassignment */
    }


    /* Add in non-duplicate vectors from the input MMP */
    /* Note that preAssignment = " " (space) means there is no preassignment,
       but we're rebuilding the vectors to refresh from a preassignment
       for the previous MMP */
    if (strlen(preAssignment) > 1) {
      localVecs = 0;
      dupCount = 0;
      p = 0;  q = 0;
      while (1) {
        /* p = instr(p + 1, preAssignment, "{"); */
        /* Ensure correct match when atom is "{" */
        p = instr(p + 1, preAssignment, "={"); /* 24-Mar-2018 */
        if (p == 0) break;
        p++; /* 24-Mar-2018 nm */

        /* Get the atom (vertex) the vector is assigned to */
        if (vectors == 0) {
          /* Get atom name prefix in front of the vector */
          /* The "A=" in "A={0,0,1},++2={0,1,0}..." */
          let(&sFrozenAtom, seg(preAssignment, 1, p - 1));
        } else {
          /* Get atom name prefix in front of the vector */
          /* The ",++2=" in "1={0,0,1},++2={0,1,0}..." */
          let(&sFrozenAtom, seg(preAssignment, q + 1, p - 1));
          if (sFrozenAtom[0] != 0) {
              /* If it is a "pass", there is no assignment (and no comma) */

              /* 13-Jan-2017 nm This is obsolete since we are now using
                 explicit assignments always */

            if (sFrozenAtom[0] != ',') {
              fprintf(stderr,
                  "#%ld ?Error: Expected ',' at position %ld in %s\n",
                  lattices, q + 1, preAssignment);
              /* Don't try to recover if pre-assignment corrupted */
              exit(1);
            }
          }
          /* Strip comma */
          if (sFrozenAtom[0] == ',' && strlen(sFrozenAtom) > 2) {
            let(&sFrozenAtom, right(sFrozenAtom, 2));
          }
        } /* if (vectors == 0) else */

        q = instr(p + 1, preAssignment, "}");
        if (q == 0) break;
        let(&sVec, seg(preAssignment, p + 1, q - 1));
        n = numEntries(sVec);
        if (n != dims) {
          fprintf(stderr,
         "#%ld ?Error: Vector %s in MMP has %ld dimensions, should have %ld\n",
              lattices, sVec, n, dims);
        }
        vectors++;
        /* if (vectors > MAX_VECTORS) { */
        /* 10-Oct-2016 nm Allow for appending the zero vector */
        if (vectors > MAX_VECTORS - 1) {
          fprintf(stderr, "?Error: Exceeded MAX_VECTORS = %ld vectors.\n",
              (long)MAX_VECTORS);
          exit(1);
        }

        for (j = 1; j <= n; j++) {
          let(&str1, entry(j, sVec));
          if (str1[0] == 0) {
            fprintf(stderr,
            "#%ld ?Error: MMP pre-assignment has empty vector components: %s\n",
                lattices, sVec);
          }
          let(&(sVecCoeff[vectors][j]), str1);
          cVecCoeff[vectors][j] = stringToComplex(str1);
        }

        if (sFrozenAtom[0] != 0) { /* There is a preassigned atom */

          i = (long)strlen(sFrozenAtom);
          if (sFrozenAtom[i - 1] != '=') {
            fprintf(stderr, "#%ld ?Error: Expected '=' at position %ld in %s\n",
                lattices, q + i, preAssignment);
            /* Don't try to recover if pre-assignment corrupted */
            exit(1);
          }
          /* Strip off '=' */
          let(&sFrozenAtom, left(sFrozenAtom, i - 1));
          if (sFrozenAtom[0] == 0) {
            fprintf(stderr,
                "#%ld ?Error: Vertex name too short at position %ld in %s\n",
                lattices, p - 2, preAssignment);
            exit(1);
          }
          if (sFrozenAtom[i - 2] == '.') {
            /* If atom name is '.', assume we changed it from "{" to prevent
               parsing ambiguity */
            sFrozenAtom[i - 2] = '{';
          }

          /* Look up the atom number corresponding to the sFrozenAtom */
          at = extendedAtomNumber(sFrozenAtom);
          if (at > maxAtom) {
            fprintf(stderr,
                "#%ld ?Error: Preassigned vertex \"%s\" is not in the MMP.\n",
                lattices, sFrozenAtom);
            exit(1);
          }
          if (at == 0) {
            fprintf(stderr, "#%ld ?Error: Bad preassigned vertex name \"%s\"\n",
                lattices, sFrozenAtom);
            exit(1);
          }
          /* Preassign a fixed vector to vertex if a vertex name is specified */
          frozenVec[at] = vectors;
          /* frozenAtom[vectors] = at; */
          numFrozenAtoms++;
        } /* if (sFrozenAtom[0] != 0) */

        numPreassignedAtoms = numFrozenAtoms;

        /* 10-Jan-2017 nm */
        /* Standardize the vector by dividing all components by the
           first non-zero (abs. val. > maxError) component */
        vecStandardize(cVecCoeff[vectors], dims, maxError);


        if (dontRemoveDupVecs == 0) {
          /* Flag duplicate (proportional) vectors */
          for (i = 1; i <= vectors - 1; i ++) {
            /*
            if (vecProportional(cVecCoeff[i], cVecCoeff[vectors],
                dims, maxError) == 1) {
            */
            /* 10-Jan-2017 nm */
            if (vecEqual(cVecCoeff[i], cVecCoeff[vectors],
                dims, maxError) == 1) {

              /* For pre-assignments, there should be no dups */
              fprintf(stderr,
                  "#%ld ?Warning: MMP pre-assignment has proportional vectors ",
                  lattices);
              for (j = 1; j <= dims; j++) {
                fprintf(stderr, "%s%s", sVecCoeff[i][j],
                    ((j < dims) ? "," : ""));
              }
              fprintf(stderr, " and ");
              for (j = 1; j <= dims; j++) {
                fprintf(stderr, "%s%s", sVecCoeff[vectors][j],
                    ((j < dims) ? "," : ""));
              }
              fprintf(stderr, "\n");
              /* vectors--; */ /* Leave duplicate in, since it is preassigned */
              break;
            }
          } /* next i */
        } /* if (dontRemoveDupVecs == 0) */
      } /* while(1) */
      if (verboseMode) {
        printf(
            "#%ld Added %ld vectors from MMP, %ld pre-assigned, %ld total\n",
            lattices, vectors, numFrozenAtoms, vectors);
        fflush(stdout);
      }
    } /* If MMP has vector pre-assignment */

    /* Read vectors from -vfile option file(s) */
    if (vectorFileList[0] != 0) {
      localVecs = 0;
      dupCount = 0;
      k = numEntries(vectorFileList);
      for (l = 1; l <= k; l++) {
        dupCount = 0;
        localVecs = 0;
        let(&str1, "");
        str1 = readFileToString(entry(l, vectorFileList), 1);
        if (str1 == NULL) {
          /* There was an error; message was printed by readFileToString() */
          str1 = "";
          /*continue;*/
          exit(1);
        }
        let(&str1, edit(str1, 1/*parity*/ + 2/*spaces*/ + 4/*linefeed etc.*/));
        p = 0;
        while (1) {
          p = instr(p + 1, str1, "{");
          if (p == 0) break;
          q = instr(p + 1, str1, "}");
          if (q == 0) break;
          let(&sVec, seg(str1, p + 1, q - 1));
          n = numEntries(sVec);
          if (n != dims) {
            fprintf(stderr,
             "#%ld ?Error: Vector {%s} in %s is %ld-dimensional, should be %ld\n",
                lattices, sVec, entry(l, vectorFileList), n, dims);
            if (n > MAX_DIMS) exit(1);
          }
          vectors++;
          localVecs++;
          /* if (vectors > MAX_VECTORS) { */
          /* 10-Oct-2016 nm Allow for appending the zero vector */
          if (vectors > MAX_VECTORS - 1) {
            fprintf(stderr, "#%ld ?Error: Exceeded MAX_VECTORS = %ld vectors\n.",
                lattices, (long)MAX_VECTORS);
            exit(1);
          }
          for (j = 1; j <= n; j++) {
            let(&str2, entry(j, sVec));
            if (str2[0] == 0) {
              fprintf(stderr,
                  "#%ld ?Error: Vector in %s has empty components: {%s}\n",
                  lattices, entry(l, vectorFileList), sVec);
            }
            let(&(sVecCoeff[vectors][j]), str2);
            cVecCoeff[vectors][j] = stringToComplex(str2);
          }

          /* 10-Jan-2017 nm */
          /* Standardize the vector by dividing all components by the
             first non-zero (abs. val. > maxError) component */
          vecStandardize(cVecCoeff[vectors], dims, maxError);

          /* Ignore duplicate (proportional) vectors */
          if (dontRemoveDupVecs == 0) {
            /* dontRemoveDupVecs allows old vectorfind.c to be emulated for
               debugging */
            for (i = 1; i <= vectors - 1; i ++) {
              /*
              if (vecProportional(cVecCoeff[i], cVecCoeff[vectors],
                  dims, maxError) == 1) {
              */
              if (vecEqual(cVecCoeff[i], cVecCoeff[vectors],
                  dims, maxError) == 1) {

                /* 17-Nov-2017 nm */
                /* Cosmetic improvement */
                /* If the new vector string has a lower "weight", assign
                   it to the old vector string */
                if (vecStringWeight(i, sVecCoeff, dims)
                    > vecStringWeight(vectors, sVecCoeff, dims)) {
                  for (j = 1; j <= dims; j++) {
                    /* Swap to simplest overall string coefficient */
                    let(&(sVecCoeff[i][j]), sVecCoeff[vectors][j]);
                  }
                }

                vectors--;
                dupCount++;
                break;
              }
            }
          }
        } /* while(1) */

        if (verboseMode) {
          printf(
             "#%ld Added %ld vectors from %s, ignored %ld duplicates, %ld total\n",
              lattices,
              localVecs - dupCount, entry(l, vectorFileList), dupCount, vectors);
          fflush(stdout);
        }

      } /* next k (file) */
    } /* if (vectorFileList[0] != 0) */



    /* Generate vectors from -vgen option list */
    if (vectorGenList[0] != 0) {
      localVecs = 0;
      dupCount = 0;

      /* 5-Dec-2016 nm Removed automatic 0 and negative */
      /*
      /@ Add negatives of components @/
      k = numEntries(vectorGenList);
      let(&str1, "");
      for (i = 1; i <= k; i++) {
        let(&str2, entry(i, vectorGenList));
        if (strchr(str2, '-') == NULL && strchr(str2, '+') == NULL) {
          let(&str1, cat(str1, ",-", str2, NULL));
        } else {
          /@ Use parentheses if vector component has - or + @/
          let(&str1, cat(str1, ",-(", str2, ")", NULL));
        }
      }
      let(&str1, cat(vectorGenList, str1, NULL));
      /@ Add 1 component if it is not there @/
      /@
      if (lookup("1", vectorGenList) == 0) {
        let(&str1, cat("1,-1,", str1, NULL));
      }
      @/
      if (lookup("0", vectorGenList) == 0) {
        /@ Add 0 component if it is not there @/
        let(&str1, cat("0,", str1, NULL));
      } else {
        fprintf(stderr, "#%ld ?Error: Component list %s should not include 0.\n",
            lattices, vectorGenList);
        exit(1); /@ It must be in position 1 below, so abort here @/
      }
      */

      /* 5-Dec-2016 nm Assign the commented-out str1 above */
      let(&str1, vectorGenList);

      /* 5-Dec-2016 nm Error check */
      if (strchr(str1, '{') != NULL || strchr(str1, '}') != NULL) {
        fprintf(stderr, "?Error: Braces are not allowed in the -vgen list.\n");
        exit(1);
      }

      /*
      if (verboseMode) {
        printf("Generating vectors with components \"%s\"...\n",
            vectorGenList);
        fflush(stdout);
      }
      */
      k = numEntries(str1);
      for (l1 = 1; l1 <= k; l1++) {
        for (l2 = 1; l2 <= k; l2++) {
          for (l3 = 1; l3 <= k; l3++) {
            for (l4 = 1; l4 <= ((dims < 4) ? 1 : k); l4++) {
              for (l5 = 1; l5 <= ((dims < 5) ? 1 : k); l5++) {
                for (l6 = 1; l6 <= ((dims < 6) ? 1 : k); l6++) {

                /* 3-Dec-2016 nm */
                for (l7 = 1; l7 <= ((dims < 7) ? 1 : k); l7++) {
                for (l8 = 1; l8 <= ((dims < 8) ? 1 : k); l8++) {
                for (l9 = 1; l9 <= ((dims < 9) ? 1 : k); l9++) {
                for (l10 = 1; l10 <= ((dims < 10) ? 1 : k); l10++) {
                for (l11 = 1; l11 <= ((dims < 11) ? 1 : k); l11++) {
                for (l12 = 1; l12 <= ((dims < 12) ? 1 : k); l12++) {
                for (l13 = 1; l13 <= ((dims < 13) ? 1 : k); l13++) {
                for (l14 = 1; l14 <= ((dims < 14) ? 1 : k); l14++) {
                for (l15 = 1; l15 <= ((dims < 15) ? 1 : k); l15++) {
                for (l16 = 1; l16 <= ((dims < 16) ? 1 : k); l16++) {
                for (l17 = 1; l17 <= ((dims < 17) ? 1 : k); l17++) {
                for (l18 = 1; l18 <= ((dims < 18) ? 1 : k); l18++) {
                for (l19 = 1; l19 <= ((dims < 19) ? 1 : k); l19++) {
                for (l20 = 1; l20 <= ((dims < 20) ? 1 : k); l20++) {
                for (l21 = 1; l21 <= ((dims < 21) ? 1 : k); l21++) {
                for (l22 = 1; l22 <= ((dims < 22) ? 1 : k); l22++) {
                for (l23 = 1; l23 <= ((dims < 23) ? 1 : k); l23++) {
                for (l24 = 1; l24 <= ((dims < 24) ? 1 : k); l24++) {
                for (l25 = 1; l25 <= ((dims < 25) ? 1 : k); l25++) {
                for (l26 = 1; l26 <= ((dims < 26) ? 1 : k); l26++) {
                for (l27 = 1; l27 <= ((dims < 27) ? 1 : k); l27++) {
                for (l28 = 1; l28 <= ((dims < 28) ? 1 : k); l28++) {
                for (l29 = 1; l29 <= ((dims < 29) ? 1 : k); l29++) {
                for (l30 = 1; l30 <= ((dims < 30) ? 1 : k); l30++) {
                for (l31 = 1; l31 <= ((dims < 31) ? 1 : k); l31++) {
                for (l32 = 1; l32 <= ((dims < 32) ? 1 : k); l32++) {

                  /* 5-Dec-2016 nm Zero detection is now done later */
                  /*
                  if (l1 == 1 && l2 == 1  && l3 == 1 && l4 == 1
                      && l5 == 1 && l6 == 1

                      /@ 3-Dec-2016 nm @/
                      && l7 == 1 && l8 == 1 && l9 == 1
                      && l10 == 1 && l11 == 1 && l12 == 1 && l13 == 1
                      && l14 == 1 && l15 == 1 && l16 == 1 && l17 == 1
                      && l18 == 1 && l19 == 1
                      && l20 == 1 && l21 == 1 && l22 == 1 && l23 == 1
                      && l24 == 1 && l25 == 1 && l26 == 1 && l27 == 1
                      && l28 == 1 && l29 == 1
                      && l30 == 1 && l31 == 1 && l32 == 1

                      ) {
                    /@ Ignore the 0 vector @/
                    continue;
                  }
                  */

                  vectors++;
                  localVecs++;
                  /* if (vectors > MAX_VECTORS) { */
                  /* 10-Oct-2016 nm Allow for appending the zero vector */
                  if (vectors > MAX_VECTORS - 1) {
                    fprintf(stderr,
                        "#%ld ?Error: Exceeded MAX_VECTORS = %ld vectors\n.",
                        lattices, (long)MAX_VECTORS);
                    exit(1);
                  }
                  /* Assign components (unused dimensions are assigned 0) */
                  let(&(sVecCoeff[vectors][1]), entry(l1, str1));
                  let(&(sVecCoeff[vectors][2]), entry(l2, str1));
                  let(&(sVecCoeff[vectors][3]), entry(l3, str1));
                  let(&(sVecCoeff[vectors][4]), entry(l4, str1));
                  let(&(sVecCoeff[vectors][5]), entry(l5, str1));
                  let(&(sVecCoeff[vectors][6]), entry(l6, str1));

                  /* 3-Dec-2016 nm */
                  let(&(sVecCoeff[vectors][7]), entry(l7, str1));
                  let(&(sVecCoeff[vectors][8]), entry(l8, str1));
                  let(&(sVecCoeff[vectors][9]), entry(l9, str1));
                  let(&(sVecCoeff[vectors][10]), entry(l10, str1));
                  let(&(sVecCoeff[vectors][11]), entry(l11, str1));
                  let(&(sVecCoeff[vectors][12]), entry(l12, str1));
                  let(&(sVecCoeff[vectors][13]), entry(l13, str1));
                  let(&(sVecCoeff[vectors][14]), entry(l14, str1));
                  let(&(sVecCoeff[vectors][15]), entry(l15, str1));
                  let(&(sVecCoeff[vectors][16]), entry(l16, str1));
                  let(&(sVecCoeff[vectors][17]), entry(l17, str1));
                  let(&(sVecCoeff[vectors][18]), entry(l18, str1));
                  let(&(sVecCoeff[vectors][19]), entry(l19, str1));
                  let(&(sVecCoeff[vectors][20]), entry(l20, str1));
                  let(&(sVecCoeff[vectors][21]), entry(l21, str1));
                  let(&(sVecCoeff[vectors][22]), entry(l22, str1));
                  let(&(sVecCoeff[vectors][23]), entry(l23, str1));
                  let(&(sVecCoeff[vectors][24]), entry(l24, str1));
                  let(&(sVecCoeff[vectors][25]), entry(l25, str1));
                  let(&(sVecCoeff[vectors][26]), entry(l26, str1));
                  let(&(sVecCoeff[vectors][27]), entry(l27, str1));
                  let(&(sVecCoeff[vectors][28]), entry(l28, str1));
                  let(&(sVecCoeff[vectors][29]), entry(l29, str1));
                  let(&(sVecCoeff[vectors][30]), entry(l30, str1));
                  let(&(sVecCoeff[vectors][31]), entry(l31, str1));
                  let(&(sVecCoeff[vectors][32]), entry(l32, str1));

                  for (i = 1; i <= MAX_DIMS; i++) {
                    /* Convert string expressions to numeric values */
                    cVecCoeff[vectors][i]
                        = stringToComplex(sVecCoeff[vectors][i]);
                  }

                  /* 5-Dec-2016 nm Ignore the zero vector */
                  zFlag = 1;
                  for (i = 1; i <= dims; i++) {
                    if (cabsl(cVecCoeff[vectors][i]) > maxError) {
                      zFlag = 0; /* A nonzero component was found */
                      break;
                    }
                  }
                  if (zFlag == 1) {
                    vectors--; /* Ignore the zero vector */
                    localVecs--;
                    continue;
                  }

                  /* 10-Jan-2017 nm */
                  /* Standardize the vector by dividing all components by the
                     first non-zero (abs. val. > maxError) component */
                  vecStandardize(cVecCoeff[vectors], dims, maxError);

                  /* Ignore duplicate (proportional) vectors */
                  for (i = 1; i <= vectors - 1; i ++) {
                    /*
                    if (vecProportional(cVecCoeff[i], cVecCoeff[vectors],
                        dims, maxError) == 1) {
                    */
                    /* 10-Jan-2017 nm */
                    if (vecEqual(cVecCoeff[i], cVecCoeff[vectors],
                        dims, maxError) == 1) {
/*D*/
/*
printf("old=%ld %s new=%ld %s\n",vecStringWeight(i, sVecCoeff, dims),
cat(sVecCoeff[i][1],sVecCoeff[i][2],sVecCoeff[i][3],NULL),
vecStringWeight(vectors, sVecCoeff, dims),
cat(sVecCoeff[vectors][1],sVecCoeff[vectors][2],sVecCoeff[vectors][3],NULL));
*/
/*D*/

                      /* 16-Nov-2017 nm */
                      /* Cosmetic improvement: */
                      /* Decide whether the new proportional vector has a
                         better name such as (1,1,1) instead of (3,3,3); if
                         so, use it instead of the old vector's name */
                      if (vecStringWeight(i, sVecCoeff, dims)
                          > vecStringWeight(vectors, sVecCoeff, dims)) {
                        for (j = 1; j <= dims; j++) {
                          /* Swap to simplest overall string coefficient */
                          let(&(sVecCoeff[i][j]), sVecCoeff[vectors][j]);
                        }
                      }
                      vectors--;
                      dupCount++;
                      break;
                    }
                  }

                  /* 3-Dec-2016 nm */
                  /* next l32, l31,..., l7 */
                  } } } } } } } } } } } } } } } } } } } } } } } } } }

                } /* next l6 */
              } /* next l5 */
            } /* next l4 */
          } /* next l3 */
        } /* next l2 */
      } /* next l1 */

      if (verboseMode) {
        printf(
      "#%ld Added %ld vectors from \"%s\", ignored %ld duplicates, %ld total\n",
          lattices, localVecs/* - dupCount*/, vectorGenList, dupCount, vectors);
        fflush(stdout);
      }

    } /* if (vectorGenList[0] != 0) */


    /* 16-Nov-2017 nm */
    /********* Strip off vectors that are not orthogonal to any other ******/
    if (discardNonOrth == 1) {
      for (i = 1; i <= vectors; i++) {
        vecHasOrth[i] = 0;
      }
  /*D*/l1=0;l2=0;
      for (i = 1; i <= vectors - 1; i++) {
        for (j = i + 1; j <= vectors; j++) {
          if (vecHasOrth[i] == 1 && vecHasOrth[j] == 1) {
            /* No need to check again */
  /*D*/l2++;
            continue;
          }
  /*D*/l1++;
          if (innerProductNonzero(cVecCoeff[i], cVecCoeff[j],
              dims, maxError) == 0) {
            /* i and j are orthogonal */
            vecHasOrth[i] = 1;
            vecHasOrth[j] = 1;
  /*D*/
  /*
  printf("i=%ld j=%ld ",i,j);
  for (k = 1; k <= dims; k++) {
    printf( "%s%s", sVecCoeff[i][k],
        ((k < dims) ? "," : ""));
  }
  printf(" and ");
  for (k = 1; k <= dims; k++) {
    printf( "%s%s", sVecCoeff[j][k],
        ((k < dims) ? "," : ""));
  }
  printf("\n");
  */
  /*D*/
          }
        }
      }
  /*D*//*printf("l1=%ld l2=%ld l1+l2=%ld\n",l1,l2,l1+l2);*/
      /* Now remove vectors with no orthogonal mate from the vector array */
      localVecs = vectors;
      for (i = numFrozenAtoms + 1; i <= vectors; i++) {
                   /* Skip the numFrozenVecs vectors at the beginning */
        if (vecHasOrth[i] == 1) {
          continue;
        }
        /* Discard this vector by transferring the last vector to here */
        for (j = 1; j <= dims; j++) {
          cVecCoeff[i][j] = cVecCoeff[vectors][j];
          let(&(sVecCoeff[i][j]), sVecCoeff[vectors][j]);
          let(&(sVecCoeff[vectors][j]), "");  /* Deallocate */
        }
        cVecCoeff[i][0] = cVecCoeff[vectors][0]; /* Transfer hashcode */
        vecHasOrth[i] = vecHasOrth[vectors];
        vectors--;
        i--; /* In case the last vector swapped down has no orth. mate */
      }
      if (verboseMode) {
        printf(
          "#%ld Removed %ld vectors without orthogonal mate; %ld remain.\n",
          lattices, localVecs - vectors, vectors);
        fflush(stdout);
      }
    } /* if discardNonOrth==1 */
    /********* End of 16-Nov-2017 addition ************/


    /* 16-Nov-2017 nm */
    /********* In -3d mode, add any missing cross products of orth vecs ******/
    if (addCrossProducts == 1 && dims == 3) {
      localVecs = vectors;
      let(&str1, cat(crossComponentList,
          ((crossComponentList[0] != 0 && vectorGenList[0] != 0) ? "," : ""),
          vectorGenList, NULL));
      let(&str2, ""); /* Holds needed simplifications */
/*D*//*printf("str1=%s\n",str1);*/
      for (i = 1; i <= localVecs - 1; i++) {
        for (j = i + 1; j <= localVecs; j++) {
          if (innerProductNonzero(cVecCoeff[i], cVecCoeff[j],
              dims, maxError) == 0) {
/*D*//*printf("ci=%ld %LG %LG %LG\n",i,creall(cVecCoeff[i][1]),creall(cVecCoeff[i][2]),creall(cVecCoeff[i][3]));*/
/*D*//*printf("cj=%ld %LG %LG %LG\n",j,creall(cVecCoeff[j][1]),creall(cVecCoeff[j][2]),creall(cVecCoeff[j][3]));*/
            /* The vectors are orthogonal */
            vectors++;
            if (vectors > MAX_VECTORS - 1) {
              fprintf(stderr,
                  "#%ld ?Error: Exceeded MAX_VECTORS = %ld vectors\n.",
                  lattices, (long)MAX_VECTORS);
              exit(1);
            }
/*D*//*printf("si=%ld %s %s %s\n",i,sVecCoeff[i][1],sVecCoeff[i][2],sVecCoeff[i][3]);*/
/*D*//*printf("sj=%ld %s %s %s\n",j,sVecCoeff[j][1],sVecCoeff[j][2],sVecCoeff[j][3]);*/
            /* https://en.wikipedia.org/wiki/Cross_product */
            let(&(sVecCoeff[vectors][1]), cat(
                "(", sVecCoeff[i][2], ")*(", sVecCoeff[j][3],
                ")-(", sVecCoeff[i][3], ")*(", sVecCoeff[j][2], ")", NULL));
            let(&(sVecCoeff[vectors][2]), cat(
                "(", sVecCoeff[i][3], ")*(", sVecCoeff[j][1],
                ")-(", sVecCoeff[i][1], ")*(", sVecCoeff[j][3], ")", NULL));
            let(&(sVecCoeff[vectors][3]), cat(
                "(", sVecCoeff[i][1], ")*(", sVecCoeff[j][2],
                ")-(", sVecCoeff[i][2], ")*(", sVecCoeff[j][1], ")", NULL));
            for (k = 1; k <= 3; k++) {
              /* Convert string expressions to numeric values */
              c = stringToComplex(sVecCoeff[vectors][k]);
              cVecCoeff[vectors][k] = c;

              /* Cosmetic improvement */
              /* Check to see if it's a "small" integer, < 10000000 */
              /* (Future: extend to "small" integer imaginary coeffs?) */
              /* Note: we do this _before_ the call to vecStandardize()
                 below, so that the sVecCoeff[][] and cVecCoeff[][] will have
                 the same values. */
              if (cimagl(c) == 0.0) {
                if (creall(c) > -10000000.0 && creall(c) < 10000000.0) {
                  if (creall(c) >= 0) {
                    cint = (long)(creall(c) + (maxError / 2));
                  } else {
                    cint = (long)(creall(c) - (maxError / 2));
                  }
                  if (cabsl((long double complex)cint - c) < maxError) {
                    /* If it is an integer, use the integer for the string
                       representation */
                    let(&(sVecCoeff[vectors][k]), str((double)c));
                  }

                  /* Handle factors of sqrt(2) */
                  /* (Future: add other common square roots?) */
                  sqrt2 = stringToComplex("Sqrt[2]"); /* To do: move up */
                  c = c / sqrt2;
                  if (creall(c) >= 0) {
                    cint = (long)(creall(c) + (maxError / 2));
                  } else {
                    cint = (long)(creall(c) - (maxError / 2));
                  }
                  if (cint != 0 /* 0 case is handled as integer above */
                      && cabsl((long double complex)cint - c) < maxError) {
                    /* If it is an integer times sqrt[2], use the integer for
                       the string representation */
                    let(&(sVecCoeff[vectors][k]),
                        cat(str((double)c), "*Sqrt[2]", NULL));
                  }

                } /* if real part is "small" */
              } /* if imaginary part is != 0 */
            } /* next k */

            /* Standardize the vector by dividing all components by the
               first non-zero (abs. val. > maxError) component */
            vecStandardize(cVecCoeff[vectors], dims, maxError);

            /* Ignore duplicate (proportional) vectors */
            foundFlag = 0;
            for (k = 1; k <= vectors - 1; k++) {
              if (vecEqual(cVecCoeff[k], cVecCoeff[vectors],
                  dims, maxError) == 1) {


/*D*/
/*
printf("old=%ld %s new=%ld %s\n",vecStringWeight(k, sVecCoeff, dims),
cat(sVecCoeff[k][1],sVecCoeff[k][2],sVecCoeff[k][3],NULL),
vecStringWeight(vectors, sVecCoeff, dims),
cat(sVecCoeff[vectors][1],sVecCoeff[vectors][2],sVecCoeff[vectors][3],NULL));
*/
/*D*/

                /* 16-Nov-2017 nm */
                /* Cosmetic improvement: */
                /* Decide whether the new proportional vector has a
                   better name such as (1,1,1) instead of (3,3,3); if
                   so, use it instead of the old vector's name */
                if (vecStringWeight(k, sVecCoeff, dims)
                    > vecStringWeight(vectors, sVecCoeff, dims)) {
                  for (j = 1; j <= dims; j++) {
                    /* Swap to simplest overall string coefficient */
                    let(&(sVecCoeff[k][j]), sVecCoeff[vectors][j]);
                  }
                }

                vectors--;
                /*dupCount++;*/
                foundFlag = 1; /* It is a duplicate */
                break;
              } /* if duplicate */
            } /* next k */

            /* Cosmetic improvement */
            /* If we are going to add a new vector for the cross-product,
               check to see if its components are among those in
               the -vgen= or -xp= lists */
            if (foundFlag == 0) {
              k = numEntries(str1);
              for (l1 = 1; l1 <= 3; l1++) {
                foundFlag = 0; /* Reusing foundFlag here... */
                for (l2 = 1; l2 <= k; l2++) {
                  if (cabsl(stringToComplex(entry(l2, str1))
                      - stringToComplex(sVecCoeff[vectors][l1]))
                      <= maxError) {
                    /* Found a matching (presumably shorter) entry in
                       vectorGenList from -vgen; use it. */
                    let(&(sVecCoeff[vectors][l1]), entry(l2, str1));
                    foundFlag = 1;
                    break;
                  }
                  /*let(&str2, "");*/ /* Prevent string stack overflow */
                } /* next l2 */
                if (foundFlag == 0) {
                  if (verboseMode) {
                    if (instr(1, str2, sVecCoeff[vectors][l1]) == 0 ) {
                      printf("#%ld Simplify and add to \"-xp=\" list: %s\n",
                          lattices, sVecCoeff[vectors][l1]);
                      fflush(stdout);
                      let(&str2, cat(str2, ",", sVecCoeff[vectors][l1], NULL));
                    }
                  }
                }
              } /* next l1 */

            } /* if foundFlag == 0 */

          } /* if (innerProductNonzero... == 0) */
        } /* next j */
      } /* next i */
      if (verboseMode) {
        printf(
          "#%ld Added %ld cross products; %ld vectors total.\n",
          lattices, vectors - localVecs, vectors);
        fflush(stdout);
      }
      let(&str2, ""); /* Deallocate memory */
    } /* if addCrossProducts == 1 && dims == 3 */
    /******** end of 16-Nov-2017 add cross products for 3 dim. *****/



    /* 15-Nov-2017 nm */
    /********* Delete vectors not belonging to an orth. basis ******/
/*D*//*printf("vectors a = %ld\n",vectors);*/
    if (discardNonBasis
        /* In -master mode, we MUST discard non-basis vectors to avoid
           gaps in vector numbering in the final output MMP.  So we
           just do this instead of requiring user to include -basis. */
        || masterMMPOnlyMode /* 27-Nov-2017 nm */
        ) {
      for (i = 1; i <= vectors; i++) {
        vecHasOrth[i] = 0; /* vecHasOrth[i] = 1 here means the vector is
                              part of an orthogonal basis */
      }
      /* For each 1st dimension i, try to find dims-1 other vectors that
         are mutually orthogonal.  For the 2nd dimension (orthBasisVecs=2),
         we scan all vectors.  For the 3rd and higher, we start at the
         (n-1)th dimension vector plus 1, since previous ones have effectively
         already been scanned. */
      for (i = numFrozenAtoms + 1; i <= vectors; i++) { /* Don't bother with
               preassigned (frozen) vectors since they will never be deleted */
        if (vecHasOrth[i] == 1) {
          /* Skip if vector has been identified as part of an orth basis
             in the search for an earlier vector */
          continue;
        }
        orthBasis[1] = i;
        orthBasisVecs = 2;  /* The one currently being tried, 1...dims */
        orthBasis[2] = 1;  /* Start 2nd dim at j=1 */
/*D*//*printf("here1 i=%ld orthBasis[1]=%ld\n",i,orthBasis[1]);*/
        foundFlag = 0;
        previous2ndVec = 0; /* Keeps track of j for 2nd dimension */
        q = 1; /* Start of 2nd dim scan for this i */
        while (1) {
/*D*//*printf("here2 ");for(p=1;p<=orthBasisVecs;p++)printf(" %ld",orthBasis[p]);printf("\n"); */
          if (orthBasisVecs < 2) bug(198);


          /*
          if (orthBasisVecs != 2) {
            /@ Start after the previously found vector, since we've
               already searched earlier ones @/
            q = orthBasis[orthBasisVecs] + 1;
          } else {
            /@ Except the first vector (being tested) may start in the
               middle if numFrozenAtoms > 0, so we have to scan all others
               below and above it @/
            q = previous2ndVec + 1;
            if (q > vectors - dims + orthBasisVecs) {
              /@ We've exhausted all 2nd dim vectors @/
              foundFlag = 0; /@ (Redundant, for safety) @/
              break;
            }
          }
          */


          orthFlag = 0; /* Set to 0 in case loop below doesn't get entered */


          joffset = (100* i)/100;  /* Use 0 for original algorithm */
          for (jloop = q; jloop <= vectors - dims + orthBasisVecs; jloop++) {
                     /* vectors - dims + orthBasisVecs leaves room for the rest
                        of the orth. basis vectors, since they will all be
                        in ascending order (except for i).  This provides a
                        small speedup. */
            /* Compute the "real" j to use, which starts after i and
               wraps around.  This hopefully will pre-compute more vectors
               ahead of i in the vecHasOrth[] assignment below and thus
               speed things up with more i-loop skips due to
               "if (vecHasOrth[i] == 1)" above. */
            j = jloop + joffset; if (j > vectors) j -= vectors;

            if (orthBasisVecs == 2) {
              previous2ndVec = j; /* Save so we can backtrack to it */
            }
            orthFlag = 1;
            /* Make sure that trial vector j is orth. to all previous in basis */
            for (k = 1; k < orthBasisVecs; k++) {
/*D*//*printf("i=%ld j=%ld k=%ld orthBasisVecs=%ld\n",i,j,k,orthBasisVecs);*/
              if (orthBasis[k] == j) {
                /* A vector is not orthogonal with itself; exit here to avoid
                   an inner product calc (very small speedup) */
/*D*//*printf("orthBasis[k] == j orthFlag=0\n");*/
                orthFlag = 0;
                break;
              }
              if (innerProductNonzero(cVecCoeff[j], cVecCoeff[orthBasis[k]],
                  dims, maxError) != 0) {
                /* Vectors are not orthogonal */
/*D*//*printf("ff[j], cVecCoeff[orthBasis[k]]  orthFlag=0\n");*/
                orthFlag = 0;
                break;
              }
            } /* next k */
            if (orthFlag == 0) continue; /* Not part of a basis.  Try next
                        vector (next j) for dimension orthBasisVecs */
            orthBasis[orthBasisVecs] = j; /* It's a potential basis vector;
                    save it for higher dim tests and also to know where to
                    backtrack to if higher dim tests fail */
/*D*//*printf("here3 i=%ld orthBasis[1]=%ld orthBasisVecs=%ld\n",i,orthBasis[1],orthBasisVecs);*/
            break; /* We found a vector othogonal to all previous ones
                      in the basis, so continue on to next one, up to dims */
          } /* next j */
/*D*//*printf("i=%ld orthBasisVecs=%ld orthFlag=%ld\n",i,orthBasisVecs,(long)orthFlag); */
/*D*//*printf("ob[1]=%ld ob[2]=%ld ob[3]=%ld\n",orthBasis[1],orthBasis[2],orthBasis[3]);  */
          if (orthFlag == 0) {
            /* A search for a vector orthogonal to all previous vectors in the
               trial basis failed */
            orthBasisVecs--;
            if (orthBasisVecs == 1) {
              /* We've backtracked all the way back to the first basis vector,
                 so vector i is not part of any orthogonal basis */
              foundFlag = 0;
              break; /* Out of while-1 loop */
            }


            if (orthBasisVecs != 2) {
              /* Start after the previously found vector, since we've
                 already searched earlier ones */
              q = orthBasis[orthBasisVecs] + 1;

              /* Adjust q for next jloop assignment */
              q/*jloop*/ = q/*j*/ - joffset; if (q < 1) q += vectors;

            } else {
              /* Except the first vector (being tested) may start in the
                 middle if numFrozenAtoms > 0, so we have to scan all others
                 below and above it */
              q = previous2ndVec + 1;

              /* Adjust q for next jloop assignment */
              q/*jloop*/ = q/*j*/ - joffset; if (q < 1) q += vectors;

              if (q > vectors - dims + orthBasisVecs) {
                /* We've exhausted all 2nd dim vectors */
                foundFlag = 0; /* (Redundant, for safety) */
                break;
              }
            }


          } else { /* orthFlag = 1 */
            /* A search for a vector orthogonal to all previous vectors in the
               trial basis passed */
            if (orthBasisVecs == dims) {
              /* Found a orthogonal basis that includes i */
              foundFlag = 1;
              break; /* Out of while-1 loop */
            }



            if (orthBasisVecs != 2) {
              /* Start after the previously found vector, since we've
                 already searched earlier ones */
              q = orthBasis[orthBasisVecs] + 1;

              /* Adjust q for next jloop assignment */
              q/*jloop*/ = q/*j*/ - joffset; if (q < 1) q += vectors;

            } else {
              /* Except the first vector (being tested) may start in the
                 middle if numFrozenAtoms > 0, so we have to scan all others
                 below and above it */
              q = previous2ndVec + 1;

              /* Adjust q for next jloop assignment */
              q/*jloop*/ = q/*j*/ - joffset; if (q < 1) q += vectors;

              if (q > vectors - dims + orthBasisVecs) {
                /* We've exhausted all 2nd dim vectors */
                foundFlag = 0; /* (Redundant, for safety) */
                break;
              }
            }


            orthBasisVecs++;


          } /* if orthFlag == 0 else */
        } /* while 1 */
/*D*//*commented out 16-Nov-2017:*/
/*D*//*if(!foundFlag){for(p=1;p<=dims;p++)printf("%s,",sVecCoeff[i][p]);printf(" i=%ld\n",i);}*/
/*D*//*printf("here5 i=%ld orthBasis[1]=%ld\n",i,orthBasis[1]);*/
        if (foundFlag == 1) {
          /* Tag all vectors in basis for this i - by tagging the other
             later vectors in the basis as well, we don't have to process
             them again */
          for (k = 1; k <= orthBasisVecs; k++) {
            vecHasOrth[orthBasis[k]] = 1;
/*D*//*printf("i=%ld orthBasis[%ld]=%ld vecHasOrth[%ld]=%ld\n",  */
/*D*/ /*i,k,orthBasis[k],orthBasis[k],(long)(vecHasOrth[orthBasis[k]]));*/
          }
        } /* if !foundFlag */
/*D*//*printf("here9 i=%ld orthBasis[2]=%ld\n",i,orthBasis[2]);*/
      } /* next i */

/*D*//*for(i=1;i<=vectors;i++)printf("%ld=%ld ",i,(long)(vecHasOrth[i]));*/

      /* Now remove vectors in no orthogonal basis from the vector array */
      localVecs = vectors;
      for (i = numFrozenAtoms + 1; i <= vectors; i++) {
                   /* Skip the numFrozenVecs vectors at the beginning */
        if (vecHasOrth[i] == 1) {
          continue;
        }
        /* Discard this vector by transferring the last vector to here */
        for (j = 1; j <= dims; j++) {
          cVecCoeff[i][j] = cVecCoeff[vectors][j];
          let(&(sVecCoeff[i][j]), sVecCoeff[vectors][j]);
          let(&(sVecCoeff[vectors][j]), "");  /* Deallocate */
        }
        cVecCoeff[i][0] = cVecCoeff[vectors][0]; /* Transfer hashcode */
        vecHasOrth[i] = vecHasOrth[vectors];
        vectors--;
        i--; /* We want to check this i again, in case the last vector
                swapped down isn't in an orthogonal basis */
      } /* next i */
      if (verboseMode) {
        printf(
          "#%ld Removed %ld vectors not part of orth. basis; %ld remain.\n",
          lattices, localVecs - vectors, vectors);
        fflush(stdout);
      }

    } /* if (discardNonBasis) */
/*D*//*printf("vectors c = %ld\n",vectors);*/
    /******** end of 15-Nov-2017 delete vectors not in orth. basis ******/


    /**** Error check: make sure all string representations match all
          complex number representations *******/
    /* (Can be skipped for speedup) */
    for (i = 1; i <= vectors; i++) {
      for (j = 1; j <= dims; j++) {
        /* Convert string expressions to numeric values */
        /* Note that we use cVecCoeff entry 0 temporarily, which is
           not used since the vector numbering starts at 1 */
        c = stringToComplex(sVecCoeff[i][j]);
        cVecCoeff[0][j] = c;
      }
      vecStandardize(cVecCoeff[0], dims, maxError);

      if (vecEqual(cVecCoeff[i], cVecCoeff[0],
                dims, maxError) == 0) {
        fprintf(stderr, "?Error: Vector %ld has string components:", i);
        for (j = 1; j <= dims; j++) {
          fprintf(stderr, " %s", sVecCoeff[i][j]);
        }
        fprintf(stderr, "\n");
        fprintf(stderr, "        but normalized components (1st is hashcode):");
        for (j = 0; j <= dims; j++) {
          fprintf(stderr, " %LG", creall(cVecCoeff[0][j]));
        }
        fprintf(stderr, "\n");
        fprintf(stderr, "        vs. expected:");
        for (j = 0; j <= dims; j++) {
          fprintf(stderr, " %LG", creall(cVecCoeff[i][j]));
        }
        fprintf(stderr, "\n");
        fprintf(stderr, "        The hashcode difference is: %LG\n",
              cabsl(cVecCoeff[i][0] - cVecCoeff[0][0]));
        bug(306);
      }
      /* Check that no vectors are zero */
      zFlag = 1;
      for (j = 1; j <= dims; j++) {
        if (cabsl(cVecCoeff[i][j]) > maxError) {
          zFlag = 0; /* A nonzero component was found */
          break;
        }
      }
      if (zFlag == 1) {
        fprintf(stderr, "?Error: Vector %ld is zero", i);
        bug(307);
      }
    } /* next i */



    if (vectors == 0) {
      fprintf(stderr,
          "#%ld ?Error: No vectors were specified.  Use an MMP pre-assignment,\n",
          lattices);
      fprintf(stderr, "#%ld   -vfile, and/or -vgen to specify them.\n",
          lattices);
      exit(1);
    }

    if (printVectorsOnlyMode == 1) {
      /* Print out the vector list */
/*D*//*printf("vectors z = %ld\n",vectors); */
      for (i = 1; i <= vectors; i++) {
        printf("{");
        for (j = 1; j <= dims; j++) {
          printf( "%s%s", sVecCoeff[i][j],
              ((j < dims) ? "," : ""));
        }
        printf("}\n");
      }
      fflush(stdout);
      goto RETURN_POINT;
    }

    /* Add the zero vector in order to skip unassignable atoms */
    zeroVec = vectors + 1;
    for (j = 1; j <= dims; j++) {
      let(&(sVecCoeff[zeroVec][j]), "0");
      cVecCoeff[zeroVec][j] = 0;
    }


    if (slowMode == 0) {    /* 11-Jan-2017 nm */
      /* In "fast" mode, a byte table vecProdNonzero[i][j] is pre-computed
         with whether vectors are orthogonal.  However, too many vectors
         will overflow memory, so slow mode is offered as a workaround. */

      /* 4-Dec-2017 nm */
      /* Deallocate previous vecProdNonzero[i][j] if it exists */
      if (vecProdNonzero != NULL && vectorsOld != vectors) {
             /* If the number of vectors didn't change, reuse the old matrix */
        free2DCharMatrix(vecProdNonzero, vectors + 2);
        if (vecProdNonzero != NULL) bug(308);
      }
      /* Note that vectorsOld is 0 the first time through, so
         allocation will happen */
      if (vectorsOld != vectors) {
        /* Dynamically allocate vecProdNonzero[][] */
        vecProdNonzero = alloc2DCharMatrix(vectors + 2, vectors + 2);
      }


      /* Populate scalar product table */
      for (i = 1; i <= vectors + 1; i++) {  /* Add +1 for zeroVec */
        for (j = 1; j <= vectors + 1; j++) {
          cVecProduct = 0;
          for (k = 1; k <= dims; k++) { /* k = dimension */
              cVecProduct += cVecCoeff[i][k] * conjl(cVecCoeff[j][k]);
          }
          /* Assign the vecProdNonzero array used for fast lookup */
          if (cabsl(cVecProduct) <= maxError) {
            vecProdNonzero[i][j] = 0;
          } else {
            vecProdNonzero[i][j] = 1;
          }

          /* Save the smallest nonzero vector product */
          if (cabsl(cVecProduct) > maxError && cabsl(cVecProduct) < minNZProd) {
            minNZProd = cabsl(cVecProduct);
            minNZVec1 = i;
            minNZVec2 = j;
          }
          /* Save the largest zero vector product */
          if (cabsl(cVecProduct) <= maxError && cabsl(cVecProduct) > maxZProd) {
            maxZProd = cabsl(cVecProduct);
            maxZVec1 = i;
            maxZVec2 = j;
          }
        }
      }
      if (verboseMode == 1) {
        printf(
          "#%ld Min scalar prod (=/=0) has abs value = %LG vs. threshold %LG.\n",
            lattices, minNZProd, maxError);
        let(&str1, "");
        let(&str2, "");
        for (k = 1; k <= dims; k++) {
          let(&str1, cat(str1, sVecCoeff[minNZVec1][k], (k != dims) ? "," : "",
              NULL));
          let(&str2, cat(str2, sVecCoeff[minNZVec2][k], (k != dims) ? "," : "",
              NULL));
        }
        printf("#%ld    1st vector = %s; 2nd vector = %s\n", lattices, str1, str2);
        printf(
          "#%ld Max scalar prod (=0) has abs value = %LG vs. threshold %LG.\n",
            lattices, maxZProd, maxError);
        let(&str1, "");
        let(&str2, "");
        for (k = 1; k <= dims; k++) {
          let(&str1, cat(str1, sVecCoeff[maxZVec1][k], (k != dims) ? "," : "",
              NULL));
          let(&str2, cat(str2, sVecCoeff[maxZVec2][k], (k != dims) ? "," : "",
              NULL));
        }
        printf("#%ld    1st vector = %s; 2nd vector = %s\n", lattices, str1, str2);
        fflush(stdout);
      }
    } /* if (slowMode == 0) */

    /* 27-Nov-2017 nm */
    if (masterMMPOnlyMode == 1) {
      let(&str10, ""); /* Output MMP */
      if (dims < 3 || dims > 9) {
        /* Future: allow more dims? */
        fprintf(stderr,
            "?Error: -master is implemented for -3d through -9d only\n");
        exit(1);
      }
      if (slowMode == 1) {
        /* Future: allow this? */
        fprintf(stderr, "?Error: -big may not be specified with -master\n");
        exit(1);
      }
      for (i = 1; i <= vectors - (dims - 1); i++) {
        for (j = i + 1; j <= vectors - (dims - 2); j++) {
          if (vecProdNonzero[i][j] == 1) {
            /* The vectors aren't orthogonal */
            continue;
          }
          for (k = j + 1; k <= vectors - (dims - 3); k++) {
            if (vecProdNonzero[i][k] == 1
                || vecProdNonzero[j][k] == 1) {
              /* The vectors aren't orthogonal */
              continue;
            }
            for (l4 = k + 1;
                l4 <= ((dims >= 4) ? vectors - (dims - 4) : k + 1); l4++) {
              if (dims >= 4) {
                if (vecProdNonzero[i][l4] == 1
                    || vecProdNonzero[j][l4] == 1
                    || vecProdNonzero[k][l4] == 1) {
                  /* The vectors aren't orthogonal */
                  continue;
                }
              }
              for (l5 = l4 + 1;
                  l5 <= ((dims >= 5) ? vectors - (dims - 5) : l4 + 1); l5++) {
                if (dims >= 5) {
                  if (vecProdNonzero[i][l5] == 1
                      || vecProdNonzero[j][l5] == 1
                      || vecProdNonzero[k][l5] == 1
                      || vecProdNonzero[l4][l5] == 1) {
                    /* The vectors aren't orthogonal */
                    continue;
                  }
                }
                for (l6 = l5 + 1;
                    l6 <= ((dims >= 6) ? vectors - (dims - 6) : l5 + 1); l6++) {
                  if (dims >= 6) {
                    if (vecProdNonzero[i][l6] == 1
                        || vecProdNonzero[j][l6] == 1
                        || vecProdNonzero[k][l6] == 1
                        || vecProdNonzero[l4][l6] == 1
                        || vecProdNonzero[l5][l6] == 1) {
                      /* The vectors aren't orthogonal */
                      continue;
                    }
                  }
                  for (l7 = l6 + 1;
                      l7 <= ((dims >= 7) ? vectors - (dims - 7) : l6 + 1); l7++) {
                    if (dims >= 7) {
                      if (vecProdNonzero[i][l7] == 1
                          || vecProdNonzero[j][l7] == 1
                          || vecProdNonzero[k][l7] == 1
                          || vecProdNonzero[l4][l7] == 1
                          || vecProdNonzero[l5][l7] == 1
                          || vecProdNonzero[l6][l7] == 1) {
                        /* The vectors aren't orthogonal */
                        continue;
                      }
                    }
                    for (l8 = l7 + 1;
                        l8 <= ((dims >= 8) ? vectors - (dims - 8) : l7 + 1); l8++) {
                      if (dims >= 8) {
                        if (vecProdNonzero[i][l8] == 1
                            || vecProdNonzero[j][l8] == 1
                            || vecProdNonzero[k][l8] == 1
                            || vecProdNonzero[l4][l8] == 1
                            || vecProdNonzero[l5][l8] == 1
                            || vecProdNonzero[l6][l8] == 1
                            || vecProdNonzero[l7][l8] == 1) {
                          /* The vectors aren't orthogonal */
                          continue;
                        }
                      }
                      for (l9 = l8 + 1;
                          l9 <= ((dims >= 9) ? vectors - (dims - 9) : l8 + 1); l9++) {
                        if (dims >= 9) {
                          if (vecProdNonzero[i][l9] == 1
                              || vecProdNonzero[j][l9] == 1
                              || vecProdNonzero[k][l9] == 1
                              || vecProdNonzero[l4][l9] == 1
                              || vecProdNonzero[l5][l9] == 1
                              || vecProdNonzero[l6][l9] == 1
                              || vecProdNonzero[l7][l9] == 1
                              || vecProdNonzero[l8][l9] == 1) {
                            /* The vectors aren't orthogonal */
                            continue;
                          }
                        }
                        /* Found a mutually orthogonal n-tuple; turn it into
                           an MMP edge */
                        blocks++;
                        let(&str1, "");
                        str1 = extendedAtomName(i);
                        let(&str2, "");
                        str2 = extendedAtomName(j);
                        let(&str3, "");
                        str3 = extendedAtomName(k);
                        let(&str4, "");
                        str4 = (dims >= 4 ) ? extendedAtomName(l4) : "";
                        let(&str5, "");
                        str5 = (dims >= 5 ) ? extendedAtomName(l5) : "";
                        let(&str6, "");
                        str6 = (dims >= 6 ) ? extendedAtomName(l6) : "";
                        let(&str6, "");
                        str7 = (dims >= 7 ) ? extendedAtomName(l7) : "";
                        let(&str7, "");
                        str8 = (dims >= 8 ) ? extendedAtomName(l8) : "";
                        let(&str8, "");
                        str9 = (dims >= 9 ) ? extendedAtomName(l9) : "";
                        let(&str10, cat(str10,
                          (str10[0] != 0) ? "," : "",
                          str1, str2, str3, str4, str5, str6,
                          str7, str8, str9, NULL));
          /*D*//*printf("l4=%ld k=%ld vectors=%ld str10=%s\n",l4,k,vectors,str5);*/
                      } /* next l9 */
                    } /* next l8 */
                  } /* next l7 */
                } /* next l6 */
              } /* next l5 */
            } /* next l4 */
          } /* next k */
        } /* next j */
      } /* next i */
      let(&str10, cat(str10, ".", NULL)); /* Final MMP period */
      /* Add the vector suffix to the MMP */
      let(&str10, cat(str10, "{", NULL));
      for (i = 1; i <= vectors; i++) {
        let(&str1, "");
        str1 = extendedAtomName(i);
        let(&str10, cat(str10, (i > 1) ? "," : "", str1, "={", NULL));
        for (j = 1; j <= dims; j++) {
          let(&str10, cat(str10, sVecCoeff[i][j], (j < dims) ? "," : "}", NULL));
        }
      }
      let(&str10, cat(str10, "}", NULL));
      printf("v%lde%ld:: %s\n", vectors, blocks, str10);
      fflush(stdout);
      goto RETURN_POINT;
    } /*if (masterMMPOnlyMode == 1)*/


  } /* if (firstTime == 1 || preAssignment[0] != 0) */

  /* Variables for next MMP */
  vectorsOld = vectors;
  hasPreassignmentOld = hasPreassignment;

  /*********************************************************************/


  /* Count number of blocks each atom occurs in */
  for (i = 1; i <= atoms; i++) {
    atomBlocks[i] = 0;
  }
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      atomBlocks[block[i][j]]++;
    }
  }

  /* Build the list of neighbors for each atom */
  for (i = 1; i <= atoms; i++) {
    atomNeighbors[i] = 0;
  }

  /* Populate atom neighbor lists */
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      if (atomBlocks[block[i][j]] < 1) bug(14);
      if (atomBlocks[block[i][j]] == 1 && noKick == 0
          /* TODO: What was the clause below for? */
          /*&& frozenVec[block[i][j]] == 0*/ /* if not preassigned */
          ) continue;
                  /* Ignore atoms in only 1 block */
      at = block[i][j];
      if (at < 1 || at > maxAtom) bug(15);
      for (k = 1; k <= blockSize[i]; k++) {
        if (j == k) continue;
        if (atomBlocks[block[i][k]] == 1 && noKick == 0) continue;
                    /* Ignore atoms in only 1 block */
        neiAt = block[i][k];
        if (neiAt < 1 || neiAt > maxAtom) bug(16);
        if (at == neiAt) bug(17);
        skip = 0;
        /* Don't put a neighbor twice (necessary?) */
        for (l = 1; l <= atomNeighbors[at]; l++) {
          if (atomNeighbor[at][l] == neiAt) {
            skip = 1;
            /* Enhance this with more information later if nec. */
            /*
            fprintf(stderr, "#%ld ?Error: Found duplicate neighbor pair\n",
                lattices);
            */

            if (verboseMode == 1) {
              /* 26-Apr-2017 nm Enhance with more information*/
              fprintf(stderr,
 "#%ld ?Warning:  Edge %ld has two vertices in common with another edge.\n",
                lattices, i);
            }

            /*bug(18);*/ /* Should never get here with good diagram? */
            break;
          }
        }
        if (skip) continue;
        atomNeighbors[at]++; /* Actual number of neighbors */
        atomNeighbor[at][atomNeighbors[at]] = neiAt;
      }
    }
  }


  /* Count the number of isolated atoms to ignore */
  /*
  numKickedAtoms = 0;
  for (i = 1; i <= atoms; i++) {
    if (atomBlocks[i] == 1 && noKick == 0
        && frozenVec[i] == 0  /@ if not preassigned @/
        ) numKickedAtoms++;
  }
  */


  for (i = 1; i <= vectors; i++) {
    vecUsed[i] = 0; /* 0 means available for use */
  }
  availableVecs = vectors;
  for (i = 1; i <= atoms; i++) {
    atomVec[i] = 0; /* 0 means not yet assigned */
  }



  /* frozenVec : {actual atoms} -> {vectors} */
  /* frozenAtom : {vectors} -> {actual atoms} */
  /* atomVec : {actual atoms} -> {vectors} */
  /* vecUsed : {vectors} -> {0,1} */
  /* atomMap : {good atoms} -> {actual atoms} */
  /* atomReverseMap : {actual atoms} -> {good atoms}, or 0 if
        actual atom not good i.e.: used by 1 block and -nk not set */
  /* atomBlocks : {actual atoms} -> {# of blocks} */
  /* atomNeighbors : {actual atoms} -> {# of actual atom neighbors} */
  /* atomNeighbor : {actual atoms}, {1...atomNeighbors} -> {actual atoms} */

  if (numFrozenAtoms > 0) { /* There are fixed preassignments */

    /* Set the atomVec and vecUsed entries */
    for (i = 1; i <= atoms; i++) {
      if (frozenVec[i] > 0) {
        atomVec[i] = frozenVec[i];
        if (vecUsed[frozenVec[i]] != 0) bug(19);
        vecUsed[frozenVec[i]] = 1;
        availableVecs--;
      }
    }

    /* Check that pre-assignment is valid */
    for (i = 1; i <= atoms; i++) {
      if (frozenVec[i] == 0) continue;
      if (atomBlocks[i] == 1 && noKick == 0) {
        let(&str1, "");
        str1 = extendedAtomName(i);
        fprintf(stderr,
    "#%ld ?Warning: You aren't using -nk, but isolated vertex %s is preassigned.\n",
            lattices, str1);
        let(&str1, "");
      }

      for (j = 1; j <= atomNeighbors[i]; j++) {
        at = atomNeighbor[i][j];
        if (atomVec[at] == 0) {
          /* Continue if atom not yet assigned */
          continue;
        }
        /* Check to see if the scalar product of the neighboring vector
           is zero (this is the key criterion) */
        /*
        if (vecProdNonzero[frozenVec[i]][atomVec[at]] != 0) {
        */
        /* 11-Jan-2017 nm */
        if ((slowMode == 0
            ?
            /* Fast (table lookup) */
            vecProdNonzero[frozenVec[i]][atomVec[at]]
            :
            /* Slow (no table memory needed) */
            innerProductNonzero(cVecCoeff[frozenVec[i]],
                cVecCoeff[atomVec[at]], dims, maxError)
            ) != 0) {

          /* Not orthogonal */
          let(&str1, "");
          str1 = extendedAtomName(i);
          let(&str2, "");
          str2 = extendedAtomName(at);
          fprintf(stderr,
 "#%ld ?Error: Scalar product of preassigned vertices %s and %s is nonzero.\n",
              lattices, str1, str2);
          let(&str1, "");
          let(&str2, "");
        }
      }
    }
  }

  /* Freeze the isolated atoms if not -nk, and assign the zero vector to
     them so that scalar product will always be 0.  We could also just
     keep polling noKick and atomBlocks[]=1, but maybe this is slightly
     faster. */
  if (noKick == 0) {
    for (i = 1; i <= atoms; i++) {
      if (atomBlocks[i] == 1) {
        /* Skip if vector has been pre-assigned in spite of not -nk
           (warning was issued above) */
        if (atomVec[i] != 0) continue;
        atomVec[i] = zeroVec;
        frozenVec[i] = zeroVec;
        /* vecUsed[zeroVec] = 1; */ /* Unnecessary */
        numFrozenAtoms++;
      }
    }
  }


  /* This is the most vectors we can assign to "normal" atoms (those
     in >1 blocks) for 3d mode */
  unlabeledVectors = vectors;

  numRetries = 0;

  while (1) {
    /* This outer loop restarts the whole search procedure (unless we
       are just looking to find 'fail' as quickly as possible by
       specifying keepTryingAfterFail = 0) so that we can assign as many
       vertices as possible. */

    /* Reinitialize backtrack variables for 2nd and later iterations */
    backtrackCountx = 0;  /* We don't reset globalBacktrackCountx here */
    highestBacktrackx = -1;
    localHighestBacktrackx = -1;

    for (i = 1; i <= atoms; i++) {
      /* Initialize saved vectors in case it doesn't get reassigned */
      saveAtomVec[i] = atomVec[i];
    }
    saveUnassignableAtom = 0; /* 0 means there is none yet */

/*D*//*p=0;for(q=1;q<=vectors;q++)if(!vecUsed[q])p++;printf("herea p=%ld avail=%ld\n",p,availableVecs);*/
    /* Map the good atoms (i.e. that need to be assigned) to atoms */
    goodAtoms = 0; /* Atoms in more than 1 block */

    for (i = 1; i <= atoms; i++) {
      atomReverseMap[i] = 0; /* Means not a good atom */
    }

    /* 15-Oct-2016 nm */
    /* Unfreeze the MMP assignment to use as the starting assignment */
    /* It is important to do this first in order to have the first good
       atoms assigned to the pre-assigned atoms, so first scan can continue
       after them. */
    if (lockMMPAssignment == 0
        && numRetries == 0 /* Treat specially only on first iteration */) {
      for (i = 1; i <= atoms; i++) {
/*D*//*printf("HERE atomVec[%ld]=%ld frozenVec[i]=%ld numPreassignedAtoms=%ld\n",i,atomVec[i],frozenVec[i],numPreassignedAtoms);*/
        if (frozenVec[i] != 0 && atomVec[i] <= numPreassignedAtoms) {
          if (atomVec[i] == 0) bug(51); /* All frozen ones should be assigned */
          if (atomVec[i] == zeroVec) bug(52);
          goodAtoms++;
          frozenVec[i] = 0; /* Unfreeze it */
          numFrozenAtoms--;
          atomMap[goodAtoms] = i;
          atomReverseMap[i] = goodAtoms;
          if (vecUsed[atomVec[i]] == 0) bug(53);
          freeVecs[goodAtoms] = vectors - i; /* For statistics */
          /* Pre-assign the dynamic map for later use when backtracking */
          /* The argument is the mapped atom (via atomReverseMap) */
          dynAtomMap[goodAtoms] = goodAtoms;
          dynAtomRevMap[goodAtoms] = goodAtoms;
          if (atomVec[atomMap[dynAtomMap[goodAtoms]]] != atomVec[i]) bug(56);
        }
      }
      if (goodAtoms != numPreassignedAtoms) bug(54);
    }

    /* The main scan to find good atoms */
    for (i = 1; i <= atoms; i++) {
      if (/*(atomBlocks[i] > 1 || noKick == 1) &&*/
            /* Skip preassigned atoms no matter what */
            frozenVec[i] == 0) {
        if (!(lockMMPAssignment == 0 && numRetries == 0
            && frozenVec[i] == 0 && atomVec[i] <= numPreassignedAtoms
            && atomVec[i] != 0)) {
          /* It is not an unfrozen MMP preassignment */
          if (atomVec[i] != 0) bug(55);
          goodAtoms++;
          atomMap[goodAtoms] = i;
          atomReverseMap[i] = goodAtoms;
        }
      }
/*D*//*printf("i=%ld goodAtoms=%ld atomMap[goodAtoms]=%ld atomReverseMap[i]=%ld\n",i,goodAtoms,atomMap[goodAtoms],atomReverseMap[i]);*/
    }

    if (goodAtoms == 0) {
      /* We've exhausted assignable atoms */
      successFlag = realSuccessFlag;
      break;
    }

    if (/*noKick == 1 &&*/ goodAtoms != atoms - numFrozenAtoms) {
      bug(20); /* noKick = 1 means all non-frozen atoms will be used ("good") */
    }


    /* Exended vectors for "don't kick out" i.e. "labelling" option in 3d
       (see mp/nm email of 1-Feb-04) */
    /* From old vectorfind.c: */
    /* if (dims == 3 && noKick == 1
        && modeid != MODE_3dmanynk) { ... */


    /********** Order available ("good") atoms prior to main scan *************/

    if (lockMMPAssignment == 0 && numRetries == 0) {
      /* Don't reorder the MMP pre-assignment since we depend on the
         fact that it starts at 1 and ends at numPreassignedAtoms to
         be able to jump into the middle of the main algorithm to continue
         the scan */
      unlockedMMPStart = numPreassignedAtoms + 1;
    } else {
      unlockedMMPStart = 1; /* Normal behavior w/out MMP preassignment */
    }

    for (i = unlockedMMPStart; i <= goodAtoms; i++) {
      /* Sort the atoms for tightest "clustering" */
      /* highestNeighborCount = 0; */
      highestNeighborWeight = -10000;
      atomWithHighestWeight = i;
      /* Look at all remaining atoms to see which has the most neighbors in
          the list of atoms so far */
      for (j = i; j <= goodAtoms; j++) {
        /* 9-Jun-2016 */
        /* Weights were determined experimentally for bub,peres,c-k.mmp */
        neighborWeight = 0;
        at = atomMap[j];
        for (k = 1; k <= atomNeighbors[at]; k++) {
          if (atomReverseMap[atomNeighbor[at][k]] < i
              /* 0 means outside of the current set of "good atoms" */
              && atomReverseMap[atomNeighbor[at][k]] != 0) {
            /* neighborWeight++; */
            /* Increase weight for each lower neighbor */
            neighborWeight = neighborWeight + weightA
                + (weightB * atomReverseMap[atomNeighbor[at][k]]);
          }
        }
        /* Increase weight with total neighbors */
        neighborWeight = (weightC * neighborWeight)
              + (weightD * atomNeighbors[at]);
        /*
        if (neighborWeight > highestNeighborWeight
            || (neighborWeight == highestNeighborWeight &&
                atomNeighbors[at] > highestNeighborCount)) {
        */
        if (neighborWeight > highestNeighborWeight) {
          highestNeighborWeight = neighborWeight;
          /* highestNeighborCount = atomNeighbors[at]; */
          atomWithHighestWeight = j;
        }
      } /* next j */
      /* 6-Jun-2016 nm  Make the debugging option official */
      if (noClustering) {  /* -nc option */
        atomWithHighestWeight = i;
      }
      /*atomWithHighestWeight = i;*/  /* No sort for debugging */
      /* Now swap the current atom with the "best" atom found */
      /* We will be swapping atoms i and j */
      if (!atomWithHighestWeight) bug(21);
      j = atomWithHighestWeight;
/*D*//*printf("j=%ld aj=%ld atomWithHighestWt=%ld neighborWt=%ld highestNeighborWt=%ld\n",j,atomMap[j],atomWithHighestWeight,neighborWeight,highestNeighborWeight);*/

      /* Swap things */
      if (atomReverseMap[atomMap[i]] != i || atomReverseMap[atomMap[j]] != j) {
/*D*/fprintf(stderr,"i=%ld armi=%ld j=%ld amj=%ld armj=%ld\n",i,atomReverseMap[atomMap[i]],j,atomMap[j],atomReverseMap[atomMap[j]]);
        bug(22);
      }
      l = atomMap[i];
      atomMap[i] = atomMap[j];
      atomMap[j] = l;
      if (atomReverseMap[atomMap[i]] != j || atomReverseMap[atomMap[j]] != i) {
/*D*//*fprintf(stderr,"i=%ld armi=%ld j=%ld amj=%ld armj=%ld\n",i,atomReverseMap[atomMap[i]],j,atomMap[j],atomReverseMap[atomMap[j]]);*/
        bug(23);
      }
      atomReverseMap[atomMap[i]] = i;
      atomReverseMap[atomMap[j]] = j;
    } /* next i */

/*D*//*printf("atomMap1=%ld atomMap2=%ld atomMap3=%ld\n",atomMap[1],atomMap[2],atomMap[3]);*/
/*D*//*printf("atomNeighbors1=%ld atomNeighbors2=%ld atomNeighbors3=%ld\n",atomNeighbors[1],atomNeighbors[2],atomNeighbors[3]);*/


    /* Do we have enough vectors? */
/*D*//*p=0;for(q=1;q<=vectors;q++)if(!vecUsed[q])p++;printf("herex p=%ld avail=%ld\n",p,availableVecs);*/
    j = 0;
    for (i = 1; i <= vectors; i++) {
      if (vecUsed[i] == 0) j++;
    }
    if (j != availableVecs) {
      printf("j=%ld availableVecs=%ld\n", j, availableVecs);
      fflush(stdout);
      bug(24); /* TODO: just use availableVecs */
    }
    if (verboseMode) {
      printf(
          "#%ld %ld/%ld verts unassigned, %ld/%ld vecs avail, %ld backtracks\n",
          lattices, goodAtoms, atoms, j, vectors, globalBacktrackCountx);
      fflush(stdout);
    }
    if (j < goodAtoms && numRetries == 0) {
      /* TODO: this message doesn't make sense when all vectors are
         preassigned:  says 57 unassigned vertices and 0 available vectors */
      fprintf(stderr,
"#%ld ?Warning: There are %ld unassigned vertices but only %ld available vectors.\n",
          lattices, goodAtoms, j);
      /* exit(1) */
      /* Continue on to get a partial assignment */
    }


    /* Populate the "lower neighbors" arrays (used for slight speedup of
       backtrack algorithm) */
    /* 17-Jun-2016 Not used for new dynamic candidate algorithm */
    /*
    for (i = 1; i <= goodAtoms; i++) {
      atomLowerNeighbors[i] = 0;
      for (j = 1; j <= atomNeighbors[i]; j++) {
        if (atomNeighbor[atomMap[i]][j] > atomMap[i]) continue;
        if (atomNeighbor[atomMap[i]][j] == atomMap[i]) bug(25);

        atomLowerNeighbors[i]++; /@ Number of smaller neighbors @/
        atomLowerNeighbor[i][atomLowerNeighbors[i]]
            = atomNeighbor[atomMap[i]][j];
      }
    }
    */

    /********** Main scan to assign vectors *************/

    /*  */


    for (i = unlockedMMPStart; i <= goodAtoms; i++) {
      dynAtomMap[i] = 0;  /* 0 means available for use */
      dynAtomRevMap[i] = 0;  /* 0 means available for use */
      freeVecs[i] = 0;  /* For statistics; not important for algorithm */
    }

    successFlag = 1;

    atomSeq = unlockedMMPStart - 1;  /* 0 w/out MMP preassignment */
    /*
    if (lockMMPAssignment == 0 && numRetries == 0) {
      /@ We've preassigned and skipped over the MMP assignment, but we
         want to allow backtracking through it later if necessary @/
      atomSeq = numPreassignedAtoms;
    } else {
      atomSeq = 0;
    }
    */
    foundFlag = 1;

    while (1) {
      /* This is the main scan with backtracking that tries to find
         a valid assignment or a contradiction quickly. */
/*D*//*if(numRetries)printf("foundflag=%ld\n",(long)foundFlag);*/
      if (foundFlag) {
        atomSeq++; /* Go to next atom */
/*D*//*for(q=1;q<=atomSeq;q++)printf("%ld ",atomMap[q]);printf("atomSeq++=%ld\n",atomSeq);*/

        if (atomSeq > goodAtoms) { /* Success */
          break;
        }

        foundFlag = 0;
        /* 17-Jun-2016 nm */
        /* Find the (first) atom which admits the least number of
           vector assignments.  It will be the atom used for
           dynAtom[atomSeq]. */
        /* The goal is to have as few vectors early on as possible to
           backtrack to when a conflict occurs, in order to reduce exponential
           behavior */
        leastFreeVecCount = vectors + 1;  /* > vectors to guarantee finding it */
        highestNeighborCount = -1;
        leastFreeAtom = 0; /* Should be nonzero at end; if not, it's a bug */
        leastFreeFirstVec = 0;  /* 1st avail vector for the atom */
        freeVecCount = 0; /* = 0 redundant; prevent possible gcc warning */
        firstVec = 0; /* = 0 redundant; prevent possible gcc warning */

        /* for (at = atomSeq; at <= atomSeq; at++) { */ /* emulate old algorithm */
        /* for (at = 1; at <= goodAtoms; at++) { */ /* new dynamic algorithm */
        if (dynamicAtomAssignment) {
          /* Scan all unassigned atoms */
          firstAt = 1;
          lastAt = goodAtoms;
        } else {
          /* Assign the next atom in order, to the first vector free for it */
          firstAt = atomSeq;
          lastAt = atomSeq;
        }
/*D*//*printf("firstAt=%ld lastAt=%ld\n",firstAt,lastAt);*/
        for (at = firstAt; at <= lastAt; at++) {
/*D*//*printf("at=%ld dynAtomRevMap[at]=%ld\n",at,dynAtomRevMap[at]);*/
          if (dynAtomRevMap[at] != 0) continue;
          mappedAtom = atomMap[at];
/*D*//*printf("mappedAtom=%ld atomVec[mappedAtom]=%ld\n",mappedAtom,atomVec[mappedAtom]);*/
          if (atomVec[mappedAtom] != 0) continue;  /* Atom already assigned */
          freeVecCount = 0;
          firstVec = 0; /* 0 indicates not assigned yet */
          conflict = 1; /* For compiler uninitialized warning */
          for (vec = 1; vec <= vectors; vec++) {
            if (vecUsed[vec] == 1) continue; /* Vector already used */

            /* If it is not a "labeled" atom, we can only select from
               the unlabeled vectors */
/*TODO - get rid of unlabeledVector stuff */
            if (vec > unlabeledVectors) {
              if (dims != 3 || noKick == 0) bug(26);
              /* The criterion for "labeled" is = 1 block, so if > 1 blocks
                 then exit the loop since we can't use
                 unlabeledVectors + 1 <= i <= vectors */
              if (atomBlocks[mappedAtom] > 1) break;
            }
            /* Check to make sure this vector is compatible with (orthogonal
               to) the atom's (assigned) neighbors i.e. other atoms sharing
               an edge */
            conflict = 0;
            for (j = 1; j <= atomNeighbors[mappedAtom]; j++) {
              /* Continue if atom not yet assigned */
              if (atomVec[atomNeighbor[mappedAtom][j]] == 0) {
                continue;
              }

              /* 28-Dec-2016 nm Future: To use bits instead of bytes:
                 http://stackoverflow.com/questions/26359068/mask-and-extract-bits-in-c
                 int getBit(char byte, int bitNum)
                 {
                     return (byte & (0x1 << (bitNum - 1)))
                 }
              */

              /* Check to see if the scalar product of the neighboring vector
                 is zero (this is the key criterion) */
              /*
              if (vecProdNonzero[vec][atomVec[atomNeighbor[mappedAtom][j]]]
                 != 0) {
              */
              /* 11-Jan-2017 nm */
              if ((slowMode == 0
                  ?
                  /* Fast (table lookup) */
                  vecProdNonzero[vec][atomVec[atomNeighbor[mappedAtom][j]]]
                  :
                  /* Slow (no table memory needed) */
                  innerProductNonzero(cVecCoeff[vec],
                      cVecCoeff[atomVec[atomNeighbor[mappedAtom][j]]],
                      dims, maxError)
                  ) != 0) {
                /* Collision */
                conflict = 1;
                break;
              }
            }

            if (!conflict) {
              if (firstVec == 0) {
                firstVec = vec; /* The first conflict-free vector */
              }
              freeVecCount++;
              /* Speedup: stop counting if we've exceeded the least so far */
              /*if (freeVecCount >= leastFreeVecCount) {*/
              if (freeVecCount > leastFreeVecCount
                  || (freeVecCount == leastFreeVecCount
                     && highestNeighborCount >= atomNeighbors[mappedAtom])) {
                break;
              }

              /* In static mode, we just need to get to first conflict-free
                 vector */
              if (!dynamicAtomAssignment) break;

            }
          } /* Next vec (vector) */
/*D*//*printf("here1 leastFreeVecCount=%ld leastFreeAtom=%ld leastFreeFirstVec=%ld\n",*/
/*D*//*        leastFreeVecCount, leastFreeAtom, leastFreeFirstVec);                  */
          /*if (freeVecCount < leastFreeVecCount) {*/
          /* leastFreeAtom = at; */ /* 11-Oct-2016 nm Moved out of if */
          if (freeVecCount < leastFreeVecCount
              || (freeVecCount == leastFreeVecCount
                && highestNeighborCount < atomNeighbors[mappedAtom])) {    /*D*/ /* < to <= */
            leastFreeVecCount = freeVecCount;
            leastFreeAtom = at; /* 11-Oct-2016 nm */
            highestNeighborCount = atomNeighbors[mappedAtom];
            /* Speedup: save the first vector to start at so we don't have to
               scan from beginning again */
            leastFreeFirstVec = firstVec;
/*D*//*printf("here2 leastFreeVecCount=%ld leastFreeAtom=%ld leastFreeFirstVec=%ld\n", */
/*D*//*        leastFreeVecCount, leastFreeAtom, leastFreeFirstVec);                   */
          }
/*D*//*if(numRetries)printf("conflict=%ld at=%ld vec=%ld lfvc=%ld\n",(long)conflict,mappedAtom,vec,leastFreeVecCount);*/
          /* Speedup: if there are no free vectors, stop scan since no other
             atom can have a smaller number of free vectors than 0 */
          if (leastFreeVecCount == 0) {
            /* leastFreeAtom should be nonzero here, even if
               leastFreeVecCount=0, which means an unassignable atom. */
            break;
          }
        } /* Next at (atom) */

        /* 12-Oct-2016 nm */
        /* In case all vectors are used up, leastFreeVecCount will never get
           assigned and will be at its initial value of vectors + 1. */
        if (leastFreeVecCount == vectors + 1) {
          /* Make sure other things are at their initial value as well */
          if (leastFreeAtom != 0 || leastFreeFirstVec != 0
              || firstVec != 0 ) {
            fprintf(stderr,
             "leastFreeVecCount=%ld leastFreeAtom=%ld leastFreeFirstVec=%ld\n",
                leastFreeVecCount, leastFreeAtom, leastFreeFirstVec);
            bug(27);
          }
          leastFreeVecCount = 0;
        }

        freeVecs[atomSeq] = leastFreeVecCount; /* For statistics */
        if (leastFreeVecCount > 0) {
/*D*//*printf("here3 leastFreeVecCount=%ld leastFreeAtom=%ld leastFreeFirstVec=%ld\n",*/
/*D*//*        leastFreeVecCount, leastFreeAtom, leastFreeFirstVec);*/
          if (leastFreeFirstVec == 0) bug(28);
          dynAtomMap[atomSeq] = leastFreeAtom; /* Assign the next atom to process */
          dynAtomRevMap[leastFreeAtom] = atomSeq;
          atomVec[atomMap[dynAtomMap[atomSeq]]] = leastFreeFirstVec;
          if (vecUsed[leastFreeFirstVec] != 0) bug(29);
          vecUsed[leastFreeFirstVec] = 1;
          availableVecs--;
/*D*/ /*
for(q=1;q<=3;q++)printf("%s,", sVecCoeff[atomVec[atomMap[dynAtomMap[atomSeq]]]][q]);
let(&extAtomName,"");
 extAtomName = extendedAtomName(atomMap[dynAtomMap[atomSeq]]);
printf(" atomSeq=%ld atomMap[dynAtomMap[atomSeq]]=%ld =%s\n",atomSeq,atomMap[dynAtomMap[atomSeq]],extAtomName);
printf("ff=1 atomSeq=%ld\n",atomSeq);
*/  /*D*/
          foundFlag = 1;  /* Cause an advance in the next iteration */
        } else {
          l4 = leastFreeAtom;
/*D*//*printf("btrack leastFreeAtom=%ld atomSeq=%ld dynAtomMap[atomSeq]=%ld\n",leastFreeAtom,atomSeq,dynAtomMap[atomSeq]);*/
          foundFlag = 0;  /* Cause a backtrack in the next iteration */
/*D*//*printf("ff=0\n");*/
        }
        continue; /* to while (1) (Redundant; just to help read the code.) */

      } else {  /* !foundFlag */
/*D*//*printf("!foundflag\n");*/
        /*weAreBacktracking = 1;*/

        mappedAtom = atomMap[dynAtomMap[atomSeq]];
        /* Deassign the current vector from this atom, if any */
        curVec = atomVec[mappedAtom];
        if (curVec > 0) {  /* It was assigned; we're backtracking, so deassign it */
          printf("curVec=%ld atomSeq=%ld\n", curVec, atomSeq);
          fflush(stdout);
          bug(30);  /* I don't think it should ever get here, but if it does
                         we should analyze what's happening */
          vecUsed[curVec] = 0;
          atomVec[mappedAtom] = 0;
        } else {
          /* It will get here when leastFreeVecCount = 0 and it backtracks */
          /* (which I think is always) */
        }
        /* Deassign current atom */
/*TODO: dynAtomMap[atomSeq]=0 when end of backtr, why?*/
        dynAtomRevMap[dynAtomMap[atomSeq]] = 0;
        dynAtomMap[atomSeq] = 0;

        /* We have exhausted possibilities, so we must backtrack */
        atomSeq--;
/*D*//*printf("atomSeq--=%ld\n",atomSeq);*/
        backtrackCountx++;
        globalBacktrackCountx++;
/*D*//*printf("atomSeq--=%ld backtrackCount++=%ld\n",atomSeq,backtrackCountx);*/
        if (atomSeq == 1) localHighestBacktrackx = 1; /* reset for status msg */
        if (atomSeq > localHighestBacktrackx) {
          localHighestBacktrackx = atomSeq;
          if (verboseMode
                && atomSeq != 0) {   /* Meaningless message when atomSeq = 0 */
            if (atomSeq > highestBacktrackx) {
/*D*//*printf("atomSeq=%ld highestBacktrackx=%ld\n",atomSeq,highestBacktrackx);*/
              printf(
                   "#%ld Assigned %ld atoms (out of %ld) before backtracking.\n",
                  /* 29-Aug-2016 nm */
                  lattices, atomSeq, goodAtoms);
              fflush(stdout);
            }
            if (dynamicAtomAssignment && atomSeq >= highestBacktrackx) {
              /* In static mode, the freeVecs() array has incomplete counts
                 to save run time speed */
/*D*//*p=0;for(q=1;q<=vectors;q++)if(!vecUsed[q])p++;printf("here5 p=%ld\n",p);*/
              j = 0;
              for (q = 1; q <= vectors; q++) {
                /* Count available vectors for user printout */
                if (vecUsed[q] == 0) j++;
              }
              if (j != availableVecs) bug(31); /* TODO: just use availableVecs*/
              printf(
"#%ld %ld local backtracks; number of vector assignments remaining to test:\n",
                  lattices, backtrackCountx);
              printf("#%ld", lattices);
              if (atomSeq == 0) {
                printf("  0\n");
              } else {
                for (i = 1; i < atomSeq; i++) {
                  printf("%s%ld", ((i == 1) ? "  " : "*"), freeVecs[i]);
                }
                /* TODO? When j=0, we get "*0^2" etc.  But why are we
                   still in program if j=0, several iterations before end?
                   Temporarily suppressed j=0 printout to lessen confusion. */
                if (j != 0) {
                  /*printf(",...(%ld more)\n", goodAtoms - atomSeq + 1);*/
                  printf("*(%ld^%ld)\n", j, goodAtoms - atomSeq + 1);
                } else {
                  printf("\n");
                }
              }
            }
            fflush(stdout);
          }
        }
        if (atomSeq > highestBacktrackx) {
/*D*//*if(numRetries)printf("at=%ld vec=%ld atomSeq=%ld highestBacktrackx=%ld\n",mappedAtom,vec,atomSeq,highestBacktrackx);*/
          highestBacktrackx = atomSeq;

          /* 29-Aug-2016 nm */
          /* Save largest the partial assignment for the failure message */
          for (i = 1; i <= atoms; i++) {
            saveAtomVec[i] = atomVec[i];
          }
          /* Clear the last assignment (that was unsuccessful) */
          /* 29-Aug-2016 nm */
          /* Actually, the last assignment is "good", it just means that it
             couldn't go further */
          /* saveAtomVec[dynAtomMap[atomSeq]] = 0;*/

          /* Save the atom that is impossible to assign - we will
             assign it to zeroVec before restarting */
          if (l4 != leastFreeAtom) bug(32);
              /* If this bug never shows up, we should be able to replace
                 l4 with leastFreeAtom to simplify code slightly */
          saveUnassignableAtom = atomMap[l4]; /* l4 is temp var from above */
/*D*//*printf("l4=%ld atomMap[l4]=%ld saveUnassignableAtom=%ld\n",l4,atomMap[l4],saveUnassignableAtom);*/
          if (atomVec[saveUnassignableAtom] != 0) bug(33);
        }
        if (atomSeq == 0) {
          successFlag = 0; /* No good assignment is possible */
          break;
        }
        if (backtrackLimit != 0 && globalBacktrackCountx >= backtrackLimit) {
          successFlag = 0; /* Timeout */
          break;
        }
        /* We are backtracking and atomSeq was decremented, so
           we should have an atom assigned for this atomSeq */
        if (dynAtomMap[atomSeq] <= 0) {
          printf("n=%ld dynAtomMap[n]=%ld\n", atomSeq, dynAtomMap[atomSeq]);
          fflush(stdout);
          bug(34);
        }
        /* We should have a vector assigned that we'll increment */
        curVec = atomVec[atomMap[dynAtomMap[atomSeq]]];
        if (curVec == 0) {
          bug(35);  /* An earlier atom must be assigned */
        }
        /* Deassign it to prepare for next iteration of loop below */
        atomVec[atomMap[dynAtomMap[atomSeq]]] = 0;
        if (vecUsed[curVec] == 0) bug(36);
        vecUsed[curVec] = 0;
        availableVecs++;

        /* Get the next vector that can be assigned to atom backtracked to */
        for (i = curVec + 1; i <= vectors; i++) {

          /* 17-Jun-2016 nm */
          /* Speed up: if there are no free vectors, bypass this loop and
             go right into backtrack */
    /*
          if (leastFreeVecCount == 0) {
            conflict = 1;
            break;
          }
    */

          if (vecUsed[i] == 1) continue;
          /* If it is not a "labeled" atom, we can only select from
             the unlabeled vectors */
          if (i > unlabeledVectors) {
            if (dims != 3 || noKick == 0) bug(37);
            /* The criterion for "labeled" is = 1 block, so if > 1 blocks
               then exit the loop since we can't use
               unlabeledVectors + 1 <= i <= vectors */
            if (atomBlocks[atomMap[dynAtomMap[atomSeq]]] > 1) break;
          }
          /* Check to make sure this vector is compatible with the atom's
             (lower-numbered) neighbors */
          conflict = 0;
          for (j = 1; j <= atomNeighbors[atomMap[dynAtomMap[atomSeq]]]; j++) {
            if (atomVec[atomNeighbor[atomMap[dynAtomMap[atomSeq]]][j]] == 0) {
              /* Not assigned yet */
              continue;
            }
            /* Check to see if the scalar product of the neighboring vector
               is zero (this is the key criterion) */
            /*
            if (vecProdNonzero[i]
                   [atomVec[atomNeighbor[atomMap[dynAtomMap[atomSeq]]][j]]]
                != 0) {
            */
            /* 11-Jan-2017 nm */
            if ((slowMode == 0
                ?
                /* Fast (table lookup) */
                vecProdNonzero[i]
                    [atomVec[atomNeighbor[atomMap[dynAtomMap[atomSeq]]][j]]]
                :
                /* Slow (no table memory needed) */
                innerProductNonzero(cVecCoeff[i],
                    cVecCoeff[atomVec[atomNeighbor[atomMap[
                        dynAtomMap[atomSeq]]][j]]],
                    dims, maxError)
                ) != 0) {
              /* Collision */
              conflict = 1;
              break;
            }
          }
          if (!conflict) {
            /* Found a good assignment */
            if (vecUsed[i] != 0) bug(38);
            vecUsed[i] = 1;
            availableVecs--;
            atomVec[atomMap[dynAtomMap[atomSeq]]] = i;
            foundFlag = 1;
            freeVecs[atomSeq]--;  /* For statistics only */
            break;
          }
        } /* next curVec */
      } /* if !foundFlag i.e. if we need to backtrack */

    } /* while 1 */
/*D*//*printf("end of while  successFlag=%ld\n",(long)successFlag);*/

    if (keepTryingAfterFail == 0) {
      if (!successFlag) {
        /* Transfer the best assignment found so far */
        for (i = 1; i <= atoms; i++) {
          atomVec[i] = saveAtomVec[i];
        }
      }
      break;  /* Early exit for speed */
    }

    if (backtrackLimit != 0 && globalBacktrackCountx >= backtrackLimit) break;
                                                   /* Timeout */
    if (numRetries == 0) {
      if (successFlag == 1) {
        /* If success is achieved on first pass, it is real, so break
           out of while loop.  On later passes, successFlag may not be
           meaningful since we are forcing it to continue past an
           unassignable vertex. */
        break;
      }
      realSuccessFlag = successFlag; /* TODO - delete realSuccessFlag */
    } else {
      /* The first "while" iteration failed, and we're in a later one */
      if (successFlag == 1) {
        /* This means all vertices got assigned on this subsequent iteration,
           but only because we froze unassignable ones with an
           assingment to zeroVec.  So we're done, but the actual
           status is fail. */
        successFlag = 0;
        break;
      }
    }
    numRetries++;
    if (verboseMode == 1) {
      printf("#%ld Start retry #%ld...\n", lattices, numRetries);
      fflush(stdout);
    }

/*D*//*printf("unfrozen before=%ld\n",numFrozenAtoms);*/
    /* Clear vecUsed to prepare for next pass */
    for (i = 1; i <= vectors; i++) {
      if (vecUsed[i] != 0) {
        if (vecUsed[i] != 1) {
          printf("i=%ld vecUsed[i]=%ld\n", i, (long)(vecUsed[i]));
          fflush(stdout);
          bug(39); /* Check for corrupted vecUsed array */
        }
        vecUsed[i] = 0;
      }
    }
    availableVecs = vectors;
    /* Assign the longest backtrack found for next pass */
    for (i = 1; i <= atoms; i++) {
      atomVec[i] = saveAtomVec[i];
      if (atomVec[i] != 0 && frozenVec[i] == 0) {
        /* This is a new assignment; freeze it for the next outermost
           loop pass */
        frozenVec[i] = atomVec[i];
        numFrozenAtoms++;
      }
      /* Rebuild the vecUsed array to be what it was at the deepest
         backtrack */
      if (atomVec[i] != 0 && atomVec[i] != zeroVec) {
        if (vecUsed[atomVec[i]] == 0) {
          vecUsed[atomVec[i]] = 1;
          availableVecs--;
        } else {
          /* A vector used twice */
          printf("i=%ld atomVec[i]=%ld\n", i, atomVec[i]);
          fflush(stdout);
          bug(40);
        }
      }
    }

/*D*//*printf("unfrozen mid=%ld\n",numFrozenAtoms);*/
    if (saveUnassignableAtom != 0) {
      /* Freeze the unassignable atom that caused the backtrack */
      atomVec[saveUnassignableAtom] = zeroVec;
      frozenVec[saveUnassignableAtom] = zeroVec;
      /* vecUsed[zeroVec] = 1; */ /* Unnecessary */
      numFrozenAtoms++;
    }
/*D*//*printf("unfrozen aft=%ld\n",numFrozenAtoms);*/
  } /* while 1 - outermost loop to keep trying past unassignable atoms */

  /******* End of outermost loop to skip bad atoms and restart scan *******/

  /* backtrackCount is for informational purposes */
  /*if (!oneLineDisplay) printf("Backtrack count = %ld\n", backtrackCountx);*/
  *backtrackCount = globalBacktrackCountx;  /* return argument */
  *highestBacktrack = highestBacktrackx;  /* return argument */


  /******* Print the output *******/

 /*print_point:*/  /* See goto above */
  /* 29-Aug-2016 nm */
  /*** done above
  if (!successFlag) {
    /@ Transfer the best assignment found so far @/
    for (i = 1; i <= atoms; i++) {
  /@D@//@printf("i=%ld atomVec[i]=%ld saveAtomVec[i]=%ld\n",i,atomVec[i],saveAtomVec[i]);@/
      atomVec[i] = saveAtomVec[i];
    }
  }
  *****/
  j = 0;
  for (i = 1; i <= atoms; i++) {
    /* Count the number of assigned vertices */
    if (atomVec[i] > 0 && atomVec[i] != zeroVec) {
      j++;
    }
  }
  k = 0;
  for (i = 1; i <= atoms; i++) {
    /* Count the number of assignable vertices */
    if (atomBlocks[i] != 1 || noKick != 0
        /* In case of preassignment to isolated (kicked) vertex */
        || (atomVec[i] > 0 && atomVec[i] != zeroVec)) {
      k++;
    }
  }
  printf("#%ld", lattices);
  if (!successFlag) {
    /* i = (100 * (highestBacktrackx - 1)) / atoms; */
    /* 29-Aug-2016 nm */
    /* i = (100 * (highestBacktrackx + numFrozenAtoms)) / goodAtoms; */
    i = (100 * j) / k;
    let(&str1, cat(left("00", 2 - (long)strlen(str((double)i))),
        str((double)i), NULL));
    /* printf("(%ld/%ld=0%s%s%s)", highestBacktrackx - 1, atoms, */
    /* 29-Aug-2016 nm */
    printf("(%ld/%ld=0%s%s%s)", j/* assigned*/, k/* assignable */,
        "%", str1, "%");
  }
  if (backtrackLimit != 0 && globalBacktrackCountx >= backtrackLimit) {
    printf("timeout%ld:: ", backtrackLimit);
  } else {
    printf(" %s:: ", successFlag ? "pass" : "fail");
  }
  /* Print stripped MMP diagram */
  for (i = 1; i <= blocks; i++) {
    for (j = 1; j <= blockSize[i]; j++) {
      /* 8-Oct-2016 nm Don't suppress printout of "kicked" atoms
         unless -nksup */
      if (atomBlocks[block[i][j]] == 1 && noKick == 0 && nkSuppressPrint == 1)
        continue;
      /* printf("%c", ATOM_MAP[block[i][j] - 1]); */
      let(&extAtomName, "");
      extAtomName = extendedAtomName(block[i][j]);
      printf("%s", extAtomName);
      /* Print "*" to "label" atom that wasn't kicked out */
      /*if (atomBlocks[block[i][j]] == 1 && noKick == 1*/
      /* 8-Oct-2016 nm ...or is kicked out in -nk mode */
      if (atomBlocks[block[i][j]] == 1 /*&& noKick == 1*/
          && nkAsterisks == 1 /* 31-Aug-2016 nm */
          )  {
        printf("*");
      }
    }
    printf("%c", i < blocks ? ',' : '.');
  }


  if (/*successFlag*/ i == i + 0 /* 29-Aug-2016 */) {
    /* Print vectors */
    printf("{");

    if (orthogonalBlockDisplay
        /* 29-Aug-2016 nm */
        && successFlag /* Failure prints assigned atoms only */) {

      /* This is the old-style display that prints the vectors in blocks
         matching the block atoms in the MMP diagram.  Use the -ob qualifier
         to invoke this display mode. */
      for (i = 1; i <= blocks; i++) {
        printf("{");
        for (j = 1; j <= blockSize[i]; j++) {
          if (atomBlocks[block[i][j]] == 1 && noKick == 0) continue;
          printf("{");
          for (k = 1; k <= dims; k++) {
            printf("%s", sVecCoeff[atomVec[block[i][j]]][k]);
            printf("%c", k < dims ? ',' : '}');
          }
        }
        printf("}");
      }

    } else {

      firstItemPrinted = 0;

      /* This is the new style per mp/nm email of 27-Feb-04, where each
         vector is displayed only once in atom order 123...ABC...abc... */
      for (j = 1; j <= atoms; j++) {
        /*
        if (atomBlocks[j] == 1 && noKick == 0) {
          /@ Skip atoms in only 1 block @/
          if (atomVec[j] != 0) {
            bug(41);
          }
          continue;
        }
        */
        if (atomVec[j] == zeroVec) continue;

        /* 29-Aug-2016 nm */
        /* Skip unassigned atoms in best assignment found so far */
        if (atomVec[j] == 0) {
          if (successFlag) bug (1010);
          continue;
        }

        /* 29-Aug-2016 nm */
        /*
        if (!successFlag) {
        */
        /* 13-Jan-2017 nm We now print atom names before every vector
           even for "pass:: " diagrams */
        if (successFlag == successFlag + 0) {
          if (firstItemPrinted) {
            printf(",");  /* Comma before 2nd or later vector */
          } else {
            firstItemPrinted = 1;
          }
          /* Print the atom name */
          let(&extAtomName, "");
          extAtomName = extendedAtomName(j);

          /* If the atom name has "{", change it to "." (which is not
             a legal atom name) to prevent ambiguity with start of vector.
             The code above that reads the atom name will convert back. */
          k = (long)strlen(extAtomName) - 1;
          if (extAtomName[k] == '{') extAtomName[k] = '.';

          printf("%s=", extAtomName);
        }

        printf("{");

        for (k = 1; k <= dims; k++) {
          printf("%s", sVecCoeff[atomVec[j]][k]);
          printf("%c", k < dims ? ',' : '}');
        }
      }

    }

    printf("}");
  }
  printf("\n");
  fflush(stdout);
 RETURN_POINT:
  /* Deallocate memory */
  let(&str1, "");
  let(&str2, "");
  let(&str3, "");
  let(&str4, "");
  let(&str5, "");
  let(&str6, "");
  let(&str7, "");
  let(&extAtomName, "");
  let(&sVec, "");
  let(&sFrozenAtom, "");

  return successFlag;
} /* findVectorAssignment */


/* Convert a string expression to a complex number */
/* Multiplication is expressed with either juxtaposition or explicitly
   with "*", so 2(5) = (2)5 = 2*5 = 10.  The other operations available are
   addition "+", subtraction "-", division "/", and exponentiation "^".
   Unary plus and minus are also expressed with "+" and "-".  The imaginary
   constant is "i"; 2i = i2 = i*2.  Square roots are expressed with "sqr";
   sqr4 = sqr(4) = 2; sqrsqr16 = sqr(sqr(16)) = 2. Spaces and tabs are
   ignored.  Addition, subtraction, unary plus, and unary minus have lower
   binding strength than multiplication and division, which are evaluated
   left to right:  5/2*3 = (5/2)*3.  Exponentiation has higher binding
   strength:  5*2^2 = 5*(2^2) and -2^2 = -(2^2).  Nested exponentiation
   requires parenthesis to eliminate ambiguity:  2^2^2 is undefined; use
   2^(2^2) or (2^2)^2.  Square root has the highest binding strength:
   sqr2^2 = (sqr2)^2; sqr-1 is undefined, use sqr(-1) = i.  Built-in
   constants: i, e, pi, phi */
long double complex stringToComplex(vstring strExprBuf) {
  long double complex sumOfTerms = 0;
  long double complex term = 1;
  long double complex partTerm = 1;
  long double complex savePartTerm = 0;
  long double complex deciAccum = 0;
  long double complex deciPointMode = 0;
  long double complex deciPointPower = 1;
  long double complex digit;
  long slen, p, q, n;
  char c;
  char deciMode = 0;
  long sqrtMode = 0; /* Counts number of nested square roots */
  char divMode = 0; /* This is what really determines whether div or mul */
  char mulMode = 0; /* Only for error msgs when user has * w/out 2nd arg */
  char expMode = 0;
  char startTermFlag = 1;
  vstring strExpr = "";
  vstring strExp1 = "";
  vstring strPart = "";
  static vstring strPrint = ""; /* Original expression for recursive call */

  /* 16-Nov-2017 nm */
  /* Buffer the input argument in case it's temporarily allocated from
     left(), entry(), etc. */
  let(&strExpr, strExprBuf);

  if (!strcmp(strPrint, "")) {
    /* Assign the original expression for use by error messages.  It is
       static so that recursive calls can use it. */
    let(&strPrint, strExpr);
  }
  let(&strExp1, edit(strExpr, 2/*delete spaces*/ + 64/*[,] to (,)*/
      + 512/*upper-case to lower*/));
  while (1) {
    /* Change all "sqrt" to the letter "s" */
    p = instr(1, strExp1, "sqrt");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p), right(strExp1, p + 4), NULL));
  }
  while (1) {
    /* Change all "sqr" to the letter "s" */
    p = instr(1, strExp1, "sqr");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p), right(strExp1, p + 3), NULL));
  }
  while (1) {
    /* Change all "pi" to the letter "p" */
    p = instr(1, strExp1, "pi");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p), right(strExp1, p + 2), NULL));
  }
  while (1) {
    /* Change all "phi" to the letter "k" */
    p = instr(1, strExp1, "phi");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p - 1), "k", right(strExp1, p + 3), NULL));
  }
  /* 3-Dec-2016 nm */
  while (1) {
    /* Change all "omega" to the letter "w" */
    p = instr(1, strExp1, "omega");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p - 1), "w", right(strExp1, p + 5), NULL));
  }
  /* Prefix and suffix with dummy terms "0" to simplify algorithm,
     where + or - signifies the end of a term */
  /* (The prefix 0 will be added; the suffix 0 will be ignored) */
  let(&strExp1, cat("0+", strExp1, "+0", NULL));
  while (1) {
    /* Change all "+-", "-+" to "-" */
    p = instr(1, strExp1, "+-");
    if (p == 0) p = instr(1, strExp1, "-+");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p - 1), "-", right(strExp1, p + 2), NULL));
  }
  while (1) {
    /* Change all "++", "--" to "+" */
    p = instr(1, strExp1, "++");
    if (p == 0) p = instr(1, strExp1, "--");
    if (p == 0) break;
    let(&strExp1, cat(left(strExp1, p - 1), "+", right(strExp1, p + 2), NULL));
  }
  slen = (long)strlen(strExp1);
  for (p = 0; p < slen; p++) {
    /* Check for unimplemented operations */
    c = strExp1[p];
    if (c < '0' || c > '9') {
      /*if (strchr("*.si+-/()^epk", c) == NULL) {*/
      /* 3-Dec-2016 nm */
      if (strchr("*.si+-/()^epkw", c) == NULL) {
/*D*/printf("slen=%ld c=%ld p=%ld\n",slen,(long)c,p);
        fprintf(stderr, "?Error: Unrecognized operation \"%c\" in \"%s\"\n",
            c, strPrint);
      }
    }
  }

/*D*//*printf("strExpr=%s strExp1=%s\n",strExpr,strExp1);*/
  for (p = 0; p < slen; p++) {
/*D*//*printf("p=%ld sumOfTerms = %LG + i%LG\n",p, creall(sumOfTerms), cimagl(sumOfTerms));*/
    if (strExp1[p] == '.') {
      /* Handle decimal point */
      if (deciPointMode == 1) {
        fprintf(stderr, "?Error: Two decimal points in a number in \"%s\"\n", strPrint);
        continue;
      }
      if (deciMode == 0) {
        deciMode = 1; /* In case number starts w/ decimal point */
        deciAccum = 0;
      }
      deciPointMode = 1;
      deciPointPower = 1;
      continue;
    }
    if (deciMode == 1) {
      if (strExp1[p] < '0' || strExp1[p] > '9') {
        /* Process completion of a number */
        deciMode = 0;
        deciPointMode = 0;
        partTerm = deciAccum;
        if (sqrtMode > 0) {
          /* Square root has highest priority; exhaust any built up chain
             of square roots */
          while (sqrtMode > 0) {  /* Loop to handle nested square roots */
            partTerm = csqrtl(partTerm);
            sqrtMode--;
          }
        }
        if (strExp1[p] == '^') {
          if (expMode == 1) {
            fprintf(stderr, "?Error: Use parentheses for double exponentiation\n");
          }
          /* Look ahead to see if exponentiation (higher priority) is next.
             If we are already in expMode, we can complete the exp operation. */
          savePartTerm = partTerm;
        } else {
          /* First process exponentiation, then finish uncompleted
             multiplication or division */
          if (expMode == 1) {
            partTerm = cpowl(savePartTerm, partTerm);
            expMode = 0;
          }
          if (divMode == 1) {
            if (partTerm == 0) {
              fprintf(stderr, "?Error: Division by 0 in \"%s\"\n", strPrint);
            } else {
              term = term / partTerm;
            }
            divMode = 0;
          } else {
            term = term * partTerm;
            mulMode = 0;
          }
        } /* if (strExp1[p + 1] == '^') */
        deciAccum = 0;
      } /* if (strExp1[p] < '0' || strExp1[p] > '9') */
      startTermFlag = 0; /* Set indicator that the term is not empty */
    } /*  if (deciMode == 1) */
    if (strExp1[p] == '+' || strExp1[p] == '-') {
      if (sqrtMode > 0) {
        fprintf(stderr, "?Error: Square root has no argument in \"%s\"\n", strPrint);
        term = 0;
        sqrtMode = 0;
      }
      if (divMode == 1) {
        fprintf(stderr, "?Error: Division has no second argument in \"%s\"\n", strPrint);
        term = 0;
        divMode = 0;
      }
      if (mulMode == 1) {
        fprintf(stderr, "?Error: Multiplication has no second argument in \"%s\"\n",
            strPrint);
        term = 0;
        mulMode = 0;
      }
      if (expMode == 1) {
        fprintf(stderr, "?Error: Exponentiation has no second argument in \"%s\"\n",
            strPrint);
        term = 0;
        expMode = 0;
      }
      /* End of term; add to sumOfTerms */
      sumOfTerms = sumOfTerms + term;
      /* Initialize term value for next term */
      if (strExp1[p] == '-') {
        term = -1;
      } else {
        term = 1;
      }
      startTermFlag = 1; /* For error checking missing arguments */
      deciMode = 0;
      deciPointMode = 0;
    }
    if (strExp1[p] == 'i' || strExp1[p] == 'e' || strExp1[p] == 'p'
        || strExp1[p] == 'k'
        /* 3-Dec-2016 nm */
        || strExp1[p] == 'w'
        ) {
      switch (strExp1[p]) {
        case 'i': partTerm = I; break;    /* sqrt(-1) */
        case 'e': partTerm = cexpl(1); break;  /* e */
        case 'p': partTerm = 4 * catanl(1); break;  /* pi */
        /* phi = (1 + sqr(5))/2 */
        case 'k': partTerm = (1 + csqrtl(5))/2; break;  /* phi */
        /* 3-Dec-2016 nm */
        /* omega = e^(2*pi*i/3) */
        case 'w': partTerm = cexpl(2 * (4 * catanl(1)) * I / 3); break;  /* omega */
      }
      if (sqrtMode > 0) {
        while (sqrtMode > 0) {  /* Loop to handle nested square roots */
          partTerm = csqrtl(partTerm);
          sqrtMode--;
        }
      }
      if (strExp1[p + 1] == '^') {
        if (expMode == 1) {
          fprintf(stderr, "?Error: Use parentheses for double exponentiation\n");
        }
        /* Look ahead to see if exponentiation (higher priority) is next.
           If we are already in expMode, we can complete the
           previous exponentiation operation. */
        savePartTerm = partTerm;
      } else {
        /* First process exponentiation, then finish uncompleted
           multiplication or division */
        if (expMode == 1) {
          partTerm = cpowl(savePartTerm, partTerm);
          expMode = 0;
        }
        if (divMode == 1) {
          if (partTerm == 0) {
            fprintf(stderr, "?Error: Division by 0 in \"%s\"\n", strPrint);
          } else {
            term = term / partTerm;
          }
          divMode = 0;
        } else {
          term = term * partTerm;
          mulMode = 0;
        }
      } /* if (strExp1[p + 1] == '^') */
      startTermFlag = 0; /* Set indicator that the term is not empty */
      continue;
    }
    if (strExp1[p] == 's') {
      sqrtMode++;  /* Increment nesting level of square roots */
      startTermFlag = 0; /* Set indicator that the term is not empty */
      continue;
    }
    if (strExp1[p] == '/') {
      if (startTermFlag == 1) {
        fprintf(stderr, "?Error: Division has no first argument in \"%s\"\n", strPrint);
      }
      divMode = 1;
      continue;
    }
    if (strExp1[p] == '^') {
      if (startTermFlag == 1) {
        fprintf(stderr, "?Error: Exponentiation has no first argument in \"%s\"\n",
            strPrint);
      }
      expMode = 1;
      continue;
    }
    if (strExp1[p] == '*') {
      if (startTermFlag == 1) {
        fprintf(stderr, "?Error: Multiplication has no first argument in \"%s\"\n",
            strPrint);
      }
      mulMode = 1;
      /* An optional "times" just completes any previous number as in 3*4,
         since juxtaposition is the normal "times" */
      continue;
    }
    if (strExp1[p] == '(') {
      n = 1;
      for (q = p + 1; q < slen; q++) {
        if (strExp1[q] == '(') n++;
        if (strExp1[q] == ')') n--;
        if (n == 0) {
          let(&strPart, seg(strExp1, p + 2, q));
          /* Recursive call to process parenthesized subexpression */
/*D*//*printf("Recursive call...\n");*/
          partTerm = stringToComplex(strPart);
          break;
        }
      }
      p = q; /* Skip over parenthesized subexpression - note that we don't
            assign p to q+1 because the end of loop will increment it */
      if (n != 0) {
        fprintf(stderr, "?Error: Too few closing parentheses in \"%s\"\n", strPrint);
        continue;
      }
      if (sqrtMode > 0) {
        while (sqrtMode > 0) {  /* Loop to handle nested square roots */
          partTerm = csqrtl(partTerm);
          sqrtMode--;
        }
      }
/*D*//*printf("partTerm = %LG + i%LG\n",creall(partTerm), cimagl(partTerm));*/
/*D*//*printf("here p=%ld %c partTerm = %LG + i%LG\n",p,strExp1[p], creall(partTerm), cimagl(partTerm));*/
      if (strExp1[p + 1] == '^') {
        if (expMode == 1) {
          fprintf(stderr, "?Error: Use parentheses for double exponentiation\n");
        }
        savePartTerm = partTerm;
      } else {
        /* First process exponentiation, then finish uncompleted
           multiplication or division */
        if (expMode == 1) {
          partTerm = cpowl(savePartTerm, partTerm);
          expMode = 0;
        }
        if (divMode == 1) {
          if (partTerm == 0) {
            fprintf(stderr, "?Error: Division by 0 in \"%s\"\n", strPrint);
          } else {
            term = term / partTerm;
          }
          divMode = 0;
        } else {
          term = term * partTerm;
          mulMode = 0;
        }
      } /* if (strExp1[p + 1] == '^' */
/*D*//*printf("p=%ld term = %LG + i%LG\n",p,creall(term), cimagl(term));*/
      startTermFlag = 0; /* Set indicator that the term is not empty */
      continue;
    }

    if (strExp1[p] == ')') {
      fprintf(stderr, "?Error: Too many closing parentheses in \"%s\"\n", strPrint);
      continue;
    }
    if (strExp1[p] < '0' || strExp1[p] > '9') {
      if (sqrtMode > 0) {
        fprintf(stderr, "?Error: No square root argument in \"%s\"\n", strPrint);
      }
      if (divMode == 1) {
        fprintf(stderr, "?Error: No number after division in \"%s\"\n", strPrint);
      }
      if (mulMode == 1) {
        fprintf(stderr, "?Error: No number after multiplication in \"%s\"\n", strPrint);
      }
    }
    if (strExp1[p] >= '0' && strExp1[p] <= '9') {
      /* Process a digit */
      digit = (long double complex)(strExp1[p] - '0');
      if (deciMode == 0) {
        deciMode = 1;
        deciAccum = 0;
      }
      if (deciPointMode == 0) {
        deciAccum = (10 * deciAccum) + digit;
      } else {
        deciPointPower = 10 * deciPointPower;
        deciAccum = deciAccum
            + digit / deciPointPower;
      }
    }
  } /* next p */

  if (!strcmp(strPrint, strExpr)) {
    /* This is topmost level of recursive calls, so clear strPrint */
    let(&strPrint, "");
  }
  /* Deallocate memory */
  let(&strExpr, "");
  let(&strExp1, "");
  let(&strPart, "");
  return sumOfTerms;
} /* stringToComplex */


/* Returns 1 if vectors are proportional, 0 otherwise */
char vecProportional(long double complex *v1, long double complex *v2,
    long dims, long double maxErr) {
  long d, dref;
  dref = -1;
  for (d = 1; d <= dims; d++) {
/*D*//*printf("d=%ld %LG %LG me=%LG\n",d,cabsl(v1[d]),cabsl(v2[d]),maxErr);*/
    /* If components are not both zero or nonzero, the vectors aren't
       proportional */
    if (cabsl(v1[d]) <= maxErr && cabsl(v2[d]) > maxErr) return 0;
    if (cabsl(v1[d]) > maxErr && cabsl(v2[d]) <= maxErr) return 0;
    /* Get the first nonzero component as a reference */
    if (dref == -1) {
      if (cabsl(v1[d]) > maxErr) dref = d;
    }
  }
/*D*//*printf("dref=%ld\n",dref);*/
  if (dref == -1) return 1; /* All components of both vectors are 0 */
  for (d = dref + 1; d <= dims; d++) {
    if (cabsl((v1[d] / v1[dref]) - (v2[d] / v2[dref])) > maxErr) {
      /* When normalized, the components differ */
      return 0;
    }
  }
  return 1;
} /* vecProportional */


/* Returns 1 if vectors are equal, 0 otherwise */
/* This should run faster than vecProportional().  It assumes
   vecStandardize() has been called for each vector to standardize them */
char vecEqual(long double complex *v1, long double complex *v2,
    long dims, long double maxErr) {
  long d;

  /* 10-Jan-2017 nm */
  /* Location 0, otherwise unused, holds a function analogous to a hashcode
     for faster rejection of non-equal vectors */
  /* Location 0 is assigned in vecStandardize() */
  if (cabsl(v1[0] - v2[0]) > maxErr) {
/*D*//*if (cabsl(v1[0] - v2[0]) < 1000 * maxErr)*/
/*D*//*printf("veq %LG %LG me=%LG me=%LG\n",cabsl(v1[0]),cabsl(v2[0]),cabsl(v1[0] - v2[0]),maxErr);*/
    return 0;
  }

  for (d = 1; d <= dims; d++) {
    if (cabsl(v1[d] - v2[d]) > maxErr) return 0;
  }
  return 1;
} /* vecEqual */


/* 10-Jan-2017 nm */
/* Puts vector in a standardized form with first non-zero component = 1 */
void vecStandardize(long double complex *v, long dims, long double maxErr) {
  long d, dref;
  dref = -1;
  for (d = 1; d <= dims; d++) {
    if (dref == -1) {
      if (cabsl(v[d]) > maxErr) {
        /* First nonzero component (within maxErr) */
        dref = d;
      }
    } else {
      v[d] = v[d] / v[dref]; /* Divide remaining components by first nonzero */
    }
  }
  v[dref] = 1;  /* First nonzero component */

  /* 10-Jan-2017 nm */
  /* Location 0, otherwise unused, holds a function analogous to a hashcode
     for faster rejection of non-equal vectors */
  /* Here we compute that function (it is arbitrary and can be any function
     of the vectors we want).  The computation doesn't have to be fast; what
     should be fast is the comparison in vecEqual(). */
  v[0] = 0;
  for (d = 1; d <= dims; d++) {
    v[0] = v[0] + (long double)d * v[d];
  }

  return;
}


/* Added 11-Jan-2017 nm */
/* Get a measure of "badness" of a long vector string; e.g. "1+1" is worse
   than "2", and "(3,3,3)" is worse than "(1,1,1)". */
long vecStringWeight(long vec, vstring (*sVecCoeff)[MAX_DIMS + 1],
    long dims) {
  long w = 0;
  long double c = 0;
  long i;
  for (i = 1; i <= dims; i++) {
    c += cabsl(stringToComplex(sVecCoeff[vec][i]));
    c += (long double)strlen(sVecCoeff[vec][i]);
  }
  w = (long)c;
  return w;
}


/* Added 11-Jan-2017 nm */
/* Returns 1 if inner product of 2 vectors is nonzero, 0 otherwise */
char innerProductNonzero(long double complex *v1, long double complex *v2,
    long dims, long double maxErr) {
  long d;
  long double complex cVecProduct;
  cVecProduct = 0;
  for (d = 1; d <= dims; d++) {
      cVecProduct += v1[d] * conjl(v2[d]);
  }
  /* Return 0 if inner product is zero */
  if (cabsl(cVecProduct) <= maxErr) {
    return 0;
  } else {
    return 1;
  }
}


/* Added 28-Dec-2016 nm, taken from mmpstrip.c and changed to char */
/* Allocate a 2-dimensional long integer matrix */
char **alloc2DCharMatrix(long xsize, long ysize)
{
  char **matrix;
  long i;
  matrix = malloc(((size_t)xsize) * sizeof(char *));
  if (matrix == NULL) {
    printf("?ERROR Out of memory\n");
    fflush(stdout);
    exit(-1);
  }
  for (i = 0; i < xsize; i++) {
    matrix[i] = malloc(((size_t)ysize) * sizeof(char));
    if (matrix[i] == NULL) {
      printf("?ERROR Out of memory\n");
      fflush(stdout);
      exit(-1);
    }
  }
  return matrix;
}


/* Free a 2-dimensional long integer matrix */
void free2DCharMatrix(char **matrix, long xsize /*, long ysize*/)
{
  long i;
  for (i = xsize - 1; i >= 0; i--) {
    if (matrix[i] == NULL) bug(301);
    free(matrix[i]);
  }
  if (matrix == NULL) bug(302);
  free(matrix);
  return;
}


/* Allocate a 3-dimensional character matrix */
char ***alloc3DCharMatrix(long xsize, long ysize, long zsize)
{
  char ***matrix;
  long i, j;
  matrix = malloc(((size_t)xsize) * sizeof(char **));
  if (matrix == NULL) {
    printf("?ERROR Out of memory\n");
    fflush(stdout);
    exit(-1);
  }
  for (i = 0; i < xsize; i++) {
    matrix[i] = malloc(((size_t)ysize) * sizeof(char *));
    if (matrix[i] == NULL) {
      printf("?ERROR Out of memory\n");
      fflush(stdout);
      exit(-1);
    }
    for (j = 0; j < ysize; j++) {
      matrix[i][j] = malloc(((size_t)zsize) * sizeof(char));
      if (matrix[i][j] == NULL) {
        printf("?ERROR Out of memory\n");
        fflush(stdout);
        exit(-1);
      }
    }
  }
  return matrix;
}

/* Free a 3-dimensional character matrix */
void free3DCharMatrix(char ***matrix, long xsize, long ysize /*, long zsize*/)
{
  long i, j;
  for (i = xsize - 1; i >= 0; i--) {
    for (j = ysize - 1; j >= 0; j--) {
      if (matrix[i][j] == NULL) bug(303);
      free(matrix[i][j]);
    }
    if (matrix[i] == NULL) bug(304);
    free(matrix[i]);
  }
  if (matrix == NULL) bug(305);
  free(matrix);
  return;
}



/* Added 10/10/02 */
/* This function returns a character string containing the entire contents of
   an ASCII file, or Unicode file with only ASCII characters.   On some
   systems it is faster than reading the file line by line.  The caller
   must deallocate the returned string.  If a NULL is returned, the file
   could not be opened or had a non-ASCII Unicode character or some other
   problem.   If verbose is 0, error and warning messages are suppressed. */
vstring readFileToString(vstring fileName, char verbose) {
  FILE *inputFp;
  long fileBufSize;
  long charCount;
  char *fileBuf;
  long i, j;

  /* Find out the upper limit of the number of characters in the file. */
  /* Do this by opening the file in binary and seeking to the end. */
  inputFp = fopen(fileName, "rb");
  if (!inputFp) {
    if (verbose) fprintf(stderr,
        "?Sorry, couldn't open the file \"%s\".\n", fileName);
    return (NULL);
  }
#ifndef SEEK_END
/* An older GCC compiler didn't have this ANSI standard constant defined. */
#define SEEK_END 2
#endif
  if (fseek(inputFp, 0, SEEK_END)) bug(42);
  fileBufSize = ftell(inputFp);

  /* Close and reopen the input file in text mode */
  /* Text mode is needed for VAX, DOS, etc. with non-Unix end-of-lines */
  fclose(inputFp);
  inputFp = fopen(fileName, "r");
  if (!inputFp) bug(43);

  /* Allocate space for the entire input file */
  fileBufSize = fileBufSize + 10;
            /* Add a factor for unknown text formats (just a guess) */
  fileBuf = malloc((size_t)fileBufSize);
  if (!fileBuf) {
    if (verbose) fprintf(stderr,
        "?Sorry, there was not enough memory to read the file \"%s\".\n",
        fileName);
    fclose(inputFp);
    return (NULL);
  }

  /* Put the entire input file into the buffer as a giant character string */
  charCount = (long)fread(fileBuf, sizeof(char), (size_t)fileBufSize - 2,
      inputFp);
  if (!feof(inputFp)) {
    fprintf(stderr, "Note:  This bug will occur if there is a disk file read error.\n");
    /* If this bug occurs (due to obscure future format such as compressed
       text files) we'll have to add a realloc statement. */
    bug(44);
  }
  fclose(inputFp);

  fileBuf[charCount] = 0;

  /* See if it's Unicode */
  /* This only handles the case where all chars are in the ASCII subset */
  if (charCount > 1) {
    if (fileBuf[0] == '\377' && fileBuf[1] == '\376') {
      /* Yes, so strip out null high-order bytes */
      if (2 * (charCount / 2) != charCount) {
        if (verbose) fprintf(stderr,
"?Sorry, there are an odd number of characters (%ld) %s \"%s\".\n",
            charCount, "in Unicode file", fileName);
        free(fileBuf);
        return (NULL);
      }
      i = 0; /* ASCII character position */
      j = 2; /* Unicode character position */
      while (j < charCount) {
        if (fileBuf[j + 1] != 0) {
          if (verbose) fprintf(stderr,
              "?Sorry, the Unicode file \"%s\" %s %ld at byte %ld.\n",
              fileName, "has a non-ASCII \ncharacter code",
              (long)(fileBuf[j]) + ((long)(fileBuf[j + 1]) * 256), j);
          free(fileBuf);
          return (NULL);
        }
        if (fileBuf[j] == 0) {
          if (verbose) fprintf(stderr,
              "?Sorry, the Unicode file \"%s\" %s at byte %ld.\n",
              fileName, "has a null character", j);
          free(fileBuf);
          return (NULL);
        }
        fileBuf[i] = fileBuf[j];
        /* Suppress any carriage-returns */
        if (fileBuf[i] == '\r') {
          i--;
        }
        i++;
        j = j + 2;
      }
      fileBuf[i] = 0; /* ASCII string terminator */
      charCount = i;
    }
  }

  /* Make sure the file has no carriage-returns */
  if (strchr(fileBuf, '\r') != NULL) {
    if (verbose) fprintf(stderr,
       "?Warning: the file \"%s\" has carriage-returns.  Cleaning them up...\n",
        fileName);
    /* Clean up the file, e.g. DOS or Mac file on Unix */
    i = 0;
    j = 0;
    while (j <= charCount) {
      if (fileBuf[j] == '\r') {
        if (fileBuf[j + 1] == '\n') {
          /* DOS file - skip '\r' */
          j++;
        } else {
          /* Mac file - change '\r' to '\n' */
          fileBuf[j] = '\n';
        }
      }
      fileBuf[i] = fileBuf[j];
      i++;
      j++;
    }
    charCount = i - 1; /* nm 6-Feb-04 */
  }

  /* Make sure the last line is not a partial line */
  if (fileBuf[charCount - 1] != '\n') {
    if (verbose) fprintf(stderr,
        "?Warning: the last line in file \"%s\" is incomplete.\n",
        fileName);
    /* Add the end-of-line */
    fileBuf[charCount] = '\n';
    charCount++;
    fileBuf[charCount] = 0;
  }

  if (fileBuf[charCount] != 0) {  /* nm 6-Feb-04 */
    bug(45); /* Keeping track of charCount went wrong somewhere */
  }

  /* Make sure there aren't null characters */
  i = (long)strlen(fileBuf);
  if (charCount != i) {
    if (verbose) {
      fprintf(stderr,
          "?Warning: the file \"%s\" is not an ASCII file.\n",
          fileName);
      fprintf(stderr,
          "Its size is %ld characters with null at character %ld.\n",
          charCount, strlen(fileBuf));
    }
  }

  /******* For debugging
  fprintf(stderr, "In binary mode the file has %ld bytes.\n", fileBufSize - 10);
  fprintf(stderr, "In text mode the file has %ld bytes.\n", charCount);
  *******/
  return ((char *)fileBuf);
} /* readFileToString */


/******************* End of main program ********************************/


/***********************************************************************/
/************ Start of "vstring" body stuff ****************************/
/************ Do not touch anything from here to end of program ********/
/***********************************************************************/

/*****************************************************************************/
/*       Copyright (C) 1999  NORMAN D. MEGILL  <nm at alum.mit.edu>          */
/*             License terms:  GNU General Public License                    */
/*****************************************************************************/

/**************************************************************************

Variable-length string handler
------------------------------

     This collection of string-handling functions emulate most of the
string functions of VMS BASIC.  The objects manipulated by these functions
are strings of a special type called 'vstring' which
have no pre-defined upper length limit but are dynamically allocated
and deallocated as needed.  To use the vstring functions within a program,
all vstrings must be initially set to the null string when declared or
before first used, for example:

        vstring string1 = "";
        vstring stringArray[] = {"","",""};

        vstring bigArray[100][10]; /- Must be initialized before using -/
        int i,j;
        for (i=0; i<100; i++)
          for (j=0; j<10; j++)
            bigArray[i][j] = ""; /- Initialize -/


     After initialization, vstrings should be assigned with the 'let(&'
function only; for example the statements

        let(&string1,"abc");
        let(&string1,string2);
        let(&string1,left(string2,3));

all assign the second argument to 'string1'.  The 'let(&' function must
not be used to initialize a vstring for the first time.

     The 'cat' function emulates the '+' concatenation operator in BASIC.
It has a variable number of arguments, and the last argument should always
be NULL.  For example,

        let(&string1,cat("abc","def",NULL));

assigns "abcdef" to 'string1'.  Warning: 0 will work instead of NULL on the
VAX but not on the Macintosh, so always use NULL.

     All other functions are generally used exactly like their BASIC
equivalents.  For example, the BASIC statement

        let string1$=left$("def",len(right$("xxx",2)))+"ghi"+string2$

is emulated in c as

        let(&string1,cat(left("def",len(right("xxx",2))),"ghi",string2,NULL));

Note that ANSI c does not allow "$" as part of an identifier
name, so the names in c have had the "$" suffix removed.

     The string arguments of the vstring functions may be either standard c
strings or vstrings (except that the first argument of the 'let(&' function
must be a vstring).  The standard c string functions may use vstrings or
vstring functions as their string arguments, as long as the vstring variable
itself (which is a char * pointer) is not modified and no attempt is made to
increase the length of a vstring.  Caution must be excercised when
assigning standard c string pointers to vstrings or the results of
vstring functions, as the memory space may be deallocated when the
'le(&t' function is next executed.  For example,

        char *stdstr; /- A standard c string pointer -/
         ...
        stdstr=left("abc",2);  /- DO NOT DO THIS -/

will assign "ab" to 'stdstr', but this assignment will be lost when the
next 'let(&' function is executed.  To be safe, use 'strcpy':

        char stdstr1[80]; /- A fixed length standard c string -/
         ...
        strcpy(stdstr1,left("abc",2));

Here, of course, the user must ensure that the string copied to 'stdstr1'
does not exceed 79 characters in length.  IT IS SAFEST NOT TO USE ANY
STANDARD C STRING FUNCTIONS WITH VSTRINGS OR VSTRING FUNCTIONS UNLESS YOU
REALLY UNDERSTAND WHAT YOU ARE DOING.

     The vstring functions ('left', 'right', 'cat', etc.) allocate temporary
memory whenever they are called.  This temporary memory is deallocated
whenever a 'let(&' assignment is made.  The user should be aware of this
when using vstring functions outside of 'let(&' assignments; for example

        for (i=0; i<10000; i++)
          print2("%s\n",left(string1,70));

will allocate another 70 bytes or so of memory each 'left' call
and eventually overflow the temporary string stack.
If necessary, dummy 'let(&' assignments can be made periodically to clear
this temporary memory:

        for (i=0; i<10000; i++)
          {
          print2("%s\n",left(string1,70));
          let(&dummy,"");
          }

It should be noted that the 'linput' function assigns its target string
with 'let(&' and thus has the same deallocation effect as 'let(&'.

************************************************************************/


static void freeTempAlloc(void)
{
  /* All memory previously allocated with tempAlloc is deallocated. */
  /* EXCEPT:  When startTempAllocStack != 0, the freeing will start at
     startTempAllocStack. */
  int i;
  for (i = startTempAllocStack; i < tempAllocStackTop; i++) {
    free(tempAllocStack[i]);
  }
  tempAllocStackTop = startTempAllocStack;
} /* freeTempAlloc */


static void pushTempAlloc(void *mem)
{
  if (tempAllocStackTop >= (MAX_ALLOC_STACK-1)) {
    printf("*** FATAL ERROR ***  Temporary string stack overflow\n");
    fflush(stdout);
    bug(46);
  }
  tempAllocStack[tempAllocStackTop++] = mem;
} /* pushTempAlloc */


static void* tempAlloc(long size)  /* String memory allocation/deallocation */
{
  void* memptr = malloc((size_t)size);
  if (!memptr || size == 0) {
    printf("*** FATAL ERROR ***  Temporary string allocation failed\n");
    fflush(stdout);
    bug(47);
  }
  pushTempAlloc(memptr);
  return memptr;
} /* tempAlloc */


/* Make string have temporary allocation to be released by next let() */
/* Warning:  after makeTempAlloc() is called, the vstring may NOT be
   assigned again with let() */
void makeTempAlloc(vstring s)
{
  pushTempAlloc(s);
} /* makeTempAlloc */


/* 8-Jul-2013 Wolf Lammen - rewritten to simplify it */
void let(vstring *target, vstring source)        /* String assignment */
/* This function must ALWAYS be called to make assignment to */
/* a vstring in order for the memory cleanup routines, etc. */
/* to work properly.  If a vstring has never been assigned before, */
/* it is the user's responsibility to initialize it to "" (the */
/* null string). */
{

  size_t sourceLength = strlen(source);  /* Save its length */
  size_t targetLength = strlen(*target); /* Save its length */
  if (targetLength < sourceLength) { /* Old string has not enough room for new one */
    /* Free old string space and allocate new space */
    if (targetLength)
      free(*target);  /* Free old space */
    *target = malloc(sourceLength + 1); /* Allocate new space */
    if (!*target) {
      printf("*** FATAL ERROR ***  String memory couldn't be allocated\n");
      fflush(stdout);
      bug(48);
    }
  }
  if (sourceLength) {
    strcpy(*target, source);
  } else {
    /* Empty strings could still be temporaries, so always assign a constant */
    if (targetLength) {
      free(*target);
    }
    *target= "";
  }

  freeTempAlloc(); /* Free up temporary strings used in expression computation */

} /* let */

vstring cat(vstring string1,...)        /* String concatenation */
#define MAX_CAT_ARGS 50
{
  va_list ap;   /* Declare list incrementer */
  vstring arg[MAX_CAT_ARGS];    /* Array to store arguments */
  size_t argPos[MAX_CAT_ARGS]; /* Array of argument positions in result */
  vstring result;
  int i;
  int numArgs = 0;        /* Define "last argument" */

  size_t pos = 0;
  char* curArg = string1;

  va_start(ap, string1); /* Begin the session */
  do {
        /* User-provided argument list must terminate with 0 */
    if (numArgs >= MAX_CAT_ARGS) {
      printf("*** FATAL ERROR ***  Too many cat() arguments\n");
      fflush(stdout);
      bug(49);
    }
    arg[numArgs] = curArg;
    argPos[numArgs] = pos;
    pos += strlen(curArg);
  } while (++numArgs, (curArg = va_arg(ap,char *)) != 0);
  va_end(ap);           /* End var args session */

  /* Allocate the memory for it */
  result = tempAlloc((long)pos+1);
  /* Move the strings into the newly allocated area */
  for (i = 0; i < numArgs; ++i)
    strcpy(result + argPos[i], arg[i]);
  return result;
} /* cat */


/* 20-Oct-2013 Wolf Lammen - allow unlimited input line lengths */
/* Input a line from the user or from a file */
/* Returns 1 if a (possibly empty) line was successfully read, 0 if EOF */
int linput(FILE *stream, const char* ask, vstring *target)
{                           /* Note: "vstring *target" means "char **target" */
  /*
    BASIC:  linput "what"; a$
    c:      linput(NULL, "what?", &a);

    BASIC:  linput #1, a$                         (error trap on EOF)
    c:      if (!linput(file1, NULL, &a)) break;  (break on EOF)

  */
  /* This function prints a prompt (if 'ask' is not NULL), gets a line from
    the stream, and assigns it to target using the let(&...) function.
    0 is returned when end-of-file is encountered.  The vstring
    *target MUST be initialized to "" or previously assigned by let(&...)
    before using it in linput. */
  char f[10001]; /* Read in chunks up to 10000 characters */
  int result = 0;
  int eol_found = 0;
  if (ask) {
    printf("%s", ask);
    fflush(stdout);
  }
  if (stream == NULL) stream = stdin;
  while (!eol_found && fgets(f, sizeof(f), stream))
  {
    size_t endpos = strlen(f) - 1;
    eol_found = (f[endpos] == '\n');
    /* If the last line in the file has no newline, eol_found will be 0 here.
       The fgets() above will return 0 and prevent another loop iteration. */
    if (eol_found)
      f[endpos] = 0; /* The return string will have any newline stripped. */
    if (result)
      /* Append additional parts of the line to *target */
      /* The let() reallocates *target and copies the concatenation of the
         old *target and the additional input f[] to it */
      let(target /* = &(*target) */, cat(*target, f, NULL));
    else
      /* This is the first time through the loop, and normally
         the only one unless the input line overflows f[] */
      let(target, f);  /* Allocate *target and copy f to it */
    result = 1;
  }
  return result;
} /* linput */


/* Find out the length of a string */
long len(vstring s)
{
  return ((long)strlen(s));
} /* len */


/* Extract sin from character position start to stop into sout */
vstring seg(vstring sin, long start, long stop)
{
  if (start < 1) start = 1;
  return mid(sin, start, stop - start + 1);
} /* seg */


/* Extract sin from character position start for length len */
vstring mid(vstring sin, long start, long length)
{
  vstring sout;
  if (start < 1) start = 1;
  if (length < 0) length = 0;
  sout=tempAlloc(length + 1);
  strncpy(sout,sin + start - 1, (size_t)length);
  sout[length] = 0;
  return (sout);
} /* mid */


/* Extract leftmost n characters */
vstring left(vstring sin,long n)
{
  return mid(sin, 1, n);
} /* left */


/* Extract after character n */
vstring right(vstring sin, long n)
{
  return seg(sin, n, (long)(strlen(sin)));
} /* right */


/* Emulate VMS BASIC edit$ command */
vstring edit(vstring sin,long control)
#define isblank_(c) ((c==' ') || (c=='\t'))
    /* 11-Sep-2009 nm Added _ to fix '"isblank" redefined' compiler warning */
{
  /* EDIT$ (from VMS BASIC manual)
       Syntax:  str-vbl = EDIT$(str-exp, int-exp)
       Values   Effect
       1        Trim parity bits
       2        Discard all spaces and tabs
       4        Discard characters: CR, LF, FF, ESC, RUBOUT, and NULL
       8        Discard leading spaces and tabs
       16       Reduce spaces and tabs to one space
       32       Convert lowercase to uppercase
       64       Convert [ to ( and ] to )
       128      Discard trailing spaces and tabs
       256      Do not alter characters inside quotes

       (non-BASIC extensions)
       512      Convert uppercase to lowercase
       1024     Tab the line (convert spaces to equivalent tabs)
       2048     Untab the line (convert tabs to equivalent spaces)
       4096     Convert VT220 screen print frame graphics to -,|,+ characters

       (Added 10/24/03:)
       8192     Discard CR only (to assist DOS-to-Unix conversion)
  */
  vstring sout;
  long i, j, k, m;
  int last_char_is_blank;
  int trim_flag, discardctrl_flag, bracket_flag, quote_flag, case_flag;
  int alldiscard_flag, leaddiscard_flag, traildiscard_flag, reduce_flag;
  int processing_inside_quote=0;
  int lowercase_flag, tab_flag, untab_flag, screen_flag, discardcr_flag;
  unsigned char graphicsChar;

  /* Set up the flags */
  trim_flag = control & 1;
  alldiscard_flag = control & 2;
  discardctrl_flag = control & 4;
  leaddiscard_flag = control & 8;
  reduce_flag = control & 16;
  case_flag = control & 32;
  bracket_flag = control & 64;
  traildiscard_flag = control & 128;
  quote_flag = control & 256;

  /* Non-BASIC extensions */
  lowercase_flag = control & 512;
  tab_flag = control & 1024;
  untab_flag = control & 2048;
  screen_flag = control & 4096; /* Convert VT220 screen prints to |,-,+
                                   format */
  discardcr_flag = control & 8192; /* Discard CR's */

  /* Copy string */
  i = (long)strlen(sin) + 1;
  if (untab_flag) i = i * 7; /* Allow for max possible length */
  sout=tempAlloc(i);
  strcpy(sout,sin);

  /* Discard leading space/tab */
  i=0;
  if (leaddiscard_flag)
    while ((sout[i] != 0) && isblank_(sout[i]))
      sout[i++] = 0;

  /* Main processing loop */
  while (sout[i] != 0) {

    /* Alter characters inside quotes ? */
    if (quote_flag && ((sout[i] == '"') || (sout[i] == '\'')))
       processing_inside_quote = ~ processing_inside_quote;
    if (processing_inside_quote) {
       /* Skip the rest of the code and continue to process next character */
       i++; continue;
    }

    /* Discard all space/tab */
    if ((alldiscard_flag) && isblank_(sout[i]))
        sout[i] = 0;

    /* Trim parity (eighth?) bit */
    if (trim_flag)
       sout[i] = sout[i] & 0x7F;

    /* Discard CR,LF,FF,ESC,BS */
    if ((discardctrl_flag) && (
         (sout[i] == '\015') || /* CR  */
         (sout[i] == '\012') || /* LF  */
         (sout[i] == '\014') || /* FF  */
         (sout[i] == '\033') || /* ESC */
         /*(sout[i] == '\032') ||*/ /* ^Z */ /* DIFFERENCE won't work w/ this */
         (sout[i] == '\010')))  /* BS  */
      sout[i] = 0;

    /* Discard CR */
    if ((discardcr_flag) && (
         (sout[i] == '\015')))  /* CR  */
      sout[i] = 0;

    /* Convert lowercase to uppercase */
    /*
    if ((case_flag) && (islower(sout[i])))
       sout[i] = toupper(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((case_flag) && (sout[i] >= 'a' && sout[i] <= 'z'))
       sout[i] = (char)(sout[i] - ('a' - 'A'));

    /* Convert [] to () */
    if ((bracket_flag) && (sout[i] == '['))
       sout[i] = '(';
    if ((bracket_flag) && (sout[i] == ']'))
       sout[i] = ')';

    /* Convert uppercase to lowercase */
    /*
    if ((lowercase_flag) && (isupper(sout[i])))
       sout[i] = tolower(sout[i]);
    */
    /* 13-Jun-2009 nm The upper/lower case C functions have odd behavior
       with characters > 127, at least in lcc.  So this was rewritten to
       not use them. */
    if ((lowercase_flag) && (sout[i] >= 'A' && sout[i] <= 'Z'))
       sout[i] = (char)(sout[i] + ('a' - 'A'));

    /* Convert VT220 screen print frame graphics to +,|,- */
    if (screen_flag) {
      graphicsChar = (unsigned char)sout[i]; /* Need unsigned char for >127 */
      /* vt220 */
      if (graphicsChar >= 234 && graphicsChar <= 237) sout[i] = '+';
      if (graphicsChar == 241) sout[i] = '-';
      if (graphicsChar == 248) sout[i] = '|';
      if (graphicsChar == 166) sout[i] = '|';
      /* vt100 */
      if (graphicsChar == 218 /*up left*/ || graphicsChar == 217 /*lo r*/
          || graphicsChar == 191 /*up r*/ || graphicsChar == 192 /*lo l*/)
        sout[i] = '+';
      if (graphicsChar == 196) sout[i] = '-';
      if (graphicsChar == 179) sout[i] = '|';
    }

    /* Process next character */
    i++;
  }
  /* sout[i]=0 is the last character at this point */

  /* Clean up the deleted characters */
  for (j = 0, k = 0; j <= i; j++)
    if (sout[j]!=0) sout[k++]=sout[j];
  sout[k] = 0;
  /* sout[k] = 0 is the last character at this point */

  /* Discard trailing space/tab */
  if (traildiscard_flag) {
    --k;
    while ((k >= 0) && isblank_(sout[k])) --k;
    sout[++k] = 0;
  }

  /* Reduce multiple space/tab to a single space */
  if (reduce_flag) {
    i = j = last_char_is_blank = 0;
    while (i <= k - 1) {
      if (!isblank_(sout[i])) {
        sout[j++] = sout[i++];
        last_char_is_blank = 0;
      } else {
        if (!last_char_is_blank)
          sout[j++]=' '; /* Insert a space at the first occurrence of a blank */
        last_char_is_blank = 1; /* Register that a blank is found */
        i++; /* Process next character */
      }
    }
    sout[j] = 0;
  }

  /* Untab the line */
  if (untab_flag || tab_flag) {

    /*
    DEF FNUNTAB$(L$)      ! UNTAB LINE L$
    I9%=1%
    I9%=INSTR(I9%,L$,CHR$(9%))
    WHILE I9%
      L$=LEFT(L$,I9%-1%)+SPACE$(8%-((I9%-1%) AND 7%))+RIGHT(L$,I9%+1%)
      I9%=INSTR(I9%,L$,CHR$(9%))
    NEXT
    FNUNTAB$=L$
    FNEND
    */

    /***** old code (doesn't handle multiple lines)
    k = (long)strlen(sout);
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((i - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((i - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((i - 1) & 7);
    }
    *****/

    /* Untab string containing multiple lines */ /* 9-Jul-2011 nm */
    /* (Currently this is needed by outputStatement() in mmpars.c) */
    k = (long)strlen(sout);
    m = 0;  /* Position on line relative to last '\n' */
    for (i = 1; i <= k; i++) {
      if (sout[i - 1] == '\n') {
        m = 0;
        continue;
      }
      m++; /* Should equal i for one-line string */
      if (sout[i - 1] != '\t') continue;
      for (j = k; j >= i; j--) {
        sout[j + 8 - ((m - 1) & 7) - 1] = sout[j];
      }
      for (j = i; j < i + 8 - ((m - 1) & 7); j++) {
        sout[j - 1] = ' ';
      }
      k = k + 8 - ((m - 1) & 7);
    }
  }

  /* Tab the line */
  /* (Note that this does not [yet?] handle string with multiple lines) */
  if (tab_flag) {

    /*
    DEF FNTAB$(L$)        ! TAB LINE L$
    I9%=0%
    FOR I9%=8% STEP 8% WHILE I9%<LEN(L$)
      J9%=I9%
      J9%=J9%-1% UNTIL ASCII(MID(L$,J9%,1%))<>32% OR J9%=I9%-8%
      IF J9%<=I9%-2% THEN
        L$=LEFT(L$,J9%)+CHR$(9%)+RIGHT(L$,I9%+1%)
        I9%=J9%+1%
      END IF
    NEXT I9%
    FNTAB$=L$
    FNEND
    */

    k = (long)strlen(sout);
    for (i = 8; i < k; i = i + 8) {
      j = i;

      /* 26-May-2016 nm */
      /* gcc m*.c -o metamath.exe -O2 -Wall was giving:
             mmvstr.c:285:9: warning: assuming signed overflow does not occur
             when assuming that (X - c) <= X is always true [-Wstrict-overflow]
         Here we trick gcc into turning off this optimization by moving
         the computation of i - 2 here, then referencing m instead of i - 2
         below.  Note that if "m = i - 2" is moved _after_ the "while", the
         error message returns. */
      m = i - 2;

      while (sout[j - 1] == ' ' && j > i - 8) j--;
      /*if (j <= i - 2) {*/
      if (j <= m) {  /* 25-May-2016 nm */
        sout[j] = '\t';
        j = i;
        while (sout[j - 1] == ' ' && j > i - 8 + 1) {
          sout[j - 1] = 0;
          j--;
        }
      }
    }
    i = k;
    /* sout[i]=0 is the last character at this point */
    /* Clean up the deleted characters */
    for (j = 0, k = 0; j <= i; j++)
      if (sout[j] != 0) sout[k++] = sout[j];
    sout[k] = 0;
    /* sout[k] = 0 is the last character at this point */
  }

  return (sout);
} /* edit */


/* Return a string of the same character */
vstring string(long n, char c)
{
  vstring sout;
  long j = 0;
  if (n < 0) n = 0;
  sout=tempAlloc(n + 1);
  while (j < n) sout[j++] = c;
  sout[j] = 0;
  return (sout);
} /* string */


/* Return a string of spaces */
vstring space(long n)
{
  return (string(n, ' '));
} /* space */


/* Return a character given its ASCII value */
vstring chr(long n)
{
  vstring sout;
  sout = tempAlloc(2);
  sout[0] = (char)(n & 0xFF);
  sout[1] = 0;
  return(sout);
} /* chr */


/* Search for string2 in string1 starting at start_position */
/* If there is no match, 0 is returned */
/* If string2 is "", (length of the string) + 1 is returned */
long instr(long start_position, vstring string1, vstring string2)
{
  char *sp1, *sp2;
  long ls1, ls2;
  long found = 0;
  if (start_position < 1) start_position = 1;
  ls1 = (long)strlen(string1);
  ls2 = (long)strlen(string2);
  if (start_position > ls1) start_position = ls1 + 1;
  sp1 = string1 + start_position - 1;
  while ((sp2 = strchr(sp1, string2[0])) != 0) {
    if (strncmp(sp2, string2, (size_t)ls2) == 0) {
      found = sp2 - string1 + 1;
      break;
    } else
      sp1 = sp2 + 1;
  }
  return (found);
} /* instr */


/* 12-Jun-2011 nm Added rinstr */
/* Search for _last_ occurrence of string2 in string1 */
/* 1 = 1st string character; 0 = not found */
/* ??? Future - this could be made more efficient by searching directly,
   backwards from end of string1 */
long rinstr(vstring string1, vstring string2)
{
  long pos = 0;
  long savePos = 0;

  while (1) {  /* Scan until substring no longer found */
    pos = instr(pos + 1, string1, string2);
    if (!pos) break;
    savePos = pos;
  }
  return (savePos);
} /* rinstr */


/* Translate string in sin to sout based on table.
   Table must be 256 characters long!! <- not true anymore? */
vstring xlate(vstring sin,vstring table)
{
  vstring sout;
  long len_table, len_sin;
  long i, j;
  long table_entry;
  char m;
  len_sin = (long)strlen(sin);
  len_table = (long)strlen(table);
  sout = tempAlloc(len_sin+1);
  for (i = j = 0; i < len_sin; i++)
  {
    table_entry = 0x000000FF & (long)sin[i];
    if (table_entry < len_table)
      if ((m = table[table_entry])!='\0')
        sout[j++] = m;
  }
  sout[j]='\0';
  return (sout);
} /* xlate */


/* Returns the ascii value of a character */
long ascii_(vstring c)
{
  return ((long)c[0]);
} /* ascii_ */


/* Returns the floating-point value of a numeric string */
double val(vstring s)
{
  double v = 0;
  char signFound = 0;
  double power = 1.0;
  long i;
  for (i = (long)strlen(s); i >= 0; i--) {
    switch (s[i]) {
      case '.':
        v = v / power;
        power = 1.0;
        break;
      case '-':
        signFound = 1;
        break;
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
        v = v + ((double)(s[i] - '0')) * power;
        power = 10.0 * power;
        break;
    }
  }
  if (signFound) v = - v;
  return v;
  /*
  return (atof(s));
  */
} /* val */


/* Returns current date as an ASCII string */
vstring date()
{
  vstring sout;
  struct tm *time_structure;
  time_t time_val;
  char *month[12];

  /* (Aggregrate initialization is not portable) */
  /* (It must be done explicitly for portability) */
  month[0] = "Jan";
  month[1] = "Feb";
  month[2] = "Mar";
  month[3] = "Apr";
  month[4] = "May";
  month[5] = "Jun";
  month[6] = "Jul";
  month[7] = "Aug";
  month[8] = "Sep";
  month[9] = "Oct";
  month[10] = "Nov";
  month[11] = "Dec";

  time(&time_val); /* Retrieve time */
  time_structure = localtime(&time_val); /* Translate to time structure */
  sout = tempAlloc(12);
  /* "%02d" means leading zeros with min. field width of 2 */
  /* sprintf(sout,"%d-%s-%02d", */
  sprintf(sout,"%d-%s-%04d", /* 10-Apr-06 nm 4-digit year */
      time_structure->tm_mday,
      month[time_structure->tm_mon],
      /* time_structure->tm_year); */ /* old */
      /* (int)((time_structure->tm_year) % 100)); */ /* Y2K */
      (int)((time_structure->tm_year) + 1900)); /* 10-Apr-06 nm 4-digit yr */
  return(sout);
} /* date */


/* Return current time as an ASCII string */
vstring time_()
{
  vstring sout;
  struct tm *time_structure;
  time_t time_val;
  int i;
  char *format;
  char *format1 = "%d:%d %s";
  char *format2 = "%d:0%d %s";
  char *am_pm[2];
  /* (Aggregrate initialization is not portable) */
  /* (It must be done explicitly for portability) */
  am_pm[0] = "AM";
  am_pm[1] = "PM";

  time(&time_val); /* Retrieve time */
  time_structure = localtime(&time_val); /* Translate to time structure */
  if (time_structure->tm_hour >= 12)
    i = 1;
  else
    i = 0;
  if (time_structure->tm_hour > 12)
    time_structure->tm_hour -= 12;
  if (time_structure->tm_hour == 0)
    time_structure->tm_hour = 12;
  sout = tempAlloc(12);
  if (time_structure->tm_min >= 10)
    format = format1;
  else
    format = format2;
  sprintf(sout,format,
      time_structure->tm_hour,
      time_structure->tm_min,
      am_pm[i]);
  return(sout);
} /* time */


/* Return a number as an ASCII string */
vstring str(double f)
{
  /* This function converts a floating point number to a string in the */
  /* same way that %f in printf does, except that trailing zeroes after */
  /* the one after the decimal point are stripped; e.g., it returns 7 */
  /* instead of 7.000000000000000. */
  vstring s;
  long i;
  s = tempAlloc(50);
  sprintf(s,"%f", f);
  if (strchr(s, '.') != 0) { /* The string has a period in it */
    for (i = (long)strlen(s) - 1; i > 0; i--) {  /* Scan string backwards */
      if (s[i] != '0') break; /* 1st non-zero digit */
      s[i] = 0; /* Delete the trailing 0 */
    }
    if (s[i] == '.') s[i] = 0; /* Delete trailing period */
  }
  return (s);
} /* str */


/* Return a number as an ASCII string */
/* (This may have differed slightly from str() in BASIC but I forgot how.
   It should be considered deprecated.) */
vstring num1(double f)
{
  return (str(f));
} /* num1 */


/* Return a number as an ASCII string surrounded by spaces */
/* (This should be considered deprecated.) */
vstring num(double f)
{
  return (cat(" ",str(f)," ",NULL));
} /* num */



/*** NEW FUNCTIONS ADDED 11/25/98 ***/

/* Emulate PROGRESS "entry" and related string functions */
/* (PROGRESS is a 4-GL database language) */

/* A "list" is a string of comma-separated elements.  Example:
   "a,b,c" has 3 elements.  "a,b,c," has 4 elements; the last element is
   an empty string.  ",," has 3 elements; each is an empty string.
   In "a,b,c", the entry numbers of the elements are 1, 2 and 3 (i.e.
   the entry numbers start a 1, not 0). */

/* Returns a character string entry from a comma-separated
   list based on an integer position. */
/* If element is less than 1 or greater than number of elements
   in the list, a null string is returned. */
vstring entry(long element, vstring list)
{
  vstring sout;
  long commaCount, lastComma, i, length;
  if (element < 1) return ("");
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) commaCount++;
  if (element > commaCount) return ("");
  length = i - lastComma - 1;
  if (length < 1) return ("");
  sout = tempAlloc(length + 1);
  strncpy(sout, list + lastComma + 1, (size_t)length);
  sout[length] = 0;
  return (sout);
}

/* 6-Oct-2016 nm */
/* Returns a character string entry from a 'c'-separated
   list based on an integer position. */
/* If element is less than 1 or greater than number of elements
   in the list, a null string is returned. */
vstring entry2(long element, vstring list, char c)
{
  vstring sout;
  long commaCount, lastComma, i, length;
  if (element < 1) return ("");
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == c) {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) commaCount++;
  if (element > commaCount) return ("");
  length = i - lastComma - 1;
  if (length < 1) return ("");
  sout = tempAlloc(length + 1);
  strncpy(sout, list + lastComma + 1, (size_t)length);
  sout[length] = 0;
  return (sout);
}

/* Emulate PROGRESS lookup function */
/* Returns an integer giving the first position of an expression
   in a comma-separated list. Returns a 0 if the expression
   is not in the list. */
long lookup(vstring expression, vstring list)
{
  long i, exprNum, exprPos;
  char match;

  match = 1;
  i = 0;
  exprNum = 0;
  exprPos = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      exprNum++;
      if (match) {
        if (expression[exprPos] == 0) return exprNum;
      }
      exprPos = 0;
      match = 1;
      i++;
      continue;
    }
    if (match) {
      if (expression[exprPos] != list[i]) match = 0;
    }
    i++;
    exprPos++;
  }
  exprNum++;
  if (match) {
    if (expression[exprPos] == 0) return exprNum;
  }
  return 0;
}


/* Emulate PROGRESS num-entries function */
/* Returns the number of items in a comma-separated list.  If the
   list is the empty string, return 0. */
long numEntries(vstring list)
{
  long i, commaCount;
  if (list[0] == 0) {
    commaCount = -1; /* 26-Apr-2006 nm Return 0 if list empty */
  } else {
    commaCount = 0;
    i = 0;
    while (list[i] != 0) {
      if (list[i] == ',') commaCount++;
      i++;
    }
  }
  return (commaCount + 1);
}

/* 6-Oct-2016 nm */
/* Emulate PROGRESS num-entries function */
/* Returns the number of items in a 'c'-separated list.  If the
   list is the empty string, return 0. */
long numEntries2(vstring list, char c)
{
  long i, commaCount;
  if (list[0] == 0) {
    commaCount = -1; /* 26-Apr-2006 nm Return 0 if list empty */
  } else {
    commaCount = 0;
    i = 0;
    while (list[i] != 0) {
      if (list[i] == c) commaCount++;
      i++;
    }
  }
  return (commaCount + 1);
}

/* Returns the character position of the start of the
   element in a list - useful for manipulating
   the list string directly.  1 means the first string
   character. */
/* If element is less than 1 or greater than number of elements
   in the list, a 0 is returned.  If entry is null, a 0 is
   returned. */
long entryPosition(long element, vstring list)
{
  long commaCount, lastComma, i;
  if (element < 1) return 0;
  lastComma = -1;
  commaCount = 0;
  i = 0;
  while (list[i] != 0) {
    if (list[i] == ',') {
      commaCount++;
      if (commaCount == element) {
        break;
      }
      lastComma = i;
    }
    i++;
  }
  if (list[i] == 0) {
    if (i == 0) return 0;
    if (list[i - 1] == ',') return 0;
    commaCount++;
  }
  if (element > commaCount) return (0);
  if (list[lastComma + 1] == ',') return 0;
  return (lastComma + 2);
}


void print2(char* fmt,...)
{
  /* This performs the same operations as printf, except that if a log file is
    open, the characters will also be printed to the log file. */
  va_list ap;
  char printBuffer[10001];

  va_start(ap, fmt);
  vsprintf(printBuffer, fmt, ap); /* Put formatted string into buffer */
  va_end(ap);

  printf("%s", printBuffer); /* Terminal */

  if (fplog != NULL) {
    fprintf(fplog, "%s", printBuffer);  /* Print to log file */
  }
  return;
}


/* Bug check */
void bug(int bugNum)
{
  fprintf(stderr, "?Error: Program bug # %d\n", bugNum);
  exit(0);
}


/* Opens files with error message; opens output files with
   backup of previous version.   Mode must be "r" or "w". */
FILE *fSafeOpen(vstring fileName, vstring mode)
{
  FILE *fp;
  vstring prefix = "";
  vstring postfix = "";
  vstring bakName = "";
  vstring newBakName = "";
  long v;

  if (!strcmp(mode, "r")) {
    fp = fopen(fileName, "r");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }
    return (fp);
  }

  if (!strcmp(mode, "w")) {
    /* See if the file already exists. */
    fp = fopen(fileName, "r");

    if (fp) {
      fclose(fp);

#define VERSIONS 9
      /* The file exists.  Rename it. */

#if defined __WATCOMC__ /* MSDOS */
      /* Make sure file name before extension is 8 chars or less */
      i = instr(1, fileName, ".");
      if (i) {
        let(&prefix, left(fileName, i - 1));
        let(&postfix, right(fileName, i));
      } else {
        let(&prefix, fileName);
        let(&postfix, "");
      }
      let(&prefix, cat(left(prefix, 5), "~", NULL));
      let(&postfix, cat("~", postfix, NULL));
      if (0) goto skip_backup; /* Prevent compiler warning */

#elif defined __GNUC__ /* Assume unix */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined THINK_C /* Assume Macintosh */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#elif defined VAXC /* Assume VMS */
      /* For debugging on VMS: */
      /* let(&prefix, cat(fileName, "-", NULL));
         let(&postfix, "-"); */
      /* Normal: */
      goto skip_backup;

#else /* Unknown; assume unix standard */
      /*if (1) goto skip_backup;*/  /* [if no backup desired] */
      let(&prefix, cat(fileName, "~", NULL));
      let(&postfix, "");

#endif


      /* See if the lowest version already exists. */
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      fp = fopen(bakName, "r");
      if (fp) {
        fclose(fp);
        /* The lowest version already exists; rename all to lower versions. */

        /* If version VERSIONS exists, delete it. */
        let(&bakName, cat(prefix, str(VERSIONS), postfix, NULL));
        fp = fopen(bakName, "r");
        if (fp) {
          fclose(fp);
          remove(bakName);
        }

        for (v = VERSIONS - 1; v >= 1; v--) {
          let(&bakName, cat(prefix, str((double)v), postfix, NULL));
          fp = fopen(bakName, "r");
          if (!fp) continue;
          fclose(fp);
          let(&newBakName, cat(prefix, str((double)(v + 1)), postfix, NULL));
          rename(bakName, newBakName);
        }

      }
      let(&bakName, cat(prefix, str(1), postfix, NULL));
      rename(fileName, bakName);

      /***
      printLongLine(cat("The file \"", fileName,
          "\" already exists.  The old file is being renamed to \"",
          bakName, "\".", NULL), "  ", " ");
      ***/
    } /* End if file already exists */
   /*skip_backup:*/

    fp = fopen(fileName, "w");
    if (!fp) {
      print2("?Sorry, couldn't open the file \"%s\".\n", fileName);
    }

    let(&prefix, "");
    let(&postfix, "");
    let(&bakName, "");
    let(&newBakName, "");

    return (fp);
  } /* End if mode = "w" */

  bug(50); /* Illegal mode */
  return(NULL);

}

/***********************************************************************/
/************ End of "vstring" body stuff ******************************/
/***********************************************************************/
